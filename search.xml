<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019_year_end_summary]]></title>
    <url>%2F2019%2F12%2F25%2F2019-year-end-summary%2F</url>
    <content type="text"><![CDATA[2019年终总结暨2020年的展望先占个坑，这几天慢慢把年度总结写一下吧！这一年有过遗憾也有过精彩的时刻，有过欢乐也有过失落的时候，我想好好地写一写今年的感受 现在看来去年给自己订的目标好像大多都成了flag(哭哭)嘛，虽然确实成了flag但还是要一个一个说吧1.每天坚持刷算法题，刷完洛谷提高组的题目 这个确实是没有坚持下来，有的时候甚至一个星期都没有做几道算法题。未来打算就是去每天参加leetcode上的周赛和双周赛以及洛谷上的相关题目反正2020年一定要好好坚持下来！ 2.学习C++，java什么的 咳咳，这个目标和我当初想的差距比较远，去年的这个时候还没有意识到现在该干嘛，C++和java其实两个学好一个就行了，所以明年会继续学好C++呢 3.学习前端三件套(html+css+js) 这个本来在寒假我其实就学的差不多了，但是大半年没用了估计也忘得差不多了，所以给我的启示就是你决定做什么事情一定要经常去做去练去刷题去实践才行吧。 4.每天学习英语,6月一次性过6级 每天学习英语这个还是没有坚持下来，但是6月份确实一次性的过了六级还是让我很开心吧，但是考的分数并不高，12月份准备刷分来着但是也没有好好的去准备只是又裸考了一次，嘛，明年要坚持每天学习英语并且养成阅读的习惯，重点准备考研英语吧。 5.每周刷数学一题目，准备考研 这个确实没有坚持下来， (未完待续………………………)]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191216]]></title>
    <url>%2F2019%2F12%2F16%2F20191216%2F</url>
    <content type="text"><![CDATA[都好起来了呢最近一直都在发生好的事情，而且是一连串的发生，好像并不算是巧合呢。上个星期三的早晨，本来是很平淡的一天，我还在漫不经心的复习着英语，突然知乎上有人私信我. 本来以为又是知乎管理员之类的私信，正想把碍眼的那个消息的小红点给按掉的时候. 原来是那个人重新注册知乎然后发现了我留下的呼唤重新找到了我一瞬间，开心激动的心情瞬间充满了我的脑海里面. 可能这就是所谓的缘分所谓的幸福吗？ 当你发现原来曾经做过很多不可挽回的事情突然发现有了新的转机的那种感受，真的很难言说出来. 再重新看看几个月前自己写下的怨恨的话，写下的种种不满，在现在看来是多么的幼稚多么的可笑，也许人不经历点事情是不会成长的吧. 所以以后我也不会说自己多么多么的成熟，因为在很多事情面前自己都还只能够算是一个孩子罢了。希望今后能够不断的进步不断的成长吧. rebegin]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191209]]></title>
    <url>%2F2019%2F12%2F09%2F20191209%2F</url>
    <content type="text"><![CDATA[炒鸡开心的两天！！！！！好开心好开心好开心啊，这几天发生的事情让我从心底里感受到了什么叫做真正的快乐，虽然在别人眼里看来可能真的没什么，但是对于我来说确实算是一个挺不错的经历了吧 先说说比赛的相关的事情吧，从二十多天前就知道了校赛要来了，原来的我对待这种事情都是特别犹豫的，各种各方面的原因都会困扰着我不敢勇敢的做出最终的选择正因为如此，我可能在大学这两三年的过程中错过了一个又一个的机会吧，比如上个学期本来是有机会去参加我喜欢的社团来着，但是当时我觉得自己已经大二了，已经错过了最好的加入的机会了，然后我就没去参加，但是我的室友去参加了，然后我只能眼睁睁的看着我的室友在社团里面交到好多朋友，认识到好多大佬，现在想想还是后悔的要死，因为大学明明有这么多的人，我却没机会认识到别人(潜意识里面我是觉得交朋友的话至少要到同一个水平上，不然很容易就躺列了之类的，这并不是我想要看到的结果)，可能我就是这么一个人吧，不满足自己的现状希望不断改变来提升自己，可能只有自己哪天成为了自己心目中想要成为的人我才会停止脚步吗(但很明显不会有那么一天) 咳咳，还是回到正题上来吧，我不想再错过这一次校赛的机会，不管我多老不管我多捞，我希望大学里面能够尽可能的多参加比赛啊，错过了现在的机会等我真正老了哪还会再有能够拼搏的机会呢？ 于是我选择了参加，和一个朋友再拉了一个他的同学我们三个人于是便组成了一个队伍，在前半个月里面我们并没有在一起配合着练习，而是在图书馆里面选择了自己提升自己，虽然现在看来我在这半个月准备的时间还是有所不足，在学习的过程中最大的感受就是一定要做笔记才行，因为很可能你半个月前学过的东西你半个月之后再看就完全不懂了，现在就是我之前暑假学过的很多知识点我现在再看又完全不懂了，等于我的暑假相当于白费的感觉，不仅是今年的暑假，以前的两年也是差不多的这样子，养不成每天学习每天刷题的习惯，也就是半途而废的那种，每次都是等到期中或者期末考试就要中断一段时间的学习，然后长时间不去刷leetcode或者洛谷之类的OJ就完全不习惯了，然后过半个月就又傻眼了所以这次我不想再重蹈覆辙了，因为留给自己的时间也不多了，12月到寒假结束的2月可能是我最后提升自己的机会了，也许人都是到了最后的关头才会急的人吧，再过一年零半个月不到的时间就是我去考研的时间了，当那种限期到来的时候的感觉是真的很煎熬，我希望我每天能过的充实起来，不仅只是在学习上，也可以在很多其他方面上呢，比如写写日记，刷刷知乎答答题之类的亦或者做做自己喜欢的视频啊，我觉得都是很有意义的事情呢~~那种感觉就好像是真正的找到了自己人生目标的感觉，虽然我现在还没有真正的意识到自己真正喜欢哪个领域的内容，但是我平时喜爱的东西已经能够让我兴奋起来了，也能够从中学到很多东西，这种东西这种感觉果然是别人教不来的，也许恋爱也会是这种样子吗(我到底在想什么啊) 诶多，好像又偏题了呢，咳咳，到了比赛的前三天我们才正式见面，第一天更是只匆匆的认识了下，然后第二天和第三天我们打印了试题去模拟了下试题，虽然模拟的感觉让我们感觉自己的水平还不太够，但是也别无办法了，毕竟只有短短的三天供我们去模拟了 然后就真正到了昨天的比赛日了，还是挺难忘的一天吧！早晨七点就被昨天已经约定好的老爸打电话把我叫醒，醒的时候整个人的精神状态还算是不错吧，前一天十一点左右就睡着了(幸好我的室友还算是好说话的人，要按照平时估计要开黑开到十二点之后，但我这次说了明天有比赛的话他们就挺安静的了) 诶多，然后就起床了，肚子巨不舒服，去上了厕所之后还是不太舒服，这个不适感一直伴随到我比赛临近开始都没有消除，和同学一起去了比赛的场地拿了参赛证，还有个吊牌(看起来还蛮正规的，好歹也是个校赛吧)算是个参加比赛的证明了，就算没得奖的话(我这么想着，起码不要报名费吧)，然后等到开幕式了，开幕式上真的是好多大佬啊，还有大佬代表来发言(这就是我想要的目标啊)，他们在自己的专业去参加比赛不仅提升自己的水平，为自己将来的发展铺平了道路，而且还很可能能够得到保研的资格，是我梦想中想要的生活(还是当初吃了选择的亏，这点深有体会以后有机会再聊聊吧) 从开幕式上我了解到一共有将近一百五十支队伍四百多个人来参加这个比赛，这个队伍在我看来是有点多了，不过我也并没有害怕，反倒是觉得越来越有意思了，想看看我跟别人队伍的差距到底在哪，嗯，然后就进了机房去调试机器了，上午的热身赛真的是让我一言难尽，三道题目其中两道题考到了素数，还有一道题考到了脑筋急转弯，我对素数什么的还不算很熟悉…欧拉筛什么的，反正就是很难受，但是已经到了比赛的那天了也顾不上那么多了。 十一点一起去食堂去吃饭，下午一点就要开始比赛也不敢吃太多，毕竟肚子还不是很舒服了，点了个小份的大盘鸡也没吃太饱就回宿舍了，十二点差一刻戴耳机睡觉，一直趴到了十二点半，没睡着，戴着耳机懵懵地趴了半天，然后洗了个脸清醒了，于是和队友就直接去比赛的场地了。 到了上午调试过的位置以后，周围已经是有很多人了，那种气氛有点压抑但是也没什么办法只能硬着头皮上了，嗯，很平静的就宣布比赛开始了，发了三本题目的册子和比赛账号，于是我们便开始为期四个小时的比赛了，一开始我从后面的K题开始看，然后其他人从前面的A题开始看，我们看到了几道签到题，于是我开始写K题到OJ上，可惜出事不利，我好像忘了特殊的情况，直接上来WA呜呜，队友刚开始也看着很不开心的样子，又试了一次继续WA，吓得我赶紧退下主位来给大佬去坐，自己赶紧装装样子去看别的题(其实当时心里是有点不开心，毕竟开门”红”确实让人很难受)，好在后来我们及时调整了状态，先就把签到题全部A了，然后再去思考那几题还有点思路的题，具体的过程就不细说了，反正过程算是很惊险的，其中最重要的就是两道重要的题我们A出来了，一道是C题一道是E题，虽然我自己A了E，也给大佬提供了C题的思路，我觉得我在这次比赛里面的功劳勉强还算大吧_(:」∠)，但是没有大佬的帮助我觉得我们这次连二等估计都莫得嘤嘤嘤，其中最遗憾的就是本来如果时间策略好一点我们其实可以再A出一道题就能拿一等奖甚至第一了(还是有点耿耿于怀噫)但是总体上的结果也算是让我满意了吧，起码也不枉费我这几十天的努力吧！最后朋友还请了我们俩吃了顿饭，我觉得这顿饭可能是最温馨最香的一次饭吧，毕竟是用我们共同的努力所换来的。 说完了第一件比赛的事，第二件事可能就是蓝桥杯报名的一件事了吧，这件事也是让我整整难受了一个多星期吧，以为这个比赛是个人都能随便报的，结果还是要院校一起报名，但是众所周知我的专业是不负责这个比赛的，结果就是我只好去通过别的院的老师去报名，但是别的院的老师告诉我要去找自己院负责竞赛的老师去联系才行，但是我那个专业又没负责这个比赛的，所以就非常的矛盾，然后拖了几天吧，好多人互相推皮球好像都不想负责(三百多的报名费都不想赚真的是)好在今天终于是解决了，真心想感谢那个组委会老师，虽然是被规则所限定了，但是一直在给我想办法，给了我好几个老师的电话去主动拨打去联系，简单的一句“不行再来找我”真的是给了我莫名的信心，让我的心非常温暖，虽然在别人看来这可能只是一件微不足道的小事，但是在我很绝望很心塞的时候，组委会老师坚定的承诺确实是给了我莫名的鼓舞，他也从不耐烦语气也很温柔，以后我如果能够成为给别人带来价值，能够帮助他人的人我觉得其实也很棒呢！ 所以，大概这就是这几十天以及这两天发生的故事吧，坚持学习然后心里煎熬了那么就大概也终于到了结束的时候吧，看着自己在日程表上一天一天划日期，虽然没怎么按着自己的计划来进行，但是结束之后再看会觉得自己心里有种很温暖的感觉。没错，既是结束，也是一个新的开始，我从这个过程里面也了解了很多，也学到了很多，对自己最近几年的人生目标萌发了点自己的想法，虽然还不是很清晰，但我相信只要能坚持那些好的习惯坚持自己的爱好，虽然今年立的flag确实没怎么完成，但是我希望，明年的这个时候我能够胸有成竹，意气风发！但是这绝不只是口里说说就能够成功的。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra]]></title>
    <url>%2F2019%2F11%2F30%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[浅谈Djikstra算法前言：前几天在算法笔记上看到了晴神对于最短路径算法Dijikstra的一个深入的分析，我感觉挺感兴趣的，顺便想借此机会来深入分析，顺带也是更新下博客了咳咳，顺带说一句我的博客看起来挺乱的，等有时间会做一个分类吧，但我不想把它变成单纯的一个技术博客，而是记录一个我的学习，生活，感悟，以及展示自己兴趣爱好的地方(虽然现在从哪方面看上去这人都挺low的) 好吧，那就开始我对Djikstra算法的认识吧 从最短路径算法Djikstra初谈什么是Djikstra? 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 这是百度百科上的定义，用我们生活中的例子来讲就相当于我们每天在地图上用的导航，导航可以帮我们在错综复杂的街道上，找到一条从出发地到达终点的最短路径 所以我们需要一个好的算法来干这事，而这种算法就叫做最短路算法(SSSP) 而其中Djikstra算法就是最短路算法中的一种(当然也是最简单的一种) 至于为什么叫Djikstra算法，因为Dijkstra算法是由一个叫Dijkstra的荷兰人发明的，故称此算法为Dijkstra算法。(怎么这么多废话) 好了，那现在进入正题 Dijkstra算法的工作原理？因为这个算法是为了求出来在一系列限制条件下两个地方的最短路径，那么我们一般怎么找到从一个地方到另外一个地方的最短路呢？ 对，我们首先得有一张地图才行啊 就拿我国庆去上海玩的经历来说吧 你现在刚从火车站出来搭地铁到人民广场这个下站了，天色已经很晚了，，但是你突然想走去黄浦江边的外滩去看风景 你可能要问，诶我为什么不继续坐地铁到那个南京东路下站然后再走去外滩啊，这样不是更近吗？(然鹅不幸的是国庆的前几天南京东站的晚上基本上都是被封的) 所以你只能选择走去外滩，当然你不可能像红色箭头这样飞过去了，不然警察叔叔会罚你 $10^{10} RMB的，所以你只能找到合适的道路走过去，也就是说你只能走那些标记为“路”的地方 于是我们就可以把每一个路口或建筑看作一个点，有些点与另一些点之间有边连接，这个边其实就是马路，连结了两个地方。 当然，有些马路的车流量比较大，有些在比较小；于是有的马路通过需要花费的时间多，有的花费的时间少。我们把一条马路通过所需要花费的时间，称作这条边的权值。所有的点和边连在一起，就成为了一个图。(没错如果你想直接从人民广场直接直接走到外滩几乎是不可能的，人流量可以把你窒息死) 图这种东西大概长这样： 一个圆就是一个点，圆上的数字是点的序号，绿色的线是边，边旁边的橙色数字是边的权值。之所以加上箭头，是因为我们假设所有马路都是单行线（双向车道改成两条单向车道不就好了）。 具体的Dijikstra算法的证明过程在这里不再给出，具体的过程可以自行百度好了(其实是我的证明水平还8太行) 但是djikstra算法不适用于有负边权的图，在这里不再赘述(才不会告诉你别人已经有更好的解释了啦) 戳这里 对我的理解来说，Djikstra算法最直观的一个解释就是以起点开始寻找有没有其他中介点能够使起点到达其他顶点的距离能够变小 Djikstra算法的一个伪代码12345678910111213141516bool vis[maxn] = &#123;false&#125;;void Djikstra(G, d[],s)&#123; 初始化 for(循环n次)&#123; u = 使d[u]最小的还未访问的顶点的标号 vis[u] = true;//记下u已被访问 for(从u出发能到达的所有顶点v)&#123; if(vis[v] == false &amp;&amp; 以u为中介点使s到达顶点v的最短距离d[v]更优) &#123; 优化d[v]; &#125; &#125; &#125;&#125; 其中G为邻接矩阵，s为起点 vis[i] == true时表示顶点Vi已被访问，vis[i] == false时表示顶点Vi还未访问 d[]表示起点s到达顶点Vi的最短距离，初始化时除了起点的d[s]赋为0，其余的顶点都赋予一个很大的数(比如INT_MAX或者自己赋一个很大的INF)(即相当于把除了起点与其他顶点的边权确认后，其余各个顶点之间的距离设为无穷大(即INF)，这样可以保证后来各个点的最短距离d[i]都是从起点s得来的) 举一个简单的例子拿一个简单的有向图来举例子吧 起点的d[s] = 0，其余点的d[i] = INF; 开始循环，起点1可以到达点3和点2先把vis[1] = true;下次就不再循环到起点1因为d[1] + weight[1][3] &lt; d[3]所以更新d[3]d[3] = d[1] + weight[1][3] = 3;同理d[1] + weight[1][2] &lt; d[2]所以更新d[2]d[2] = d[1] + weight[1][2] = 6; 继续循环，寻找d[i]中最小的点(即离起点最近的)再开始计算这时候d[3] = 3最小(因为d[1]已经被标记过了不再访问)此时就以点3为中介点，看起点以它为中介点到达另外点的距离能不能变短标记vis[3] = true;此时d[3] + weight[3][2] &lt; d[2]; 3 + 2 &lt; 6(即从1-&gt;3-&gt;2的距离比1-&gt;2的离更小)所以更新d[2] = d[3] + weight[3][2] = 5; 又以点3中介点可以到达点4d[3] + weight[3][4] &lt; d[4]; 3 + 3 &lt; INF此时更新d[4] = d[3] + weight[3][4] = 6; 同理以点3中介点可以到达点5d[3] + weight[3][5] &lt; d[5]; 3 + 4 &lt; INF此时更新d[5] = d[3] + weight[3][5] = 7; 此时还能访问的d[2] = 5,d[4] = 6,d[5] = 7,d[6] = INF;然后继续循环发现d[2]最小，于是再以2为中介点进行寻找vis[2] = true;d[2] + weight[2][4] &gt; d[4]; 5 + 5 &gt; 6此时不更新，由于2只能到达4所以结束循环 此时还能访问的d[4] = 6,d[5] = 7,d[6] = INF;于是以点4为中介点进行循环vis[4] = true;由于点4可以到达点5和点6d[4] + weight[4][5] &gt; d[5] 6 + 2 &gt; 7不更新，继续循环d[4] + weight[4][6] &lt; d[6] 6 + 3 &lt; INF所以d[6] = d[4] + weight[4][6] = 9;然后结束循环 此时还能访问的d[5] = 7,d[6] = 9;以点5为中介点进行循环vis[5] = true;由于点5可以到达点6d[5] + weight[5][6] &gt; d[6] 7 + 5 &gt; 9所以不更新，结束循环 此时还能访问的d[6] = 9;vis[6] = true;最后发现除了6自己以外其他点都已访问过，所以结束循环 最后的结果就是d[1] = 0d[2] = 5d[3] = 3d[4] = 6d[5] = 7d[6] = 9 至此算法结束。如果您人脑模拟出来跟上面的图示有不一致的地方建议您重新阅读本拙文。如果您还看不懂请戳这里。 具体实现的代码，以邻接矩阵作为举例这里是以PAT1003为举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;//最大的城市数//N表示一共有N座城市 M表示一共有M条道路 C1 C2分别表示起点和终点int N,M,C1,C2;bool vis[maxn] = &#123;false&#125;;//定义一个数组来判断城市是否被访问int G[maxn][maxn];//表示城市与城市之间的距离int pre[maxn];//存储前驱结点int d[maxn];//记录最短距离,d[u]表示从起点s到达顶点u的最短距离int weight[maxn];//每个点的权值int w[maxn];//记录起点到每个点的最大权值int num[maxn];//num[u]表示起点s到达顶点u的最短路径条数void dijkstra(int s)//s表示起点&#123; fill(d,d+N,INT_MAX);//把所有点的距离都抹掉 d[s] = 0;//把起点的最短距离设置为0 w[s] = weight[s];//起点开始的权值即为起点的权值 num[s] = 1; for(int i = 0;i &lt; N;i++)&#123; //循环n次 int u = -1,MIN = INT_MAX;//u设置为-1是为了方便当找不到可以连接的点时方便判断,MIN存放最小的d[u], for(int j = 0;j &lt; N;j++) &#123; //找到未访问顶点中d[]最小的顶点,因为从起点开始更新了后面的d[u],然后下次循环就要从这个点寻找能到达顶点中距离最小的那个点 if(d[j] &lt; MIN &amp;&amp; vis[j] == false) &#123; u = j;//找到跟起点相距最短的那个点 MIN = d[j];//更新最短的距离 &#125; &#125; if(u == -1) return ;//如果找不到小于INT_MAX的d[]，意味着剩下的顶点和起点s不连通 vis[u] = true;//标记为已访问 for(int v = 0;v &lt; N;v++) &#123; //如果u能到达v 且 v未访问 -&gt; 则以u为中介点到达v可以使d[v]更优 if(G[u][v] != 0 &amp;&amp; vis[v] == false ) &#123; //当以u为中介点的时候能使d[v]变小 if(d[u] + G[u][v] &lt; d[v] ) &#123; d[v] = d[u] + G[u][v];//覆盖d[v] w[v] = w[u] + weight[v];//更新w[v] num[v] = num[u];//覆盖num[v] &#125; else if(d[u] + G[u][v] == d[v])//找到一条相同长度的路径后 &#123; if(w[v] &lt; w[u] + weight[v])//如果这条路径的点权之和更大 &#123; w[v] = w[u] + weight[v];//更新 &#125; num[v] += num[u];//有相同路径长度,则相加num[u],因为当d[u] + G[u][v] &lt; d[v]时候已经算出一个num[v]是符合条件的 &#125; //那么当d[u] + G[u][v] == d[v]时之前d[u] + G[u][v] &lt; d[v]算的num[v]仍然符合条件,则继续加上现在相等时候的num[u] &#125; &#125; &#125;&#125; 分析算法的复杂度？从复杂度来看，主要是外层循环O(V)与内层循环(寻找最小的d[u]需要O(V)、枚举v需要O(V))产生的，总复杂度为O(V*(V+V)) = O(V^2). 但其实Djikstra算法是可以优化到O(nlogn + m)的级别的为什么？因为必须把每个点都标记为已访问(即vis[i] = true)，所以外层循环的O(V)时间是无法避免的但是寻找最小的d[u]的过程可以不必要一个一个重新循环去寻找最小的那个的d[u]可以通过堆优化来降低复杂度，最简单的做法就是直接用STL中的优先队列priority_queue(STL依赖症) 看了上面的代码你可能已经发现了一个问题，那就是如果题目除了最短路径还有其他的要求怎么办？比如PAT1003里面就要求找到从起点到终点的最短路径的条数以及最短路径的数目之和即最短的路径可能不止一条 于是有三种主要的方式来进行考察①新增边权，即以新增的边权花费为例cost[u][v]表示从u -&gt; v的花费，并增加一个数组c[]，令起点s到达顶点u的最少花费为c[u]同理初始化的时候c[s] = 0,其余均为INF这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和c[v]而当d[u] + G[u][v] == d[v]时且c[u] + cost[u][v] &lt; c[v]时更新c[v](即可以是s到v的最少花费更优时更新c[v]) 样例代码:12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; &#125; else if(d[u] + G[u][v] == d[v] &amp;&amp; c[v] &gt; c[u] + cost[u][v])&#123; c[v] = c[u] + cost[u][v]; &#125; &#125;&#125; ②新增点权，即以新增的点权代表城市能收集到的物资为例，用weight[u]表示城市u中的物资数目，并新增一个数组w[]，即从起点s到达顶点u可以收集到的最大的物资为w[u]，初始化的时候w[s] = weight[s],其余均为0，这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和w[v]而当d[u] + G[u][v] == d[v]时且w[u] + weight[u][v] &gt; w[v]时更新w[v](即可以使s到v的最大物资更优)代码与上面类似不再给出 ③求最短路径条数，只需要增加一个数组num[]，令从起点s到达顶点u的最短路径条数为num[u]，初始化时num[s]为1，其余num[u]均为0这样可以使当d[u] + G[u][v] &lt; d[v]使num[v]继承num[u]而当d[u] + G[u][v] == d[v]时将num[u]加到num[v]上 代码如下12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; num[v] = num[u]; &#125; else if(d[u] + G[u][v] == d[v])&#123; num[v] += num[u]; &#125; &#125;&#125; 鉴于时间关系暂时就先总结这么多，Dijikstra算法其实能扩展的东西还有很多，比如如果题目要求具体的最短路径的话还要另外增加一个记录前驱结点的数组之类的东西，等以后有时间我再来补齐吧!]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20191120]]></title>
    <url>%2F2019%2F11%2F20%2F20191120%2F</url>
    <content type="text"><![CDATA[平静的生活也需要心灵的慰藉最近在读吴军老师这几年出的新书《见识》感觉给我带来的东西确实挺多的，不像是豆瓣上别人说的那种鸡汤文吴军老师确实是在用他漫长人生中遇到的种种事例来举例子所得到的一些感悟和体会，比如在谷歌时期工作时候遇到的很多优秀的同事从中学习到了很多优点，亦或者是谷歌的两个联合创始人拉里佩奇和谢尔盖布林的一些故事，从中可以感受到谷歌之所以能取得如今这样的成功，并不是偶然。并把他所遇到的人和事都亲口讲述出来。确实和我的切身体会差不太多，除了没有职场的那些经历，其他的在我不长的人生中其实已经有太多的感悟了。提到“见识”，就会想起高中数学老师给我讲的那句话，我至今仍然时刻记在心中“眼界决定境界，态度决定高度”当时上高中的时候还不以为然，现在真正出来了，到了新的世界才感受到了自己的渺小，自己的无知，然后会产生一种很大的遗憾感，把自己的前几年拿来和那些有见识有眼界的人的来比简直就是可笑 人生需要做减法有的时候我们是不是应该静下来思考一个问题，每天自己到底在忙什么？每天给自己布置那么多的任务到底有用吗？整天下来确实很忙，但是自己真的学到东西了吗？ 我很赞同吴军博士他在这里表达的一个观点，就是我们需要对我们自己的事情做减法诚然，的确有那种每天做很多事还能做的很好的人，但那毕竟是少数。大多数人其实每天能做好一两件事已经达到一个人每天精力的上限了正因为如此，我们需要给自己做减法，吴军博士在书中阐述自己能够成功的原因不是因为很会合理安排时间(当然合理安排每天的时间并不是说一点用也没有)，而是因为他每天少做很多不必要的事情。我们不禁反问自己，自己每天真的需要做那么多那么多的事情吗？难道有些事情不做天就会塌下来吗？仔细想想确实，对于我自己来说，这两三年来确实给自己布置了太多任务了，每天忙来忙去但是其实到头来收获其实没有多少，自己现在的各种意义上的水平和自己两三年刚入学的时候其实并没有多少提升，想想就很惭愧，但是这也从另外一个方面体现出一个人的思考和每天的习惯对一个人的影响有多大，但是这不正是因为自己之前没有多少见识，只会一味的伪努力去感动自己，可能一时确实还以为自己不错，哎呀又不怎么打游戏又不干别的事，但是长期来看伪努力和那些天天打游戏上课摸鱼的又有什么区别呢？还不都是什么都不会，还不如当初好好玩呢(暴论)，所以最后落得个学也没学好，玩也没玩好的尴尬的地步了。所以我特别认同他的话，“人生需要给自己做减法”，不仅仅是学习工作中，其实各种意义上都是如此，每天如果能够做好一两件事并且能够坚持的下来，对于一个人的潜移默化的好处是不可言喻的。但是现在的人可能就是如此，或者说人本身就有一种贪婪的本性，就是什么都想要，什么也不想舍弃，“我全都要”的调侃可能是每个人心中都想要达到的目标，但是现实往往并没有如此的简单，因为本身“做好一件事”其实就已经要花费人大量的时间和精力了，更何况是还要涉及很多领域的知识(当然我在这里针对的是像我这种平凡的普通人来说)对于我来说我其实对很多方面都很感兴趣，政治，历史，计算机，经济，金融，甚至是投资这方面的知识，当然一个人兴趣多是好事，但是也要分阶段分精力去学习才行，对于我来说今年还剩下一个月的时间，明年的这个时候就要准备考研计算机了，对于我来说最重要的东西当然是计算机专业相关知识的学习了，其他的东西都可以放一放，所以我要抓紧时间去学习算法相关的知识，不仅是为了准备半个月之后的比赛，更是为了自己的前途和明年的考研要开始做准备了。道理听起来确实简单，但是很少有人能够真正地自我剖析，能够真正的明白自己当前任务的主次才行，所以很多事都是说起来容易做起来难，这跟平时人们常说的“道理谁都懂”等诸如此类的话罢了，先达到每天能做好一件事的水平之后再去干更多的事情要认识到人的精力和能力都是有限的，尽可能地去做那些捡西瓜的事而不是去捡芝麻，把宝贵的时间浪费在一点微不足道的蝇头小利上，付出和收入实在是不成正比。的确，人的眼光往往是短视的，就跟在a股投资差不多，赚短期赚快钱是一件很爽的事情但同时伴随着高风险，很可能一不小心你就栽跟头了，这个时候人们容易追涨杀跌从而亏得叫苦连天，只有长期坚定不移的投资才能给自己带来合理的回报。同理，做人又何尝不是如此呢，在我的身边其实就有两类人，一类是贪图享受，每天从早到晚都只会打打游戏看看剧聊聊天，日子过得好不自在。另一类就是所谓的伪工作者，每天从早到晚待到自习室感动自己，以为自己很努力，甚至还要发说说发朋友圈作秀，但其实一点用也没有，到头来跟前一类人没多大区别。我们所要避免的就是成为这两类人，提早的认清自己，认清自己将来的目标将来的发展，认清每天应该要做什么事情，哪些是重要的哪些是不重要的 &lt;未完待续…..&gt;这篇blog我会随着这本书的感悟每天都写一点，嗯，也是看完书对自己的一种记录吧，每天都写一点收获和体会，不一定要刻意的去对待，但是把得到的收获每天记录下来警醒自己我觉得是有必要的。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>每天一点小感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1032]]></title>
    <url>%2F2019%2F11%2F13%2FPAT-1032%2F</url>
    <content type="text"><![CDATA[1032 Sharing传送门 题目的大意就是: 给出两条链表,要你找出两条链表第一个相交点如果有相交点,给出相交点地址值,如果没有,返回-1 思路：1.给出两条链表，我把所有的结点都标记为false(或者0)，然后我标记第一条链表的所有点为ture(或者1)，我再从第二条链表开始遍历，如果遇到标记点为1就为相交点，如果没遇到就说明两条链表没有相交点 注意事项：1.这题应该用静态链表比较合适，用map容易超时2.再用静态链表的时候定义maxn一定要大一点,因为数组的index值也很大(比如11111,22222)，否则数组会越界，PAT会报错“段错误”3.最后输出的时候要用print(“%05d”)来输出，因为我是用int型来保存地址的嘛，所以在输入00002的时候他会保存为2，那么我在输出的时候就应该在前面补0才行4.静态链表的next结点不是指针 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;//PATA 1032 Sharing//题目大意：给出两条链表,求出两条链表的第一个共用结点const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125;node[maxn];int main()&#123; int s1,s2;//s1和s2分别为第一二条链表的首节点 int N;//N表示一共有N个结点 cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;N; int result = -1; int address,next; char data; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;address&gt;&gt;data&gt;&gt;next; node[address].data = data; node[address].next = next; &#125; for(int i = 0;i &lt; N;i++) &#123; node[i].flag = false; &#125; for(int p = s1;p != -1;) &#123; node[p].flag = true;//flag为true表明在第一条链表上 p = node[p].next; &#125; for(int q = s2;q != -1;) &#123; if(node[q].flag == true) &#123; result = q; break; &#125; q = node[q].next; &#125; if(result != -1) &#123; printf(&quot;%05d&quot;,result); &#125; else &#123; cout&lt;&lt;result; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1059]]></title>
    <url>%2F2019%2F11%2F02%2FPAT-1059%2F</url>
    <content type="text"><![CDATA[1059 Prime Factors传送门 题目大意：就是分解一个质因数 思路：如果要分解一个质因数，那么最简单的思路就是从2开始相除，直到不能除尽为止，同时记录除每个质因数的次数，最后按题目的要求输出 所以要几个步骤：1.首先列出一个素数表2.从素数表里面依次相除，并记录每个可以相除质数的次数3.打印的时候要注意最后一个不能有*符号(所以我需要用一个num来记录有多少个不同的质数方便最后打印)4.用一个fac的结构体来记录质数和次数 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;//分解质因数的实现const int maxn = 10001;int prime[maxn],pNum = 0;bool p[maxn] = &#123;false&#125;;void setPrime()&#123; for(int i = 2;i &lt; maxn;i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; &#125; for(int j = 0;j &lt; pNum;j++) &#123; if(i * prime[j] &gt; maxn) break; p[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125;&#125;struct factor&#123; int x,cnt;//x记录质因数,cnt记录质因数的个数&#125;fac[10];int num = 0,n;//num为不同质因子的个数void decomposePrimeFactor(int n)&#123; int temp = 0,i = 0,sum = 0; while(n) &#123; while(n % prime[temp] == 0) &#123; fac[i].x = prime[temp]; fac[i].cnt++; n /= prime[temp]; if(n % prime[temp] != 0)&#123; i++; num++; break; &#125; &#125; temp++; if(n == 1) break; &#125;&#125;int main()&#123; setPrime(); int cmp = 0; cin&gt;&gt;n; if(n == 1) &#123; cout&lt;&lt;&quot;1=1&quot;; &#125; else &#123; decomposePrimeFactor(n); cout&lt;&lt;n&lt;&lt;&apos;=&apos;; for(int i = 0;i &lt; 10;i++) &#123; if(fac[i].cnt == 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;&apos;*&apos;; &#125; &#125; else if(fac[i].cnt &gt; 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x&lt;&lt;&apos;^&apos;&lt;&lt;fac[i].cnt; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;&apos;^&apos;&lt;&lt;fac[i].cnt&lt;&lt;&apos;*&apos;; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191007]]></title>
    <url>%2F2019%2F10%2F07%2F20191007%2F</url>
    <content type="text"><![CDATA[上海之旅已经上了两年的大学了，还从来没有好好出去玩过一次，于是一个月前，我就和两个同学计划在国庆7天里面好好出去玩玩，如今已经旅游完回到宿舍，不觉感叹美好时光的短暂，也从这次旅游之中感触到自己的很多不足，也是希望借机会记录一下自己的生活吧，反正自己的blog想写啥就写啥咯，记录一点不一样的东西可以让我的心宁静下来吧。(其实就是想记录记录流水账，让自己记忆还未忘却的时候用文字和图片记录下来，我觉得这也是旅游的意义之一吧，而不是去过了什么收获体会都没有) 9月30日 &amp; 10月1日下午6点的车去魔都，4点后翘掉选修课回去洗了个澡穿了身新衣服就和同学坐地铁去火车站了，随便吃了点什么就上车了 这还是我人生中第一次体验绿皮火车吧，之前从来也只坐过高铁动车之类的，坐火车过夜倒是人生中的第一次，去之前其实心里也有点忐忑不安，因为说实话之前已经在知乎上看到有好多人说卧铺怎么怎么不好，同学也都跟我说里面空气不太好 不幸中的万幸可能就是我在订火车票的时候把我们三个都订在同一边的铺位上了吧，这样子还挺方便我们互相照顾的 进去之后果然，感觉里面的位置都好小好紧，人们都坐在过道旁边的座位上，吃着东西有说有笑，我和同学走了很久才找到了自己的铺位 “有个小桌子，有被子有枕头，我睡在下铺应该没什么大问题吧”，我内心这样想着于是，把东西放下后不久后火车便缓缓的开动了让我出乎意料的是平时在学校用的不怎么样的联通卡，在火车上的信号居然奇好无比(比我同学的移动简直好不完，经常找我开热点给他)闲着无聊，我于是在火车上就开始写作业，一直写了差不多3个小时的样子吧，到十点火车上熄灯了，同学也都从我床上上去休息了，我也差不多躺下来看会手机这一躺不知道，躺下去才知道火车是有多晃啊，当时我就感觉晚上睡觉不会顺利了(最后也没出乎我的意料)刷着手机过了凌晨，上完厕所去睡觉，躺下来蜷缩在被子里面，因为我有很严重的鼻炎的缘故，我每天睡觉只能侧着身子睡觉，但是火车晃的很严重让我侧着身子经常睡不好，于是就这样半睡半醒的样子持续到了4点多钟，迷迷糊糊的到了5点半，乘务人员就来叫醒我们准备下车了我去洗了个脸，用发泥弄了下自己的头，内心其实有点期待和不安吧，期待的是魔都能够给我带来什么样的惊喜，不安的是自己眼界不足，总感觉出去会丢人之类的想法。 嗯，总算是出站了，可是外面下着大雨让我的心里的不安达到了极点 没错，我当然知道要提前看天气，9月28日那天我就知道1号的时候会有台风天气，说实话，一直只待在内地的我确实还从来没有经历过台风天气，以前都是只能从电视上或者手机上的新闻了解到台风有多么多么厉害，好了，现在可算是“身临其境”了。 出了火车站就直接去地铁站感受下魔都地铁的便捷 令我惊讶的是来的时候地铁站里面居然没有很多人，可我看新闻明明魔都是国庆人们出游最多的地方了，“这台风是有多厉害喔，难道劝退了这么多人吗”由于订的民宿中午十二点之后才能入住，所以这之前我们要随便找个地方去转转 直奔云南路去找b站上那些大大们推荐的地方去随便吃点早餐吧到魔都早点最有名的就是生煎和锅贴了吧，于是在云南路上找了家店坐下来，外面居然就下起了暴雨了起来(原来这就是台风的威力吗) 等了几分钟点了两份锅贴和馄饨，不得不说，魔都本地的锅贴和我在学校吃的真的完全不一样，我觉得最大的不同点就是它里面的汁是真的足，吸完汁再吃一大口肉馅，那种感觉是真的不一样 吃完了早餐，由于离中午还有很久的时间我们就到人民广场附近随便转转，由于雨实在是太大了我们于是就找了家全家去避雨去了(魔都随处可见的便利店简直是不能再方便了) 等雨小之后我们于是继续在附近转，准备去附近的广场公园去看看 不看不知道，一看是真的把我美倒了“魔都这里的公园才能叫公园啊，有花有草有小溪有湖，里面还有一大群鸟儿，甚至还有橘子树”，其他地方的公园和这里一比简直是弱爆了。。。 继续走，到了十点钟也正好是阅兵的时候，我们也正好走到了上海市政府中心的位置(正好也是阅兵刚开始的时候吧)，我们也顺便一遍走一遍观看阅兵的直播。 不知不觉居然就走到了南京路步行街附近，但是第一天我们的计划里面并没有计划在这里好好玩，于是我们在美团里面找到了这附近评分最高的一家叫“南京大牌档”的地方去吃第一顿午餐了 不得不说这家餐厅里面的上海菜的确有它的特点，偏甜，偏小，里面的粥挺好喝的，还有类似的糕和小吃都能满足我们的味蕾，价格方面也不算离谱(没错，这顿饭也是这次旅游里面体验最好的一次了) 吃完饭，将近十二点了，于是我们便坐地铁到龙阳站附近的民宿去放东西(我背着一个电脑包来旅游实在是不太方便) 走了半天终于找到了订的民宿，经过一番折腾后终于是住了进去(没人，门上是智能开锁，只需要主人告诉密码就进去了) 民宿里面的环境还不错，三个人平均下来也只要一百多一个晚上，这在寸土寸金的上海简直就不要太便宜，而且旁边就是很方便的地铁站，住的地方是真的不错 我们休息了会天就黑了，准备出去恰个晚餐，我们仨打个伞就直接出去了，结果被台风天气虐到了，鞋子全湿裤子也几乎全被打湿了，一个伞在台风面前是在是不够看，我也是第一次见识到了台风的威力了。 虽然有点不爽，但是我们只能原路返回去避雨了，我们仨居然就直接在饿了么美团上面点外卖吃了(没错，出去玩还点外卖，我其实也是有点哭笑不得) 但也是迫于无奈吧，玩了玩电脑到过了凌晨，洗了个澡我们就直接睡觉了 第一天的旅途就这么结束了呢。 10月2日第二天，起来的不是很早，因为好像是晚上一两点才睡的觉我们晚上的精神不知道为什么都挺好的 嗯所以我们十点左右的时间才从家里出发 有个人要去见他亲戚一面于是和我们分开了 嗯虽然只有两个人，我们还是去了云南路去吃饭， 先去了这家阿叔熬奶茶去点了一杯血糯米奶茶，不过很失望，喝起来和普通奶茶店的奶茶好像没什么区别 又去附近的八宝炸猪排去买了个猪排，猪排十一块一个，虽说分量不是很多，但是加上那个汁确实好吃 又去云南路附近的汤包店点了两笼汤包以及一碗葱油面，点的时候还以为不够，点了才知道根本就吃不完。。。那个苏州汤包是真的好鲜啊。。。不蘸醋直接一口吃简直就是大大的满足，里面的汁水很足但是也不算太大，就算过了二十多天我还是记忆犹新 从云南路准备去世博园去的，但是途中居然就碰到了中共一大的会址。。。说巧也不巧，因为可以凭借身份证免费进去参观，于是我们便排队进去参观了 虽然是国庆但是可能是前一天的台风的影响吧，第二天中午还没看到很多人，于是我们便进去参观了 嗯…犹豫里面大多数的历史我都已经很清楚了，所以我们进去看了一圈就出来了，就随便放几张图好了 嗯，差不多就放这么多好了 出了一大会址，我们便坐地铁准备去世博园了 到了世博园，进去售票处，发现只要凭借身份证就能够免费的进去参观 于是我和他就领了票进去参观 额，由于里面其实也没什么好看的，那我也就不放图好了 进去参观将近一个小时之后就出去了 准备去梅赛德斯奔驰馆参观了 到了梅赛德斯奔驰馆，其实说实话有种不真实的感觉，因为平时在家里电脑手机上看到那么多在这里举行的比赛居然现在真真切切的在我身边，唯一有点遗憾的就是他不让游客进入比赛地点去参观了，属实有点遗憾。 梅赛德斯奔驰馆后面就是黄浦江，说实话，这里的景色是真的很棒啊，真的是很壮观的长江，里面还有好多游轮，但是在广阔的长江上就显得十分渺小 从梅赛德斯奔驰馆出来我们便准备去附近的世博公园去转转了世博公园是真的很大，地图上黄浦江一边的一大块都是世博公园，好像不骑自行车根本就不可能逛完，江边的公园景色真的很美啊！ 正在世博公园走的脚都快疼死的时候，突然另外一个同学打电话来说弄完了 我们于是便动身去前期约定好的animate店去集合了，A店在中国只有上海有一家店，虽然东西比较少但是对于我们这种宅来说去看看去打卡还是挺不错的 未完待续……….]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190926]]></title>
    <url>%2F2019%2F09%2F26%2F20190926%2F</url>
    <content type="text"><![CDATA[每天只会无能狂怒的废物&gt;发泄了下自己的情绪这种东西还是不要让别人看到好了 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-169]]></title>
    <url>%2F2019%2F09%2F14%2FLeetcode-169%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PAT-1003]]></title>
    <url>%2F2019%2F09%2F09%2FPAT-1003%2F</url>
    <content type="text"><![CDATA[1003 Emergency传送门 英文描述:As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:2 4 中文题意给出N个城市，M条无向边。每个城市都有一定数目的救援小组，所有边的边权已知。现在给出起点C1和终点C2，求从起点C1到终点C2的最短路径条数及最短路径上的救援小组数目之和。如果有多条最短路径，则输出数目之和最大的。 思路：把样例输入来举例子吧5 6 0 2分别代表5座城市(对应N)6条道路(对应M)0表示对应的起点是第0号城市(因为城市的编号是从0到N-1)这里我把0到4的五个城市分别从A到E来表示比较方便那么如图所示ABCDE五座城市,起点为A终点为C红色的数字表示每座城市的救援人员人数绿色的数字表示城市与城市之间的道路距离所以我们要求的是在从A到C道路距离最小的情况下,沿途城市一起的救援人数越多越好 所以我们定义一个rescueWorkers和val_distance来存放最后的结果并且令rescueWorkers = INT_MIN,val_distance = INT_MAX方便后面比较结果 定义一个邻接矩阵road[maxn][maxn],其中如果road[i][j]为0表示i和j之间没有道路,如果不为0则表示i和j之间有道路,且值即为图中绿色颜色的数字所代表的距离 再定义一个visit[maxn]来判断城市是够走过定义一个map&lt;int,int&gt;city来存放每个城市的救援人数,其中city[i]表示第i个城市的救援人数(map也可以用一个数组来代替,因为城市是从0到N-1的所以没有影响) 所以我的思路就是用dfs从起点开始来进行搜索,直到到达终点位置然后就继续回溯,直到全部搜索完于是有两种情况1.搜索到C2的时候,当前的distance比之前更新过的val_distance要小这个时候应该重新更新sum为1,因为这是只有一种最小的情况,并且更新val_distance2.搜索到C2的时候,当前的distance和之前更新过的val_distance相等,这时表示当前找到了另一条最短路径,则此时sum++,然后再判断people和rescueWorkers的大小,如果当前的people比rescueWorkers大则重新更新rescueWorkers 几点需要注意的地方:1.在输入邻接表的时候不仅要更新road[i][j],一定也要还更新road[j][i]！！！否则会造成错误2.dfs的思路就是从0开始进行遍历,所以用一个for循环从头开始进行遍历,当visit[i] == 0 &amp;&amp; road[nowVisit][i]不为0的时候进一步dfs3.dfs后一定要令visit[i] = 1,回溯的时候一定要令visit[i] = 04.dfs直接从最初的C1点开始搜索,dfs(C1,city[C1],0)表示从C1开始搜索,最初的人数为city[C1],距离为0开始 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;//P1003 Emergencyconst int maxn = 501;//邻接矩阵最大的数目int N,M,C1,C2,sum = 0;//N表示城市数量,M表示道路的条数,C1表示当前所在城市,C2表示要去的城市int rescueWorkers = INT_MIN;//rescueWorkers来存放最多的救援队人数int val_distance = INT_MAX;int road[maxn][maxn];int visit[maxn];//表示是否访问过map&lt;int,int&gt;city;//定义一个map来存放城市对应的救援队的数目void dfs(int nowVisit,int people,int distance)&#123; if(nowVisit == C2) &#123; if(distance &lt; val_distance) &#123; sum = 1; val_distance = distance; rescueWorkers = people; &#125; else if(distance == val_distance) &#123; sum++; rescueWorkers = max(rescueWorkers,people); &#125; return ; &#125; if(distance &gt; val_distance) return ;//如果现在的距离已经超过最短的距离直接返回 for(int i = 0;i &lt; N;i++) &#123; if(visit[i] == 0 &amp;&amp; road[nowVisit][i] != 0) &#123; visit[i] = 1; dfs(i,(people+city[i]),(distance+road[nowVisit][i])); visit[i] = 0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2; for(int i = 0;i &lt; N;i++) &#123; int temp; cin&gt;&gt;temp; city[i] = temp; &#125; for(int j = 0;j &lt; M;j++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; road[a][b] = c; road[b][a] = c; &#125; dfs(C1,city[C1],0); cout&lt;&lt;sum&lt;&lt;&quot; &quot;&lt;&lt;rescueWorkers; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1449]]></title>
    <url>%2F2019%2F09%2F05%2FluoguOJ-P1449%2F</url>
    <content type="text"><![CDATA[P1449 后缀表达式传送门 题目描述所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。 如：3*(5–2)+7对应的后缀表达式为：3．5．2．-*7．+@。’@’为表达式的结束符号。‘.’为操作数的结束符号。 输入格式输入：后缀表达式 输出格式输出：表达式的值 输入输出样例输入 #13.5.2.-*7.+@ 输出 #116 说明/提示字符串长度，1000内。 思路：从左到右扫描后缀表达式 如果是操作数就压入栈 如果是操作符就连续弹出两个操作数(且后弹出的是第一操作数,先弹出的是第一操作数)然后再进行对应操作符的操作最后再把新生成的操作数压入栈里面,直到后缀表达式扫描完毕那么此时栈只剩下的一个数就是最终的答案 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152stack&lt;int&gt; num;string str;int val = 0;int main()&#123; cin&gt;&gt;str; for(int i = 0;i &lt; str.size();i++) &#123; if(str[i] ==&apos;.&apos;) &#123; num.push(val); val = 0; continue; &#125; else if(str[i] &lt;= &apos;9&apos; &amp;&amp; str[i] &gt;=&apos;0&apos;) &#123; val *= 10; val += str[i] - &apos;0&apos; + 0; &#125; else if(str[i] != &apos;@&apos;) &#123; int temp1,temp2,temp; temp2 = num.top(); num.pop(); temp1 = num.top(); num.pop(); if(str[i] == &apos;+&apos;) &#123; temp = temp1 + temp2; &#125; else if(str[i] == &apos;-&apos;) &#123; temp = temp1 - temp2; &#125; else if(str[i] == &apos;*&apos;) &#123; temp = temp1 * temp2; &#125; else if(str[i] == &apos;/&apos;) &#123; temp = temp1 / temp2; &#125; num.push(temp); &#125; else if(str[i] == &apos;@&apos;) &#123; cout&lt;&lt;num.top(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1433]]></title>
    <url>%2F2019%2F09%2F03%2FluoguOJ-P1433%2F</url>
    <content type="text"><![CDATA[P1433 吃奶酪传送门 题目描述房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在(0,0)点处。 输入格式第一行一个数n (n&lt;=15) 接下来每行2个实数，表示第i块奶酪的坐标。 两点之间的距离公式=sqrt((x1-x2)(x1-x2)+(y1-y2)(y1-y2)) 输出格式一个数，表示要跑的最少距离，保留2位小数。 输入输出样例输入 #141 11 -1-1 1-1 -1 输出 #17.41 思路：double一个sum来统计每次dfs到底的时候比较最短距离，如果s比sum要小就更新sum我觉得这里面最重要的就是用visit[maxn]数组来判断是否走过因为每次用now在dfs里面表示当前第几个点因为要走过所有的点，所以从哪个点开始进行dfs是无所谓的，所以默认dfs(0,0,0.0)开始没问题然后double Distance[maxn][maxn]来存放点与点之间的距离Distance[i][j]表示第i个点和第j个点之间的距离然后再dfs(i+1,j,s+Distance[now][j])这个的意思就是现在位于now点,然后再准备走向下一个点,也就是走向j对应的点然后就先令visit[j] = 1表示j这个点即将要走到了那么s就加上一个Distance[now][j],此时继续dfs那么此时的now就等于j点,如果一直dfs,一直递归到条件不成立,那么就回溯,令visit[j] = 0因为每一层dfs里面的for循环都是从1一直到n的,所以怎么无论dfs多少次都是会从1开始遍历如果经过了就不考虑,如果没经过就继续dfs,直至每层dfs为止然后再更新最小的sum值又因为输出的格式要求要保留两位小数,所以最后就printf(“%0.2f”,sum)得到最后的结果 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 16;int n;double sum = 10000.0;//sum来存放跑动的最少距离double Distance[maxn][maxn];//存放点与点之间的距离double x[maxn],y[maxn];//存放每个点的坐标int visit[maxn];void dfs(int i,int now,double s)//i表示已经走了几个点，now表示当前第几个点，s表示距离&#123; if(s &gt;= sum)//如果发现s已经大于当前最小的sum则直接返回 &#123; return ; &#125; if(i == n)//全部走完的时候 &#123; sum = min(sum,s); return ; &#125; for(int j = 1;j &lt;= n;j++) &#123; if(!visit[j]) &#123; visit[j] = 1;//把即将要走过的这个点设置为走过 dfs(i+1,j,s+Distance[now][j]); visit[j] = 0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; for(int i = 0;i &lt;= n;i++) &#123; for(int j = 0;j &lt;= n;j++) &#123; Distance[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dfs(0,0,0.0); printf(&quot;%0.2f&quot;,sum); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1403]]></title>
    <url>%2F2019%2F09%2F02%2FluoguOJ-P1403%2F</url>
    <content type="text"><![CDATA[P1403 [AHOI2005]约数研究传送门 题目描述：科学家们在Samuel星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机“Samuel II”的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用“Samuel II”进行数学研究。 小联最近在研究和约数有关的问题，他统计每个正数N的约数的个数，并以f(N)来表示。例如12的约数有1、2、3、4、6、12。因此f(12)=6。下表给出了一些f(N)的取值： f(n)表示n的约数个数，现在给出n，要求求出f(1)到f(n)的总和。 输入格式:输入一行，一个整数n 输出格式:输出一个整数，表示总和 输入输出样例输入 #13输出 #15 说明/提示【数据范围】 20%N&lt;=5000 100%N&lt;=1000000 思路： (数学方法)f(1)到f(n)的和，即为1到n之间因子的和那么1到n之间1的因子总共有n/1个2的因子总共有n/2个3的因子总共有n/3个…依此类推那么1到n之间因子的和即为f(i) = n / i;i从1到n的总和 代码如下：123456789101112int n;int result;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; result += n / i; &#125; cout&lt;&lt;result; return 0;&#125; (非数学方法)(用筛法) 定义一个数组num[maxn]，result = 0；从1到n,int i = 1,然后每隔1就累加一次num[i]++,表示从1到n每个数都拥有的1的个数,然后再从1到n,s加一次ai然后i++递增,同理,i = 2,每隔2就累加一次num[i]++,然后依次类推表示从2到n里面每个数如果含有2就会++一次,然后结束循环之后,s再加一次a[i]依此类推 代码如下：123456789101112int n,a[10000001],s;int main()&#123;cin&gt;&gt;n;for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; &#125;cout&lt;&lt;s;return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1118]]></title>
    <url>%2F2019%2F08%2F31%2FluoguOJ-P1118%2F</url>
    <content type="text"><![CDATA[P1118 [USACO06FEB]数字三角形传送门 题目描述有这么一个游戏： 写出一个1至N的排列ai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少1，直到只剩下一个数字位置。下面是一个例子： 3,1,2,4 4,3,6 7,9 16 最后得到16这样一个数字。 现在想要倒着玩这样一个游戏，如果知道N，知道最后得到的数字的大小sum，请你求出最初序列ai，为1至N的一个排列。若答案有多种可能，则输出字典序最小的那一个。1234567891011121314输入输出样例输入：4 16输出：3 1 2 4说明/提示对于40%的数据，n≤7；对于80%的数据，n≤10；对于100%的数据，n≤12,sum≤12345。 思路：假设n = 5,那么a b c d e依次对应a b c d e a+b b+c c+d d+e a+2b+c b+2c+d c+2d+e a+3b+3c+d b+3c+3d+e a+4b+6c+4d+e此时1到5对应的权值即为位数 1 2 3 4 5权值 1 4 6 4 1 假设n = 8,那么a b c d e f g h依次对应a b c d e f g h a+b b+c c+d d+e e+f f+g g+h a+2b+c b+2c+d c+2d+e d+2e+f e+2f+g f+2g+h a+3b+3c+d b+3c+3d+e c+3d+3e+f d+3e+3f+g e+3f+3g+h a+4b+6c+4d+e b+4c+6d+4e+f c+4d+6e+4f+g d+4e+6f+4g+h a+5b+10c+10d+5e+f b+5c+10d+10e+5f+g c+5d+10e+10f+5g+h a+6b+15c+20d+15e+6f+g b+6c+15d+20e+15f+6g+h a+7b+21c+35d+35e+21f+7g+h 此时1到8对应的权值为位数 1 2 3 4 5 6 7 8权值 1 7 21 35 35 21 7 1 所以这其实就是一个杨辉三角的一个模型那么构建一个杨辉三角的代码如下所示1234c[1][1]=1;//最左上角的数初始化为1for(int i=2;i&lt;=n;i++)//由于这里数组的记录是从1开始记的，所以不用担心越界 for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//每个数都等于它肩上两数之和 或者直接套用杨辉三角的通用公式来直接解出来,和上式一样C(n-1,m-1)=(n-1)!/[(m-1)!(n-m)!](其中!表示阶乘，n！=n(n-1)…21) 那么当n为几,sum的和就是n个数乘以杨辉三角第n行分别对应系数得到的结果 然后直接从1开始进行dfs,因为是从1开始储存的,所以得到的结果肯定也是字典序最小的 完整代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;int n,p;//输入必备int a[13];//输出必备int c[13][13];//杨辉三角必备bool b[13];//判重必备void dfs(int dep,int s)&#123; if(s&gt;p)//如果现在累加的数已经超过了给定的数，就返回 return; if(dep&gt;n)//如果已经搜完了n个数，就返回 &#123; if(s==p)//如果答案跟给定的数相等 &#123; cout&lt;&lt;a[1]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;a[i];//输出 exit(0);//终止程序 &#125; return;//如果没有输出答案，就返回 &#125; for(int i=1;i&lt;=n;i++) &#123; if(b[i]==false)//如果当前这个数没有用过 &#123; b[i]=true;//标记成用过 a[dep]=i;//保存第dep个取的数 dfs(dep+1,s+i*c[n][dep]); b[i]=false;//注意这里要将状态回归，不然TLE &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;p;//输入 c[1][1]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//生成杨辉三角 dfs(1,0);//开启深搜之旅 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190823]]></title>
    <url>%2F2019%2F08%2F23%2F20190823%2F</url>
    <content type="text"><![CDATA[想做一点有趣的事情好久都没写博客了Orz，这个习惯要开始慢慢重新恢复起来了。。嘛，最近开始接触了PR,AE之类的软件，突然感觉心血来潮，对做视频这方面感觉挺有意思的，现在越来越觉得游戏没多少意思了，虽然能够给我带来快乐，但是都只是短暂的，不可持续的，比每天刷一道题，去知乎好好写一篇回答，亦或者去好好做一个视频给自己带来的成就感确实低多了。。。 所以我现在所在的问题不是会不会用什么东西，而是要去自己深入了解其中的内涵，不然自己跟所谓的工具人又有什么区别(悲 果然不出我所料，回家带的几本书根本翻都没翻，就算看书我也是喜欢直接到电脑上去看。。。感觉自己对于电脑的感情还是不一般呢，可能自己一辈子也离开不了它了吧。。。 其实我一直都在问自己，到底喜欢什么，以后到底喜欢做什么事情，但是确实没有什么事情能够让自己一直能够很开心的去做下去，所以看那些大佬们每天能够做自己喜欢做的事情真的是羡慕的不行呢，果然跟C菌说的一样。。。兴趣就是最好的前进动力可惜我没有叻。。。 自己的惰性还是大于自己的干劲，这几天和家里的老人又聊了聊天感觉自己过的时候真的是太幸福了，像我爷爷奶奶到了我这个年纪就要去工厂干活或者去农田里面耕作，虽说现在时代是好了但是我在家也没有好好学习充实自己反而是每天浪费时间去做很多很多无意义的事情。。。每天中午睡觉也是。。经常就睡一下午，就感觉跟家里人所说的没有操心一样，心里没有一点事情就睡得安稳，就喜欢混时间，可能是不到最后一刻不到生死关头自己才会醒悟吗？可是每次都把希望寄托在明天我最后可能什么都得不到。。。 想了想19年已经8月底快9月了，这一年过的真的是太快太快了，就好像刚刚过年没多久自己立下的flag还历历在目但是现在来看根本没完成几个。。。我真的有点厌倦了。 可能是舒服的日子过得太久了吧，两年前还在奋斗高考的我的那股冲劲感觉完全都没有了，现在的我只是一个一事无成每天喜欢看手机玩电脑的废物，这也不会那也不会。。。明年就要考研了我还没开始系统的学习知识点，还有好多想做的事情没有去做。。我很难过，但是我不怪别人，这都是自己找的，但是我已经认识到了我自己的问题，新的学期大三虽然是满课，但是我觉得我每天可以过的很充实，一天一道题，一个星期写一篇回答，一个月制作一个视频，我觉得自己给自己找点事情做才会让自己每天都充实。 那么今天的日记就这样吧，以后写日记的频率会增加吧，我觉得真的挺充实的，还会更新算法相关的笔记，那么就这样吧Orz]]></content>
  </entry>
  <entry>
    <title><![CDATA[20190816]]></title>
    <url>%2F2019%2F08%2F16%2F20190816%2F</url>
    <content type="text"><![CDATA[一点点疑惑突然发现自己的博客居然有人在看，不禁觉得有点害羞，但是仔细想想既然分享了出去，那么肯定就是希望有人来看的，但是这种感觉就好像是自言自语被别人看到了一样(就感觉像个沙雕一样呜呜呜)可能我就是这样的人吧，有的时候会太在意别人的看法，在意别人看法的后果就是做什么事情都畏手畏脚，从而好多事情都不敢去做，就比如交朋友来说，觉得别人很厉害啊什么的就不敢去交流不敢去交往，我觉得这可能也是很多人的一个通病吧，所以好好的做好自己才是更应当做到的事情(天天都在摸鱼的屑留下来不思进取的眼泪) 但是我又不禁感到一丝惭愧，作为一名还没有任何知识水平的人，既没有自己擅长的领域可以分享给别人，也没有好好分析一个问题的能力，实在是让我惶恐不安，可能这就是所谓的键盘侠吧，打字计划满满的一堆，但是真正去做什么事情都会大打折扣。所以想要朋友是对的，但是莫名其妙的去强行和别人交流真的不可取，不同阶级，不同知识水平，自己都没有这个水平怎么跟别人聊得起来呢？所以现在我也想开了，提升自我修养才是更应该去做的事情，只有自己的知识水平上去了，只有自己变得足够优秀，才能有和别人成为朋友的价值。正如我之前所说，朋友之间是相互的，如果你不能给别人足够的帮助，那别人为什么要和你成为朋友呢，所以这其实是一个伪命题。这件事我不会再写很多了，说多了其实自己也挺烦的，一个人就一个人吧，一个人其实也挺好的，至少没人来烦我Orz。 乱七八糟又写了这么多，暑假也快要过完了，我觉得是时候要好好想一想一下自己未来的生活了xd 在b站上看到一个视频，学习思维和方法确实比知识重要太多了，以前觉得这个都不怎么重要，现在才知道原来自己是多么幼稚，简直就是浪费了自己当初多少的大好时光，所以说导致现在这个样子真不能怪别人，只能怪自己太短视了。 番茄工作法真的很适合我这种不自觉的人，平时干什么事情都会莫名其妙就看手机，刷知乎，上b站去了，还不如规定一段时间让自己专心致志的去做某件事情，能够让自己集中注意力，我觉得挺赞的。 我今天才发现自己平时真的是不爱思考，不喜欢思考事情，不管是好是坏都是一种无所谓的态度，可能在这个过程之中逐渐就丧失掉了自己的思考问题的能力，我觉得不能再拖下去了，是时候正视自己的缺点去改进了 所以以后会在blog更新一些我对时事的一些看法和一点意见吧。哦对了，好久都没有把刷过的题目好好做个总结，这也是今后需要做的事情，当初其实是想当一个技术blog来着的(但是真的没什么技术水平)，但是我会努力的！争取在合理的时间做合适的事情吧，还有十天不到的时间，就这样先试试看吧~]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190810]]></title>
    <url>%2F2019%2F08%2F10%2F20190810%2F</url>
    <content type="text"><![CDATA[一点感慨有一段时间没有更新过博客了吧，这段时间也确实发生了很多事情，这其中我也想了很多，思考了很多，我发现自己确实变了很多，长大了之后就感觉自己逐渐失去了自我？(maybe)，学会了如何去讨好他人？学会了怎么去妥协别人？反倒是自己不能够随心所欲的去干一些事情？我觉得到现在看来真的挺可笑的，有的时候自己确实想的太多思考的太多，反倒有的时候过于考虑别人从而让自己每天活在不快乐之中。嗯，所以我决定了，自己以后不管是谁都不能改变自己的初心了，我就是我，我想干什么就去干什么，真的没什么好顾忌的。 因为现在已经没有什么可以失去了。嗯，接下来就说说这几天发生的事情吧，算是都跟朋友有关吧，直到今天我才有时间来好好总结。 第一件事就是我和我现实中的好朋友吧，我和他算是老相识了吧，从小学就开始认识了，到现在为止算了算认识了也有十几年了吧，但是可能是我过于高估我们两个之间的关系了吧？长大以后，我的性格越来越内向，我从一个外向开放的人逐渐走向内向自闭的一个人，尤其是在高中这个阶段，嗯，高中的氛围很不好，很不好，很不好，以至于我不再想回忆起我的高中生活，但是我必须要去面对那段事实，就是我确实感觉很孤独，在那么紧张那么激烈的一段时间里面，没有人能够一起说话没有人可以让自己表达自己的感情，有的只是同学之间相互之间的嘲讽，没错就是嘲讽。你可能难以想象，怎么可能，高中同学难道不应该是相互鼓励相互尊重然后一起努力去考上一个好的大学吗？很可惜，对于我来说很不巧，刚好分到了一个班级里面都不是那么友善的人，简单的来说就是他们不是想跟你一起努力，反而是通过各种手段(就比如各种嘲讽)来影响你让你考试发挥不好，影响你的心态然后就能踩在你身上获得成就感，虽然已经两年了，但是我还是忘不了这段时期，现在已经不敢想象当时自己是怎么过来的。于是就在这个背景之下，我和那个人就因为认识了很多年的原因，所以就成为了表面上的好朋友吧，毕竟当时在班里我也和别人不熟，他也和我差不多，但是到今天为止我都没猜透他到底在想什么。你可能会说，这不是一件好事吗，认识了那么久，在一个班里刚好能互相取暖吧，但可能我不知道我做了什么事情让他心里不爽吧(可能)，一直跟我保持距离，但是我一直都算是把他当做最好的朋友来看待的。现在想想真的是可笑，别人可能根本把我不当什么吧，都怪我自作多情，大学里面还经常打电话过去，每次出去玩都是我主动找他，他一次也没有找过我，直到前几天各种理由来推脱我，我这时候才终于明白了。 朋友之间不应该是相互的吗？为什么只有我去关心别人？朋友不应该就是能够互相依靠的吗，说句不好听的话，怎么就成了我去舔别人了呢？现在想想真的可笑，我可能是为了寻求内心那一点点依靠，把别人看的太重了，导致成了现在这幅样子，但是如今我也想开了，已经没有什么好失去的了，这种朋友不要也罢，前几天一气之下就直接把他删了，既然不想跟我做朋友，既然不想跟我见面，那我们各走各的有缘再见吧。 第二件事就是知乎上一个朋友橘猫，我也不想说你的id你也注销过好几次了，不，按您的说法我们根本就算不上朋友，我也不想回忆您我也不想再说和您的故事，好聚好散，虽然你是个渣男和好多木桶饭也都交往过，请好好想想为什么最后都会成为这样，不要把责任都推到别人身上，你自己本身就有很大的问题，我现在也看开了不是同一个世界的人就没有必要天天聊这个聊那个的，思维都不一样，希望您早点出国成为人生赢家，走入社会再干上您最讨厌的工作吧，哦不，或者成为一个哲学家(当代马克思)也说不定？ 稀里糊涂说了这么多我也不想改了，反正就是记录自己最近的烦心事，以后会随着自己的本性去做事情了，不会再去顾忌这个顾忌那个 因为自己已经没有什么好失去的了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190727]]></title>
    <url>%2F2019%2F07%2F27%2F20190727%2F</url>
    <content type="text"><![CDATA[记录一下昨天晚上的一些心事从25号回家到现在也有两天了，发现回家也并没有想象中的那么兴奋嘛，第一天家里人见到我都说我瘦了好多好多Orz，还怀疑我有没有在学校好好吃饭(其实在学校根本就没吃过早餐，因为没有好吃的早餐哼唧)，看着自己那么胖那么粗的一根腿说实话我觉得我自己胖的要爆炸了这个腿根本不可能让别人有社保的欲望啊(逃但是家里人好像可能已经察觉到了什么了？诶多，下学期还是要坚持运动吧，争取能再瘦个10斤？(flag先立起来再说) 然后再就是昨天晚上发生的事情让我难受了一个晚上吧Orz嗯，昨天晚上的事情确实有点让我伤心，本来这个月初就跟原来最好的朋友说好要一起出去的，当初也答应了我要一起出去，结果昨天发消息却是不情不愿，也不想跟我说话我是真的真的特别伤心，因为本来原来高中的时候跟同学处的就不是很好，到现在也没几个能联系的人，唯一一个在我眼里看来算是最好的朋友的人可能不把我放在心上吧。每次放假都是我主动给他打电话，每次什么活动都是我主动去拉别人，现在想想真的是有点自作多情了，说实话我对他可能是有感情的吧，毕竟同学了十几年了，从小学一直到高中，可是别人却把我不当回事，我是真的真的很心痛，可能本来就不是一路人吧，我现在也想开了今天中午又跟另外一个朋友聊了半天，说句笑话，我真的算是条舔狗吧？把别人当回事，还义无反顾的去舔，我现在真的无所谓了，以后爱见不见，有缘再见吧真的是，你不情愿我也无所谓，厚着个脸皮天天叫你真的没意思ok？但是伤心是真的伤心，现实里面真的就没有那种真正意义上能够关心我的朋友了吗，为什么会这样子呢…我也不知道为什么从小长到大性格越来越内向，越来越不喜欢跟别人交流但是却又想和更多的人交流沟通。。。 真的是很矛盾呢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190724]]></title>
    <url>%2F2019%2F07%2F24%2F20190724%2F</url>
    <content type="text"><![CDATA[回家前的一点感悟终于，摸了这么多天我还是选择回家好了(其实是因为没钱的缘故了xd)，又要一个人踏上回家的旅程了，回家一次就是相差大半年，仔细算算还有几个大半年能够这样呢(就是没多少假期意思desu)，想想没几年就是个社畜了(悲，还没有可爱的大姐姐来找我呜呜呜，这辈子算是难了噗，不说多的了，希望今天能有一个好梦吧！ 时间真的是过得非常非常快，从2号考完到现在已经整整过了22天了，也就是将近一个月了，暑假已经走到了一半了，说来惭愧，这二十多天真的是没有做什么事情，其实留校和在家真的没有什么区别，反而每天要自己花时间来安排自己的吃喝，反而效率更低了(笑) 真的是不知道为什么，当初那种努力的感觉就是找不回来了，学习完再快乐本来应该是一件很棒的事情，但是在电脑上就是抑制不住自己，但是仔细想想我现在本来是一个很自觉的人啊，为什么会这样子呢。 想了想，可能还是没吃过苦头吧，也就是所谓的在危机没有真正到达眼前之前，人总会给自己找各种各样的借口来为自己的懈怠推脱，所以现在格外的意识到了人性，”说到底还不就是一条懒狗”，完美总结了这22天的宿舍生活。 于是我决定明天就回家好了，宿舍还有个室友经常打扰我，在家里应该不会有人打扰我了，而且也不用操心自己的吃喝，挺好的，这次回家我准备就带两本书回去，还有两本关于经济学方面的书准备看完，现在我的知识水平还是太欠缺了，根本不能到知乎上去做像模像样的回答(同时也没有勇气和大佬们交流)所以虽然玩了知乎有几年了，但是认识的朋友却并不多(悲)，希望能好好改善一下当前的处境呢。 这个暑假最大的收获可能就是认识了一位志同道合的朋友吧(或者说是未来的研友也不为过)，虽然他就住在我楼下但是感觉认识更多的人自己的信息面会广很多啊，这个朋友为我提供了很多资料，我挺感谢他的，毕竟都是失败专业的人嘛，互相帮助互相交流我觉得挺好的，早点认识到自己的失败所在，及时的改正我觉得才是一个正常人应有的判断和抉择。 暑假还打算出去旅游来着，但是好像约的人好多都有事，如果能顺利出行的话会继续到博客上更新的hhh说不定还会拍vlog？(从而成为一名up主？)，说实话我一直都很想做点视频去做一名up主，看到老番茄激励的视频就感觉很兴奋，但是兴奋了一会之后往往又会平静下来，可能这就是我吧。 总之我想摆脱当前这样的生活，一天到晚打游戏的生活虽然快乐但是却并不能给我带来收获，在并不知道自己真正喜欢什么的时候只有努力学更多的知识才能让自己处于不败之地吧(可能) 其实说实话什么时候能真正摆脱人的惰性，我觉得干什么事都能够成功的，摸鱼一时爽，一直摸鱼一直爽，可是时间不等人喔，今年我已经20岁了，已经不再是一个小孩子了，是时候该为自己的未来做打算了，毕竟，不仅是为了自己，也是为了那份执着的信念罢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1168]]></title>
    <url>%2F2019%2F07%2F10%2FluoguOJ-P1168%2F</url>
    <content type="text"><![CDATA[P1168 中位数传送门 这题主要的思路 1.因为这题的数据很大,常规思路就是我每隔两个就sort一下,然后再找出中位数 显然这样做重复的次数会很多,一定会TLE,所以需要转换思路* 2.所以应该从输入的时候一开始就进行插入操作,输入1个插入1个,然后以插入的方式直接有序的插入进去 然后插入3个之后则第2个即是前三个的中位数,然后依次类推。* 3.然后考虑插入操作应该怎么插入,很容易就能想到用二分查找的方式查找到X附近的位置然后进行插入 因为是进行的插入操作所以应该用upper_bound()(或者lower_bound())进行二分查找,然后再进行插入* 自己遇到的坑: 我以为要输入完之后再全部进行输出,但是其实可以一边输入一边进行插入操作 从而降低了时间复杂度。 代码如下：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;//P1168 中位数int N;//N表示整个序列的长度vector&lt;int&gt; val;//定义一个数来存放int main()&#123; cin&gt;&gt;N; for(int i = 1,x;i &lt;= N;i++)//直接用一个变量x就可以代替数组 &#123; cin&gt;&gt;x; //val.insert(val.begin()+(upper_bound(val.begin(),val.end(),x)- val.begin()),x); val.insert(lower_bound(val.begin(),val.end(),x),x);//上式等价的写法,val.begin()被抵消了 if(i % 2 == 1) cout&lt;&lt;val[(i-1)/2]&lt;&lt;endl;//因为存入vector中下标是从0开始的,所以要用i-1,(i-1)/2即是排序好的奇数个数中的中位数 &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1325]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1325%2F</url>
    <content type="text"><![CDATA[P1325 雷达安装传送门 题目描述1234567描述：假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围d。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。数据使用笛卡尔坐标系，定义海岸线为x轴。在x轴上方为海洋，下方为陆地。样例1如图所示 ！样例12345678输入输出格式输入格式：第一行包括2个整数n和d，n是岛屿数目，d是雷达扫描范围。接下来n行为岛屿坐标。输出格式：一个整数表示最少需要的雷达数目，若不可能覆盖所有岛屿，输出“-1”。 12345678输入输出样例输入样例#1： 3 21 2-3 12 1输出样例#1： 2 这题我的思路过程 这题遇到的坑 1.雷达的范围,以及坐标值最好都要用double来确定精度,否则int和double混用来进行计算的时候往往会出现问题* 2.这题的思路刚开始有问题,刚开始我是把所有岛屿的横坐标作参照进行排序,但其实这样会漏掉很多种情况,虽然也是基于贪心的思想, 但是这样子会把横坐标小但是纵坐标很高的情况排到左边,于是就会产生误差* 正确的思路应该是:因为已经知道每个岛屿的坐标和雷达的范围,所以以每个岛屿为圆心以雷达的半径作圆交于X轴都能够得到两个坐标 此时这两个坐标即是雷达所在位置的两个极值,此时按一般的思路从左往右从小到大进行排序, 把所有确定雷达的右坐标从小到大进行排序,首先确定第一个雷达的位置为确定第一个岛屿的右坐标,num++, 然后以这个右坐标为基准,因为贪心的思想,我在两个极值(a,b)之间虽然我放在a或者ab之间的某点都能够覆盖这个岛屿, 但是我如果把这个雷达放在最右边的b点的时候能够覆盖更多的岛屿,所以我放在最右边的b点, 判断这个b点是否大于第二个点最左边的a点,如果可以的话说明这个雷达能够覆盖第二个点,说明就不需要再新加雷达了 然后依次类推,如果这第一个的b点小于某一个点最左边的a点,说明覆盖不到,所以需要新加雷达站,num++ 所以再以这个点的b点为基准来进行判断,然后依次类推,就可以算出雷达站最少的数目了。‘* 3.第三个坑就是雷达站怎么也覆盖不到的情况,即岛屿的纵坐标y恒大于雷达的范围d,那么不管怎么样 都覆盖不到该岛屿,即返回-1 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;//P1325 雷达安装const int maxn = 1010;int num = 0;//存放雷达数int N;//N表示岛屿的数目double d;//d表示雷达的范围struct Node&#123; double x,y;//x,y分别代表岛屿的横坐标和纵坐标&#125;;Node radar[maxn];//定义一个结构体数组来存放岛屿的横纵坐标Node coordinate[maxn];//定义一个结构体数组来存放确定半径之后每个岛屿左右雷达的坐标值double cmp(Node a,Node b)//待会sort的时候以每个岛屿确定的最右边的雷达坐标来从小到大进行排序&#123; return a.y &lt; b.y;&#125;double rightradar(Node a)//已经确定最右边的岛屿,算最右边雷达的X坐标&#123; return a.x + pow((d*d-a.y*a.y),0.5);&#125;double leftradar(Node a)//已经确定最右边的岛屿,算最左边雷达的X坐标&#123; return a.x - pow((d*d-a.y*a.y),0.5);&#125;bool val(Node x)//判断岛屿是否超出了雷达站的范围&#123; if(x.y &gt; d) &#123; return false; &#125; return true;&#125;int main()&#123; //输入数据 cin&gt;&gt;N&gt;&gt;d; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;radar[i].x&gt;&gt;radar[i].y; &#125; for(int i = 0;i &lt; N;i++) &#123; if(!val(radar[i])) &#123; cout&lt;&lt;-1; return 0; &#125; &#125; for(int i = 0;i &lt; N;i++)//计算每个岛屿的左右雷达坐标的极值,并存放到结构体数组中 &#123; coordinate[i].x = leftradar(radar[i]); coordinate[i].y = rightradar(radar[i]); &#125; sort(coordinate,coordinate+N,cmp);//以每个雷达站的右坐标为标准从左往右进行排序 double temp = coordinate[0].y;//先计算第一个雷达站 num = 1; for(int i = 1;i &lt; N;i++)//然后根据第一个雷达站的坐标为基础来进行进一步的计算 &#123; if(temp &gt;= coordinate[i].x) &#123; continue; &#125; else &#123; temp = coordinate[i].y; num++; &#125; &#125; cout&lt;&lt;num;//输出结果 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1182]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1182%2F</url>
    <content type="text"><![CDATA[P1182 数列分段Section II传送门 题目描述1234567891011121314151617181920212223242526272829303132333435对于给定的一个长度为N的正整数数列A-i，现要将其分成M(M≤N)段，并要求每段连续，且每段和的最大值最小。关于最大值最小：例如一数列4 2 4 5 1要分成33段将其如下分段：[4 2][4 5][1]第一段和为6，第2段和为9，第3段和为1，和最大值为9。将其如下分段：[4][2 4][5 1]第一段和为4，第2段和为6，第3段和为6，和最大值为6。并且无论如何分段，最大值不会小于6。所以可以得到要将数列4 2 4 5 1要分成3段，每段和的最大值最小为6。输入输出格式输入格式：第1行包含两个正整数N,M。第2行包含N个空格隔开的非负整数Ai,含义如题目所述。输出格式：一个正整数,即每段和最大值最小为多少。-------------------------------------------------------输入输出样例输入样例#1： 5 34 2 4 5 1输出样例#1： 6 这题我的思路: 这题遇到的坑 1.cmp初始化应为1,或者最后应加1,因为M表示的是分成多少段,而我却搞成了有多少个分隔,导致运行错误* 2.temp初始化为0,之后若temp + num[i] &gt; x,直接令temp = num[i]再进行下一轮循环,而不是令temp = num[i+1] 比如 4 2 4 5 1,如果temp = 4,x = 4,4 + 2 &gt; 4,则此时应有一个分隔即4 | 2 4 5 1,此时再令temp = 2开始寻找下一个分隔,而不是令temp = 4(2之后的4)再进行寻找* 3.如果当cmp &gt; M之后就可以结束循环判断为false,不必令cmp正好 == M,因为如果cmp &lt; M, 也满足条件的话那么只需在已经分好的中间再多加几个分隔符就行了,所以只需判断错误的情况 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;//P1182 数列分段`Section II`const int maxn = 100010;long N,M;//N表示有多少个正整数,M表示要分多少段long num[maxn];//存放数字的数组long long sum = 0;//求和以便进行二分查找long result;//最后的结果bool judge(long x)&#123; long temp = 0; long cmp = 1; for(int i = 0;i &lt; N;i++) &#123; if(num[i] &gt; x) return false; if(temp + num[i] &gt; x) &#123; temp = num[i]; cmp++; &#125; else &#123; temp += num[i]; &#125; if(cmp &gt; M) return false; &#125; return true;&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M;//输入 long l = LONG_MAX; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;num[i]; sum += num[i]; l = min(l,num[i]);//选取num[i]的最小值作为边界 &#125; long r = sum;//选取所有和来作为右边界 while(l &lt; r)//当l == r时才终结循环 &#123; long mid = (l + r) &gt;&gt; 1; if(judge(mid))//判断mid是否符合条件,如果符合就继续往左缩小边界 &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout&lt;&lt;l; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190706]]></title>
    <url>%2F2019%2F07%2F06%2F20190706%2F</url>
    <content type="text"><![CDATA[迟迟到来的总结以及这个暑假的展望嗯，没错，正式放假了四天之后我才记起来要写这个学期的总结和下个学期的展望了先说点题外话吧，自从这个学期搭建了博客以来我感觉还是挺不错的，能够在小地方记录记录自己的生活，写写近些天自己的烦心事，同时记录自己刷过的题目，我觉得挺好的！虽然近一个月都没怎么写了，但是我觉得我还是应该坚持下去，因为经常写博客真的很快乐，虽然确实好多都是些流水账或者重复的内容，但是能够记录自己的生活让我感觉每天生活都是有意义的，不管是学习还是做其他的事情，这样做的正反馈确实挺多的，所以，还需要坚持才行呢，以后我也需要看更多的书来提升自己的知识水平了~而不是天天打游戏~，嗯那就先写这么多好了总的来说这个学期没有做什么事情，可以说是完全浪费了一个学期，因为这个学期本来很宽松的时间并没有被我好好利用，我觉得这是一个很大的教训吧，有的时候过于轻松的环境反而会让人懈怠啊，可能这是老生常谈的话题了但是我还是不得不时刻提醒自己应该去注意这方面的东西，因为人是健忘的，有的时候不到最后一刻可能就没有行动的动力，嗯就像我基友这学期一样吧，上课和考试周都很轻松，这学期反倒挂了两门专业课，我觉得挺不可思议的，虽然确实，这专业课确实傻逼，但是就算不喜欢这门课想及格还是挺容易的 反正失去的时间已经挽回不了，所以我要做的就是怎么把未来的时间去规划好，嗯从放假开始也浪了五天了，是时候该收心来开始计划下这个暑假的学习了 这个暑假我打算主要的目标还是把数据结构学好，下周开始为期一个星期的集训就是很好的机会了，早晨讲课下午训练，感觉这是自己的一个很好的机会去见识下真正竞赛的水平是什么样的。训练结束完之后，还有半个月的时间1.重新复习高数，每天坚持刷五道题，重新开始学习概率论相关内容2.数据结构继续学习，每天坚持完成一道算法题(最好是洛谷上照着训练来一步一步刷题)3.开始学习计算机组成原理的相关知识(到时候买课本回来进行系统的学习和整理笔记)4.C++继续学习面向对象的部分，从八月份开始给自己找一个小项目去写5.观看相关网课，找到合适的网课进行学习(mooc Coursera上找到相关资料)6.每天的学习时间： 早晨：8:00 – 11:30 下午：14:15 – 17:15 晚上：18：00 – 20:00(做每日一题) 20:30之后为娱乐时间，坚持劳逸结合的方法，在学习的时候提升自己的学习效率，不分心多思考，多动手打代码，多和朋友交流，争取自己过一个充实的暑假！嗯，毕竟之前也浪费了那么多的时间了。 最后就是时间的安排了，计划大概八月初去旅游然后回家待一个星期左右的时间然后再回到学校进行半个月的学习，除去集训的时间外，大概有一个月的时间来给自己提升，这次切不可再浪费来之不易的暑假了，我也不给自己安排过多的任务，这个暑假如果能按照这个计划切实落实好的话我觉得我下个学期会很有底气地去做事情了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190616]]></title>
    <url>%2F2019%2F06%2F16%2F20190616%2F</url>
    <content type="text"><![CDATA[迟到好久来的日记摸了好久啊，可能有半个月了？从放松的时光一跃进入考试周，简直就像是在做梦一样，因为根本就没反应过来因为在我的印象里面这学期实在是过的太快了，从2月份开学一直到现在6月份三个多月的时间就这么被我过去了，感觉毫无意义，因为我发现我自己学习缺乏一个系统的过程，每天去leetcode或者洛谷刷题反而让自己没有多大的提高其实仔细想想也不会很奇怪，缺乏系统有效的体系单纯去刷题的提高是很有限的，所以我觉得暑假应该调整好自己的方向刚才又在看陈平教授的眉山论剑，觉得说的真的是太对了第一就是要关心天下大事，关心社会问题在这个时代要有自己的思考第二就是对于未来自己的专业，不是赶着时髦去选专业，而是选适合自己或者自己喜欢做的事情才是最正确的第三就是个人的进步，说来惭愧，我不止一两次在我日记里面写到了，本来大学刚开始就准备要好好学计算机，结果到现在两年了实在是说不上有多少进步，虽然说确实有很多客观的原因影响自己的学习但是人总不能给自己找借口吧，人就是这样子，不喜欢努力，想着天天躺在床上去就能够进步就能够成为大佬，怎么可能呢哈哈哈哈，看着知乎上那些初高中的小弟弟小妹妹们都比自己实力强，不禁心里想问自己心里难道就不会有压迫感吗，我仔细想了想可能也是因为自己周围的环境所造成的，宿舍的人确实过的太舒服了我感觉自己被他们所同化了，其次就是我自己所说的那句话，自己没有经历过的事情，是不会体会到那种感觉的，就是虽然看到知乎上面有那么多的天坑专业的硕士，博士有那么惨痛的经历，可是自己没有亲身体验过，所以没有那种危机感，但是确实，好的话就要听进去，方向比努力更重要，所以我在这里决定，暑假不能够再浪费了，正好在学校也认识了一个志同道合的朋友，虽然之前学校也认识一个沙雕网友还是我把它劝退了，但是在我看来他并没有那么坚定的决心去劝退去脱坑，对于天坑专业还有种幻想，还觉得自己有很多条后路，所以我不太想跟他一起，所以暑假和新朋友去一起参加培训，一起讨论题目甚至还可以一起去考pat，一起明年去考蓝桥杯，我觉得这是很好的事情，自己也确实需要去主动认识一些人了，毕竟你不主动谁来认识你，谁来和你交朋友呢，因为专业的缘故也没参加大学的社团感觉挺遗憾的，所以自己要亲手去弥补这个遗憾才行呢，在网上认识更多的大佬，同时自己也需要更加努力去提升自己的实力才能够配的上跟别人交朋友的资格呢 其次就是这次618自己也买了几本书，我发现自己对经济，近代史方面确实还挺感兴趣的，所以之后为了提升自己的人文素养也要去看这方面相关的知识，到知乎上面多浏览，和知乎上的大佬们多讨论，要形成自己的看法，形成自己的观点，到b站上面多看看陈平教授这样的视频去提升自己的素养，而不是整天去打游戏，最后一学期下来甚至整个大学下来都没有什么收获，嗯但也不是说不去打游戏，偶尔打打游戏还是可以的，但是要掌握一个度才行，每天要完成任务比如完成一道算法题，刷了leetcode或者学了一个算法才能够自己打游戏，否则就不行，所以在7月2号考完之后所以应该进入考研的模式了，同时每天也要坚持对英语和数学的学习才行，嗯虽然自己的技能栏还是空空如也，但是我相信只要有信念什么时候都不算晚。 说到底道理谁不知道呢，关键就是大学里面实在是没有自己喜欢做的事情，只有赶着这个时代的潮流了，想起看过吴军博士写过的《浪潮之巅》，确实心潮澎湃，生活在这个变革的时代，不去顺应潮流去做点什么事情，难道不会感到遗憾么，所以坚定自己的决心去当一名geek不也是挺酷的事吗，但其实对自己来说，可能不逼一逼自己就根本就没有危机感和压力感，所以暑假和朋友要好好讨论讨论自己未来的道路了。 嗯，下个星期就是复习周了所以当前的主要目标就是要应付完这个学期才行，起码及格才行吧，但是能考高一点就高一点，就算自己以后不从事化学这方面的事情，绩点高一点对自己也是无害的。所以加油吧，最后的半个月的时间，需要自己去好好的专注到专业课的方面了，在最后这几天好好努力一把吧，在自习室要提升自己学习的效率了，等考完了再来写日记好好规划下自己吧！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-033]]></title>
    <url>%2F2019%2F06%2F09%2FLeetcode-033%2F</url>
    <content type="text"><![CDATA[33. 搜索旋转排序数组题目描述传送门123456789101112131415161718假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路:数组在某个点进行了旋转，那么原来的数组就不是有序的了，所以我们需要遍历数组来找到那个分界点那么问题来了，怎么才能找到那个分界点呢？ 因为题目要求算法的时间复杂度为 O(log n) 级别,所以我们就不能遍历数组来找到那个分界点 而是应该用二分查找的方式来找到那个分界点才能满足时间复杂度的要求 那么怎么用二分查找来获取那个分界点呢？ 答案就是比较low,mid,high三个点的值的大小比较,如果mid &gt; low,说明low到mid之间是有序的所以令low = mid + 1,否则low到mid之间是无序的，令high = mid 最终知道low == high的时候就找到了分界点，然后再比较分界点之间与target的大小然后再分别到两个区间进行二分查找，可以满足要求 代码如下:1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; //System.out.println(left); int split_t = left; left = 0; right = nums.length - 1; if (nums[split_t] &lt;= target &amp;&amp; target &lt;= nums[right]) left = split_t; else right = split_t; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190528]]></title>
    <url>%2F2019%2F05%2F28%2F20190528%2F</url>
    <content type="text"><![CDATA[两周年回顾嗯这个打算这个星期写完吧，好好总结和反思一下自己，希望未来能够以此引以为戒。 今天还是开了两周年的班会，不知不觉已经两年了，我也从一个新生成为了一个老学长油条了呢青春，就是在不知不觉中慢慢流逝的呢今天的班会上说了些莫名其妙的话，其实根本都不是我内心里面的真实想法，嘛，毕竟这种东西只能对亲密的人说呢 好吧，那现在我好好总结下我这两年的生活吧17年高考完毕之后，填志愿，那时自己也是真的挺傻的，填志愿都不知道去找几个对应专业的学长学姐问问具体的情况，自己在知乎上就随便搜了几个热门的专业确实是想去学计算机和电气相关的专业，可以填六个志愿，最后一个不知道填什么就随便填了化学，于是乎，命运就这样跟我开了个巨大的玩笑，让我的生活发生了巨大的转折 没错呢，分数不够计算机和电气的专业，于是进了化学系，当时的我确实已经产生了后悔的感觉了，但是这种感觉并不强烈，嗯因为自己没有那种强烈的危机感，自己根本就不知道未来的人生计划到底怎么样，于是像个傻子一样没有目的一样的生活，但是自己给自己定的目标就是要远离化学的坑，说来惭愧，过了两年了自己的编程水平并没有什么明显的提升，但是我并不后悔因为后悔也没用了 大一两个学期都是满满的课，每天上课指纹签到，每天晚上都有晚自习，怎么说呢那段时间还是挺让人怀念的吧，如果对于一个好好学习的学生的话确实挺充实的，有我喜欢的微积分的课和vb的课可以上，别的科目虽然不怎么喜欢但是当时自己没有什么别的想法，还是挺充实的吧，说实话那段时间确实还在经常抱怨什么的，因为确实很累，但是回过头来现在这样懒散的生活反而导致自己没有了原来的动力了。仔细回想了下大一真的没有做什么事情，最大的遗憾可能就是错过了计算机协会吧，其实我内心是想进入一个社团去体验一下大学生活的，但是很可惜，当时自己没什么技能也没什么实力所以也没有进入。(其实内心是炒鸡后悔的，错过了认识一大群可爱的人的机会)第二个遗憾的事情可能就是没有好好努力学习知识了吧，把自己的绩点搞上去达到专业的前15%就可以申请转专业了，因为当时自己也不知道转专业的条件和限制，等到了大二去问导员才知道只能大一上学期才能转专业，然而到了大二下学期才知道学校又稍微放宽了大一的转专业的限制，不需要成绩达到前15%就可以申请(所以又错过了一次又一次的机会) 不知道为什么呢，人生就是这样的戏剧性，一次又一次的错过，一直有一件事想搞明白，造成这样的原因到底是因为运气呢还是命中注定呢，不管是大学，高中，甚至是初中，可以改变我命运或者说是人生道路的明明有好几个，但是都被我完美的错过或者说没抓住机会，我真应该好好反思下自己为什么会一而再再而三的犯同样的错误了。 第三个可能做得唯一一件有意义的事情就是去考了计算机二级的证书吧，说来也搞笑，当初自己大一上就报了计算机二级考试，还报了两门，一门C语言和一门office，结果自己复习了好多天，考office还遇到的是原题，结果最后考出来两门都没有过，当时真的是，自己去查成绩真的是想死的心都有了，因为还是自己叫另外一个同学去报考的，他也报了两门，结果别人两门都过了，自己两门都没有过，这种巨大的落差真的是让自己感觉好难受，是的，人生本来就是一直在和别人进行比较的时光，我本来心态也一直不好，当时真的是想去跳楼之类的，但是现在想起来这算什么呢，人生的挫折多了去了，可能就是因为要经历过很多很多事情才能锻炼出自己强大的内心吧。嗯，然后下半年又去报了一门C语言，还是自己一个人去的，万幸，这次终于过了，虽然没能拿到优秀，但是良好也挺不错了，总之这次过了之后自己的内心才能有所释怀，毕竟是大学的第一个证书啊，然后我自己下定决心，趁着大学剩下的时间要把能考的证书全部考了(flag无疑) 第四个不好的事情可能就是大一下的无机化学了吧，这个给我的印象挺深的，无机的一次期中考试，考完之后我在全班是倒数第二，这个成绩真的是震惊到我了，可以说是第一次不完全意义上的挂科了吧，然而让我想到我室友的挂科的惨状，下个学期莫名其妙多了一门课要去学，还有补考，那真的是炒鸡痛苦啊，然后我下定决定好好学，万幸最后居然过了，这次给我的警告让我知道了大学决不能挂科啊，不然带来的后果简直就是太痛苦了。 emmmmm好像没了呢，大一好像就这些给自己深刻印象的事情了。 大一的暑假，可真的是太混了，在暑假打了两个月的游戏，说好要学习也没怎么学(间接导致了我现在的现状)想出去旅游也找不到人可以一起出去玩，那时候真的是孤独和寂寞啊，现实中也找不到人可以一起玩，网上也没多少人可以说话，我也不知道当时我是怎么过来的。 然后就进入了大二吧，大二刚进来的时候就进行了所谓的实训，快乐了半个月吧，去博物馆参观和去化工厂参观，说实话其实就是一个走流程的东西，根本就学不到什么东西，去参观化工厂给自己的感受就是又苦又累的生活，我自己下定决心以后要远离这种生活呢。然后大二的课也是好多好多除了好多实验就是好多无意义的课了，当然还有我最讨厌的大物了说起来我也不知道为什么按理来说数学好的人物理不会差到哪里去，但是我偏偏是相反的那一个了，数学还行吧，但是物理真的是巨差无比，哈哈哈我好像不喜欢那种抽象出数学模型的东西。可能我做的最明智的一个决定就是去参加数学竞赛了吧，说巧不巧，其实我之前也不知道这个消息的，还是我一个朋友告诉了我想跟我一起参加比赛之后才有这个想法要去参加一下比赛，嗯买了一本那个黄书去学，每天晚上去学那个知识，真的是炒鸡痛苦，因为我真的是很不喜欢证明题，然后就准备了几个星期去参加初赛，说实话我到现在都不知道是怎么跟我算的成绩，我明明感觉我初赛考的稀烂。。。。然后就告诉我过了，然后要我去参加复赛不过那次经历真的让我超喜欢啊，出去代表打比赛什么的，真的是好有成就感，什么东西都能找学校去报销，和一个同学在酒店住了一晚上hhh那天晚上真的是好美妙啊，好像晚上八点就复习不下去了，从第一天晚上的八点睡到第二天的七点，足足睡了十二个小时，这可能是我这辈子睡的最久的一次了，然而第二天复赛的题目真的好难啊，我好多题都看不懂，最后还是草草的虽然写了然后就交卷了，然后再和别人一起回学校。嗯最后出结果我居然还是考了个省一，真的是在我的意料之外啊，虽然不那么完美，但是对于误打误撞就获奖的我还算挺幸福的了，从此我也知道要好好学习只有自己的实力不断的提升才能自信的去面对任何困难(还有一个惊喜就是前几天突然告诉我省一原来还有奖金hhhh，意外之中的收获吧，但是不知道多久才能打到我的卡上qaq) 之后印象深刻的事情可能就是元旦晚会了吧，不知道为什么呢我就是想参加表演呢，因为感觉自己大学确实没参加过什么精彩的事情呢，于是就和几个室友和同学一起去表演了一个话剧，啊，每天晚上上完晚自习都去练习，动作什么的都要练好练到位，现在想想真的是挺辛苦呢，其实是挺浪费时间的。到了上台的那一天真的是，说实话因为其他人的节目都挺精彩反而我们的节目不那么精彩了，所以没能在同学的记忆里面留下深刻的印象，说实话我挺灰心的，因为付出小于回报，自己辛辛苦苦练了几个星期的节目还不如别人一个女装的印象深刻xd，但是总之还算是很美好的一个回忆了。 然后就是这个学期，大二下学期，可能是最舒服的一个学期了，课也没多少，我也经常逃课去自习，自己可以利用的时间真的是多多了，但是很可惜啊，从三月份到五月份，整整三个月的时间我的水平还是没什么长进，还是停留在数据结构这上面很久了(说到这个真的是对自己好气好气，有的时候不逼一逼自己根本就不行)但是这个学期说实话我并不觉得轻松，因为有三门跟物理相关的专业课要去考试，今天已经2号了，24号就要考第一门了，留给我的时间已经不多了，我决定就算要复习每天也要坚持学习算法，这个绝对不能断，自己给自己买的专栏要看，要实现的算法要坚持自己去实现一遍才行，再加上昨天到的xm3耳机，不能再找借口去放松什么的了，争取重新到达高三那时候的水平，不能再安逸下去了。对了还有15号的6级考试，这个也要认真的去准备，争取一次过，不能让明年考研的时候还被这个困扰。 好了，星期二就开始想写的这个东西我今天终于摸完了，说实话这两年其实不那么精彩，我在大学认识的人也太少了，可以获得的信息也太少了，以后要主动去认识更多更有趣的人才行呢，改变别人不如改变自己，主动去认识别人主动和别人交朋友才能充实自己嘛，虽然有时候会遇到尴尬，但是自己不主动就不会有故事呢！在网上也是这样，争取到知乎上认识更多的小可爱(划掉)qaq哼唧嗯，总结篇就写这么多吧，过几天再写关于未来具体的计划和要达成的目标吧。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1141]]></title>
    <url>%2F2019%2F05%2F24%2FluoguOJ-P1141%2F</url>
    <content type="text"><![CDATA[P1141 01迷宫传送门题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式：第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来mm行，每行22个用空格分隔的正整数i,j对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式：m行，对于每个询问输出相应答案。 输入输出样例：1234567891011121314151617181920212223242526272829303132输入样例#1： 2 201101 12 2输出样例#1： 44--------------------------------------------------输入样例#2： 8 410010011011001001001001101011011100010000001101100101000000000101 28 66 24 3输出样例#2： 2519125 思路：定义一个数组val来存放迷宫，定义一个数组cmp来判断是否走过1.这道题一眼看上去就是一个深搜，把01用二维数组存下下来，搜索每一个格子然后判断合理情况，如果遇到不相同的格子就记录然后每遇到一个点就重新memset一下cmp重新开始噼里啪啦一顿dfs交上去，TLE了三个点只有70分 2.这样做问题出在哪里呢？我把测试数据看了一下，发现很恶心，n和m分别取到了1000和100000，那显然，memset是很耗时间的于是我想到把cmp数组的标记改为layer，代表所搜索的格子所在的不同联通块。这样，每一次去数新一个格子所能联通的块数就只要更新layer，节省了很大一块时间(这样就不用每次memset一次cmp数组我觉得这样的做法很巧妙)成功过掉了第二个点也就是n=1000, m=10000的点 3.但是还有两个点TLE，说明还要需要改进的地方需要我去思考苦苦思索，是与否有其他优化方法，果然，有一条很明显的但是一早就被我忽略了： 同一个联通块所在的格子，能到达的格子数都是相同的。这样一看，怎么记忆化就已经很明显了，我们已经用cmp数组标记过了当前搜索的格子所在的联通块，用layer表示，那么我们只要再开一个record数组，将已经遍历过的联通块对应的格子数记录下来，那么搜索到相应联通块里的其它格子时，就不用再搜索了，这是一步很大的优化，最终我提交了修改过的代码，100分ac 自己遇到的坑：第一个坑: OJ上要求的是直接输入一串数而不是一个数字一个数字输入的我觉得这个挺坑的，我就懒得换了，直接char一个数组去接受，然后再int一个全局数组去修改对应的值，这样做其实挺傻的，还有可以改进的地方~(但是我懒啊)~第二个坑: OJ要求的输出是输入数据之后全部输出，所以就还要再定义一个sum数组去存放数据，最后再全部输出。 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int maxm = 100010;int num = 0;int layer = 1;int record[maxm];char sum[maxn][maxn];int val[maxn][maxn];//定义一个二维数组才存放n*n的迷宫int cmp[maxn][maxn];int n,m;//n表示n*n迷宫,m表示询问的点的个数//方向数组int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; cmp[x][y] = layer; record[layer] = ++num; for(int i = 0;i &lt; 4;i++) &#123; int a = x + dx[i],b = y + dy[i]; if(val[a][b]==val[x][y]) continue; if(cmp[a][b] == layer) continue; if(a &gt; 0&amp;&amp;a &lt;= n&amp;&amp;b &gt;0&amp;&amp;b &lt;= n) &#123; cmp[a][b] = layer; dfs(a,b); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;sum[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; (sum[i][j] == &apos;1&apos;)&amp;&amp;(val[i][j] = 1); &#125; &#125; int sum[maxm]; for(int i = 0;i &lt; m;i++) &#123; num = 0; int temp1,temp2; scanf(&quot;%d %d&quot;,&amp;temp1,&amp;temp2); if(record[cmp[temp1][temp2]] == 0)&#123;//如果record里面temp1和temp2对应的cmp的值为0的话就进行dfs，并记录到record中 dfs(temp1,temp2); sum[i] = record[cmp[temp1][temp2]]; &#125; else//遇到相同的联通块直接输出对应的record &#123; sum[i] = record[cmp[temp1][temp2]]; &#125; layer++; &#125; for(int i = 0;i &lt; m;i++) &#123; cout&lt;&lt;sum[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-022]]></title>
    <url>%2F2019%2F05%2F24%2FLeetcode-022%2F</url>
    <content type="text"><![CDATA[22.括号生成难度:medium123456789101112题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路：应用递归的思路来解决这道题只有当左括号大于右括号的时候才进行递归但其实递归的实质就是栈的实现 代码如下:123456789101112131415161718192021class Solution &#123;public:void val_generateParenthesis(int left,int right,string str,int n,vector&lt;string&gt;&amp; val)&#123; if(left &gt; n || right &gt; n) return ; if(left == n &amp;&amp; right == n) val.push_back(str); if(left &gt;= right)//只有左括号的数目大于右括号再进行递归 &#123; val_generateParenthesis(left+1,right,str+&apos;(&apos;,n,val); val_generateParenthesis(left,right+1,str+&apos;)&apos;,n,val); &#125;&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; val; val_generateParenthesis(0,0,&quot;&quot;,n,val); return val; &#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190523]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[半个月来摸出来一点东西吧上回写日记还是5月12号，一晃眼就已经23号了啊这个五月我过得还是比较充实的，基本上实现了基本预定的目标不管是学习上还是其他方面，但是现在面临的问题也更多了诶多，6月15号的六级考试过了之后，23号就要开始期末考试了今天正好整整一个月的时间吧，不说之前重复的话了，没意思，好好努力吧，争取让充实的五月不忘初心吧 今天晚上又发生了不好的事情呢，我和好朋友又吵架了呢，像个hape一样那么大声在街上吵架。。。简直就像是失了智一样，我发现我有的时候就喜欢这样。。。喜欢跟别人较真，喜欢跟别人死磕，每次都是因为一些小事吵起来真的挺无语的，吵架的时候非要分个对错才行吗？有的时候想想就能明白的道理，自己却不去想不去思考，那再有用的大道理又有什么用呢？ 所以啊抛弃这种幼稚的思想吧，努力去成长为一个大人吧！ 这其中也发生了好多好多事情，我也想借这个机会聊聊我自己的看法，比如中美贸易战以及Trump制裁华为这几件事，让我觉得世界并不太平，Trump的目的可能是和以前的日本一样逼迫中国签订类似广场协议的条约所以去年中兴被制裁，领导人直接就去谈判了，今年华为更加严重反倒没去，说明我们是准备和美国打而不是准备去谈判妥协问题。但是我觉得这个时代自己不能太缺乏知识了，还是要去多了解历史经济相关的知识才行。最近看b站上陈平教授的&lt;&lt;眉山论剑&gt;&gt;，我觉得陈平老师的知识很精辟也很到位，对当前一些热点问题的分析我觉得有自己独特的看法，而且也敢说话，没有架子我决定去买本陈平教授的&lt;&lt;代谢增长论&gt;&gt;，多看一点历史案例和西方的一些兴衰史真的是很有意思啊，丰富自己的知识和阅历，我还从来没有主动迫切的想买一本书的时候啊。。。。其实增加自己的知识水平比打游戏更有意思，我决定大学还有两年要利用好时间去学习更多相关的知识，争取能够早日达到能够在知乎上分析问题得出自己观点的水平吧！ 可能是一个最好的五月，也可能是一个最坏的五月x，具体怎么样全看你自己了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1443]]></title>
    <url>%2F2019%2F05%2F23%2FluoguOJ-P1443%2F</url>
    <content type="text"><![CDATA[P1443 马的遍历题目描述有一个n*m的棋盘(1&lt; n,m &lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步 输入输出格式输入格式：一行四个数据，棋盘的大小和马的坐标 输出格式：一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1） 1234567891011121314151617181920#输入输出样例输入样例#1： 3 3 1 1输出样例#1： 0 3 2 3 -1 1 2 1 4输入样例#2：6 9 1 1输出样例#2：0 3 2 3 2 3 4 5 4 3 4 1 2 3 4 3 4 5 2 1 4 3 2 3 4 5 4 3 2 3 2 3 4 3 4 5 2 3 2 3 4 3 4 5 4 3 4 3 4 3 4 5 4 5 思考:这题就是一道很典型的bfs的题目根据题目给的首节点，来存入队列里面定义方向数组来模拟马走的八个方向然后把首节点存入队列，然后取出首节点，依次遍历八个方向，然后如果可以就Map2 = Map1 +1这样的话根据这个递推公式可以推出所有可以走的点最后还记得定义一个path数组来判断是否走过就行了 这道题目里面的坑:题目要左对齐宽五格所以要printf(“%-5d”,Map[i][j]) 代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;//P1443 马的遍历int n,m;//定义const int maxn = 410;//定义方向数组来定义马走的八个方向int dx[8] = &#123;1,2,2,1,-2,-1,-2,-1&#125;;int dy[8] = &#123;2,1,-1,-2,1,2,-1,-2&#125;;int Map[maxn][maxn];//定义一个数组记录棋盘上的int path[maxn][maxn];//定义一个路径来判断是否走过当前路径struct Node&#123;//定义一个结构体才存放棋盘坐标的值 int x,y;&#125;;queue&lt;Node&gt; val;//定义一个来存放结点void bfs(Node s)//传入结点&#123; val.push(s); Map[s.x][s.y] = 0;//定义开始为0，其余的结点都是依照这个点而来的 path[s.x][s.y] = 1;//记录路径为走过 while(!val.empty())//如果队列里面不为空则继续循环 &#123; Node temp = val.front(); val.pop(); for(int i = 0;i &lt; 8;i++)//八个方向来进行探测 &#123; Node cmp;//定义一个中间变量来存放数据 cmp.x = temp.x + dx[i]; cmp.y = temp.y + dy[i]; if(path[cmp.x][cmp.y] != 0||cmp.x&lt;1||cmp.x&gt;n||cmp.y&lt;1||cmp.y&gt;m) continue; path[cmp.x][cmp.y] = 1;//记录为走过 Map[cmp.x][cmp.y] = Map[temp.x][temp.y] + 1; val.push(cmp); &#125; &#125;&#125;int main()&#123; memset(Map,-1,sizeof(Map));//定义Map上所有结点为-1，如果这个值不会改变则说明这个点根本走不到 Node s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s.x&gt;&gt;s.y; bfs(s); for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; printf(&quot;%-5d&quot;,Map[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1162]]></title>
    <url>%2F2019%2F05%2F20%2FluoguOJ-P1162%2F</url>
    <content type="text"><![CDATA[P1162 填涂颜色123456789101112131415题目描述由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字11构成，围圈时只走上下左右44个方向。现要求把闭合圈内的所有空间都填写成22.例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：0 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1-----------0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 输入输出格式输入格式：每组测试数据第一行一个整数n(1&lt;=n&lt;=30)接下来n行，由0和1组成的n×n的方阵。 方阵内只有一个闭合圈，圈内至少有一个0。 输出格式：已经填好数字2的完整方阵。 输入输出样例12345678910111213141516输入样例#1： 60 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1输出样例#1： 0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 说明: 1&lt;=n&lt;=30 思路:定义一个a数组来接受方阵，然后定义一个b数组，在a数组的外围套一层边界，也就是套一层0，这样做的目的是为了让dfs边界的时候能够把闭合圈以外的部分都能够标记(也就是染色) 然后定义方向数组，从(0,0)开始往四个方向依次寻找两个边界中间的部分然后标记，然后b数组对应没染色的地方就是a数组方阵闭合圈里面要找的 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 40;//定义最大的边界int a[maxn][maxn];//用来接收方阵的数组int b[maxn][maxn];//把方阵外面套一层边界,便于dfs寻找边界int N;//N表示N * N的方阵//方向数组,依次为右下左上int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; //当dfs寻找值碰到外边界和内边界时返回上一层 if(x &lt; 0|| x &gt; N+1||y &lt; 0||y &gt; N+1||b[x][y] != 0) &#123; return ; &#125; //如果没碰到边界,继续搜索,令两个边界中间的值为2,并沿着四个方向继续搜索 else &#123; b[x][y] = 1; for(int i = 0;i &lt; 4;i++) &#123; dfs((x + dx[i]),(y + dy[i])); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N; //输入方阵 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(a[i][j] == 1) b[i][j] = 2; &#125; &#125; dfs(0,0);//对加过边界的b数组进行搜索 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(b[i][j] == 0) &#123; a[i][j] = 2; &#125; cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-019]]></title>
    <url>%2F2019%2F05%2F15%2FLeetcode-019%2F</url>
    <content type="text"><![CDATA[19. 删除链表的倒数第N个节点难度：medium1234567891011题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。 我自己的思路:(两次遍历链表的想法)先定义一个num遍历链表记录结点的总数，然后定义一个cmp = 0，当再次遍历到num - n -1时就表明这个时候的结点是在要删除结点的前一个结点，然后再进行删除操作 这题遇到的坑：不知道leetcode到底有没有头结点，结果最后发现没有头结点，head对应的就是第一个结点，最后定义了一个newhead做头结点来进行操作，如果 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* newhead = new ListNode(0); newhead-&gt;next = head; int num = 0,cmp = 0; ListNode *temp1,*temp2; temp1 = newhead; temp2 = newhead; while(temp1 != NULL)//统计链表的结点数 &#123; temp1 = temp1-&gt;next; num++; &#125; while(cmp != num - n -1 )//定位到要删除结点的前一个结点 &#123; temp2 = temp2-&gt;next; cmp++; &#125; ListNode * flag = new ListNode(0); flag = temp2-&gt;next; temp2-&gt;next = flag-&gt;next; return newhead-&gt;next; &#125;&#125;; 官方的题解思路： ###方法一：两次遍历算法 ###思路 我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。 ###算法 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。 Java代码如下:123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next;&#125; ##复杂度分析 时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。 ###方法二：一次遍历算法 ###算法 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 Java代码如下:1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next;&#125; ###复杂度分析 时间复杂度：O(L)，该算法对含有 L个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-018]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-018%2F</url>
    <content type="text"><![CDATA[18.四数之和难度: medium1234567891011121314151617题目描述:给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路:回顾一下三数之和的思路:三数之和的主要思路在于双指针的遍历先把数组从小到大排序，然后再从nums[k]开始从左往右进行遍历因为a + b + c = target此时只要 b + c = target - a相等的话就算找到了然后就是相当于定义两个双指针分别对应 b 和 cint i = k+1int j = nums.length() - 1然后 i , j从k的右边到数组的边界，从两头分别开始进行遍历如果nums[i] + nums[j] &lt; (target -nums[k]) 那么就说明i还需要更大一点才能相等,i++如果nums[i] + nums[j] &gt; (target -nums[k]) 那么就说明j还需要更小一点才能相等,j–最后nums[i] + nums[j] == (target -nums[k]) 的时候记录数据这个时候进行去重的操作，因为第一次相等之后，如果i,j,k后面还有重复的数字的话那么就会有重复的结果那么如果遇到符合条件的重复数组就i++,j–,k++去重 四数之和==&gt;三数之和==&gt;两数之和跟三数之和类似，多了层循环遍历数组，同时也需要注意数组的去重操作1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); for(int k=0;k&lt;nums.size();k++)&#123; int i = k + 1; int j = nums.size() - 1; while(i &lt; j)&#123; int value = nums[i] + nums[j]; if(value &gt; (0-nums[k]))&#123; j--; &#125;else if(value &lt; 0-nums[k])&#123; i++; &#125;else&#123; vector&lt;int&gt; list; list.push_back(nums[k]); list.push_back(nums[i]); list.push_back(nums[j]); res.push_back(list); while(i&lt;j &amp;&amp; nums[i] == nums[i+1])&#123; i++; &#125; while(i&lt;j &amp;&amp; nums[j] == nums[j-1])&#123; j--; &#125; i++; j--; &#125; &#125; while(k&lt;nums.size()-1 &amp;&amp; nums[k] == nums[k+1])&#123; k++; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190512]]></title>
    <url>%2F2019%2F05%2F12%2F20190512%2F</url>
    <content type="text"><![CDATA[一点点小总结吧迟到了两天才有时间写个总结，我也真是懒啊hhh忙碌复习一周的感觉简直就是要了我的命，从零开始学习令我厌恶的化学真的是让我作呕可是我又能有什么办法呢(笑)，为了不挂科，也只能用心的去学了呢，每天一有空就去自习室简直就是让人窒息啊，就感觉提前进入了复习周一样难受啊，不过以后每个周末都要好好努力复习了呢 总之总之，期中考试终于over了，接下来是新の五月的生活啊虽然已经过了一半了，但是也要好好的充实才行呢 这几天又发生了几件让我不开心的事情呢，果然不是每个人都是善意的呢，有的人不喜欢被主动勾搭，有的人不喜欢和我说话，真的是好遗憾呢 诶多诶多，这每天记流水账一样的日记简直就是让我想吐啊233333，果然每天还是应该乱写点想写的东西才好吗 啰里啰嗦了半天还是决定以后如果有意义的事情再来写日记吧233333那么就这样吧今天，希望以后能继续写更多有意义的东西呢]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190509]]></title>
    <url>%2F2019%2F05%2F09%2F20190509%2F</url>
    <content type="text"><![CDATA[令人绝望的星期四嗯，一个星期唯一没课的一天，硬是自己把自己搞自闭了，早晨7点本来只想趴着休息会，结果睡着睡着就睡到九点半了，唔，然后一个上午相当于啥都没干，中午又睡了个觉磨磨蹭蹭到三点钟才起床去自习室，然后到自习室混了7个多小时到十点左右再回来 结构真的是好难啊，好多东西我都搞不懂，还有一天多的时间去学，还有物化这块硬骨头要啃，呜，这个星期过了我就好好做人，游戏都删掉的我要过一个不一样的五月！ by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190508]]></title>
    <url>%2F2019%2F05%2F08%2F20190508%2F</url>
    <content type="text"><![CDATA[星期三的烦恼嗷今天真的是忙碌的一天嗷，从早到晚满课嗷，今天凌晨四点钟突然惊醒然后睡不着，到床上折腾了半天估计有半个小时吧才睡着，诶诶多结果一醒来结果利物浦居然把巴萨逆转了！！！哇塞，创造历史的一场比赛啊，还没有球队能够在客场0比3的情况下，主场逆转翻盘！真的是荡气回肠的一场比赛，说实话我其实挺喜欢利物浦的，尤其是渣叔克洛普，我超喜欢的！真心希望利物浦能赢得欧冠啊，去年的遗憾今年不能再重蹈覆辙了。 早晨日常逃课，但是早晨学习的效率是真的低啊，又困又要学习，真的是好难熬啊嗷嗷，期中考试的一周真的是难受难受难受难受的要死了，一个星期要学完前面几个月的知识我真是个天才哈哈哈哈哈哈嗝才怪，希望这星期能应付完期中考试吧，再准备其他比赛。 晚上真的是没心思学习了，晚上看汉堡王做活动没忍住买了四五十的外卖呜呜呜，我真的是败家玩意嗷，还口口声声说减肥呜，估计又要胖回去了，嗯嗯这一定是最后一次，嗯最后一次啦，以后为了减肥可不能再这样了5555555 最后就是不能理解为什么要晚上停电维修，唔，明明早晨宿舍都没人它不去检修，非要晚上还没睡觉的时候就停电检修，搞不懂电力部门在想什么 那么今天就这样吧，晚安啦，希望明天没课的一天我能复习完物化和结构的大部分。 by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190507]]></title>
    <url>%2F2019%2F05%2F07%2F20190507%2F</url>
    <content type="text"><![CDATA[今日份的记事今天真的是不一样的一天呢 早晨日常去上体育课，本来以为要体测做引体向上，结果那个老师是个明白人233333，我本来一个也做不了的qaq结果挂上面抖了抖就给我算满分了hhhhh，然后测完中途就溜回去洗了个澡就休息了，嗯挺不错的。 中午倒是发生了一些事情让我有点害怕，中午日常吃饱饭，但是一站起来就感觉胃特别不舒服，还好我室友给了我胃药缓解多了，但是以后必须得格外注意了，不能吃的太饱233333 下午好不容易起来去自习室，但是感觉还是效率不是太高，好在今天把物化第二章复习完了，接下来就是明天继续复习第三章和去写期中考试卷子了，嗯感觉这个星期如果熬过去感觉这次的考试是可以挺过去的。 晚上倒是发生了很多愉快的事情，和同一类人聊天是真的愉快，说什么话都能很快就明白根本不用多费口舌，别人说什么东西也能很快就能懂意思，不仅仅是一起讨论问题还是去探讨一些别的话题，我们在一起聊天是真的很开心很开心！希望以后多和这样的好朋友在一起为未来的前途努力吧！说实话真的是很烦为什么没分配到一个宿舍里面啊真的是，我现在越来越讨厌我的室友了，真的不是一类人，只会天天打游戏，应付考试应付别人，关键是还喜欢影响别人，等着瞧吧，再过两年我们走着瞧咯。 这个星期复习完专业课后要重新开始学习算法，英语和数学，嗯一个也不能拉下，尤其是已经把游戏全部都卸载掉了，嗯五月初自己说过的话千万不能再忘了，已经失去太多的东西了好像已经没有再可以失去的了，一起学习的朋友晚上熬夜到三点中还在做leetcode，感觉自己跟别人比起来真的是太舒服了，要找回原来的那种状态，要去让每一天都充实起来才行！加油吧，每天都不忘初心方得始终。 by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190506]]></title>
    <url>%2F2019%2F05%2F06%2F20190506%2F</url>
    <content type="text"><![CDATA[预习第一天的感受不开心的第一天嗷，不过早晨做实验是真的混啊2333333，本来以为今天要做很久的实验，看了那么一大堆步骤，结果老师都不让我们去做，给了个粗品要我们直接去提纯，简直太快乐了啊哈哈。 昨天Trump的一条推特导致今天A股暴跌真的是闻所未闻，都快跌6%了，简直就是股灾啊，看别人评论说的，别人美国总统一句话就能让你一无所有，很真实，股市的风险确实是太大了，我觉得我在大学这个阶段一定要慎之又慎才行，我搞这个心态又不好23333，所以要锻炼自己在金融方面的知识才行呢，做一个知识全面的人才行呢。 下午就不怎么快乐了，今天开始复习物化了，但是真的是好烦啊，本来就不喜欢物理相关的知识，但是这学期两门专业课都涉及物理，简直让我绝望5555555，还以为就算不怎么好好学考试考好点能拿奖学金呢，可惜这学期估计科科及格都难咯 下午在自习室从4点一直搞到9点半，除去要去上课签到花了点时间，差不多有将近五个小时的时间都可以学习，但是效率是真的低，在自习室整个人都快自闭了，太安静的环境也不适合去学习，脑阔里面非要听点电音或者轻音乐才能去集中自己的注意力，但是有的时候听多了反而又容易走神23333，真的是很难抉择呢，但是好在是已经开头了，我有信心去准备这次的期中考试，这个星期好好努力吧，争取达到能应付考试的水平就行了，然后下个星期再开始准备学习算法，天天运动，嗯，这学期不能再像之前那样了 这可是你自己说要过一个不一样的五月啊，成年人就应该信守自己所作出的承诺。 嘛，今天就写这么多吧，每天写日记写博客真的是让自己很喜欢这种生活，为什么不早点开始坚持记录自己每天的生活呢？嘻嘻]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190505]]></title>
    <url>%2F2019%2F05%2F05%2F20190505%2F</url>
    <content type="text"><![CDATA[今日份的不知所云嗯，五一假期后的第一天上学，感觉还行吧，感觉自己的状态有所回升呢，但是感觉还是要加把劲呢，还有一个星期从零开始准备期中考试啊，真的是最不舒服的一个星期要来了呢 今天真的是莫名其妙的惊喜呢，空间里面突然有个大佬加我，真的是猜不透呢，不是一个世界的人原来想接触我这样的普通人吗？感觉别人的思想真的是不一样呢，想去顶级名校，想去拯救整个社会，想去改造别人的思想，想去像儒家一样去兼济天下，唉，可惜呢，只有生存无忧才会去想这些事呢，继承家产，到大城市的地方有几套房，我如果有这么好的家室就好了啊，有钱可以买自己想买的东西，也没有学业，事业上面的压力就好了，可是啊，这只能存在于幻想之中呢，现实就是我出身一个十八线小城市，没车没房，家里也没钱，唯一值得庆幸的就是父母都挺开明的，知道自己没什么知识，敢于让我自己去做决定，自己去做决定自己未来的人生道路，我觉得这也是不幸中的万幸了吧！ 还有一件事就是我今天才知道我的一个室友前几天刚脱单，这几天又找到了新的女友，怎么说呢，别人大学都谈了三次了我还一次都没有，怎么说呢，从小到大我可能对感情都没有概念吧，被老师把恋爱这个选项在脑海中删除了(其实也有小学到高中越来越丑越来越胖的原因)，但是谁不渴望爱情呢，不说那么奢侈的东西吧，我其实渴望被关心，渴望和别人每天聊天，渴望和别人分享自己的快乐和烦恼，谁喜欢孤独呢，孤独都不是被逼的吗？如果遇到合适的人和志同道合的人，谁又想一个人呢。 诶多，不知不觉又写了这么多，我也不知道自己天天在说什么，但是感觉日常写日记真的让自己感觉很棒，我会继续坚持下去的，记录自己生活的点点滴滴，这样的感觉真的很棒，等我觉得哪天我的东西可以分享给别人的话就会给你们看的，毕竟日记也不是不可以分享给别人的东西，我也希望有人来看我每天生活的点点滴滴，希望以后能遇到更多更棒的朋友！ by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-002]]></title>
    <url>%2F2019%2F05%2F04%2FLeetcode-002%2F</url>
    <content type="text"><![CDATA[2. 两数相加难度 : medium题目描述:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。12345示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析：两个非空的链表表示两个非负的整数，既然是按照逆序的方式来储存，那么就应该对两个链表分别从头开始遍历进行加和操作 用x,y来分别取出两个数对应的数位,用carry来记录是否需要进位先令carry = 0,再计算sum = x + y + carry;如果 sum &gt;= 10,则令carry = 1再让 sum % 10来组成新的数的每一位如果其中一个链表有数可以取出,而另一个链表的下一位为NULL则令为NULL的那一条链表对应的x或者y为0即可 然后最后结束的时候如果carry还为 1,说明最后还多出来一位,则应该再额外多进1。 自己在这题中遇到的问题:Leetcode给的构造函数(struct跟class一样啊，我真的是有点傻了)既然它给的有构造函数ListNode(int x) : val(x), next(NULL) {}则初始化对象的时候一定要调用,那么定义新的结点的时候就一定需要一个初始值(比如0),否则会报错。 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p1,*p2,*p3; ListNode *l3 = new ListNode(0); p1 = l1; p2 = l2; p3 = l3; int carry = 0; while(p1 != NULL || p2 != NULL) &#123; //如果对应的数位为NULL,则直接令其为0 int x = (p1 != NULL) ? p1-&gt;val : 0; int y = (p2 != NULL) ? p2-&gt;val : 0; int sum = x + y + carry; (sum / 10)? (carry = 1): (carry = 0); ListNode *s = new ListNode(0);//定义一个新的结点来存放结果,一定要初始化才行 s-&gt;val = sum % 10; p3-&gt;next = s; p3 = s; (p1 != NULL) &amp;&amp; (p1 = p1-&gt;next);//代替if的语句 (p2 != NULL) &amp;&amp; (p2 = p2-&gt;next); &#125; if(carry)//如果最后carry还为1,则说明还需进一位 &#123; ListNode *s = new ListNode(0); s-&gt;val = 1; p3-&gt;next = s; p3 = s; p3-&gt;next = NULL; &#125; l3 = l3-&gt;next; return l3; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新の开始？]]></title>
    <url>%2F2019%2F05%2F04%2F20190504%2F</url>
    <content type="text"><![CDATA[新の开始胡乱写一些自己都看不懂的话重新再来，从头开始真的是令人怀念的话语啊,上一次说这个话是高考前一百多天的时候,结果说完也没有多么努力去改变自己的命运,结果自己到了今天这个地步,如今,实在是没有什么可以再失去的东西了 青春？梦想？努力？奋斗？再为自己的年轻付出巨大的代价之后才会后悔,可是又能有什么用呢？一次又一次的悔恨,一次又一次的失败，我实在是厌倦这样的生活了,不知道两年前的自己怎么也想不到今天会到这种地步吧，不仅什么也不会，而且也缺少朋友，缺少能天天和我一起说话的人 孤独？谁又喜欢孤独呢，谁希望自己被逼成这样呢，孤独的人也渴望和朋友一起聊天，一起分享每天的欢乐，一起诉说每天的烦恼，这是我梦想中的生活啊。 然而，每天简直就是有无穷无尽的烦恼，不仅是学业上还是生活中。经过了两年的时间，自己还是啥都不会，虽然早就下定了转行的决心，但是相比跟我年龄一样的科班的人，差距还是巨大，只有每天付出比他们更多的努力才能让自己变得更强生活上，每天被室友吵得心烦，天天只会打游戏，混日子，每个星期还要去实验室跟老师搬砖还浑然不知未来的处境如何，真的是感觉可悲，真不知道再过两年他们会有什么感受。 想起了高中班主任跟我说的话，眼界决定境界，态度决定高度，这句话我现在细想起来还真的是太对了，但可惜我两样都没有论眼界，从小城市出身的我真的是眼界太低，见识也太低了，居然稀里糊涂的报了化学这个天坑专业，高中还以为化学挺有意思的，谁知道大学完全是两个完全相反的学科，跳进了坑真的是感觉自己蠢到极点。论态度，我明知道每天自己该干嘛，却还是天天摸鱼，喜欢看b站，喜欢逛知乎，喜欢玩游戏，反正每天除了学习真的是一堆事都能做，但是只要学习就容易犯困，提不起劲，这个学期把没用的课都翘了好好学算法，学相关一堆知识可以学，但是我还是喜欢浪费时间，整天摸鱼，然后从2月份一直到现在，我真的忍受不了了，必须做出一点改变来才行了，不然就算再给两年的时间给自己也是白费。 已经20岁了，不再是一个小孩子了，是时候该为自己的未来，为自己的前途好好考虑一下了，人不是为自己而活，你还要付出很多很多东西才行，不说那么远，就说为了将来自己幸福的生活现在也应该要好好行动了。嗯，今天把游戏全都卸载了，时间是宝贵的，再也经不起我这样浪费了，两个月的时间，我想重新调整自己的状态，该去自习室去自习室，该休息休息，以后每天十一点上床睡觉，决不熬夜，只有晚上睡好了早晨才有精神去学习，去做其他事情。这个月，再也不能跟自己开玩笑了。总结下最近应该准备的东西吧1.英语六级，每天背10-15个单词2.物理化学，结构化学复习，先把期中考试撑过了再说吧。3.每天一篇算法题目(期中考试前可酌情减少)4.订阅的专栏每天阅读两到三篇文章，有问题多跟小伙伴去讨论5.知乎上多跟别人互动交流，诶多自己不主动怎么会有更多的朋友呢emmmm，如果可以每个星期摸出一篇高质量的回答吧！争取把点赞数和关注数都上去吧，多跟别人到想法下面去互动吧！6.Linux入门吧，再不入门说不过去了。7.继续算法的学习，这个每天不能丢。8.运动也不能停，但是可视情况减少相应的跑步次数来去学习。 嗯，就写这么多吧，现在好像也总算养成了写博客写日记的习惯了，希望再过一年两年的自己再回过头来看不会后悔吧！加油啊]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五一假期的一点感想]]></title>
    <url>%2F2019%2F05%2F02%2F20190502%2F</url>
    <content type="text"><![CDATA[五一假期的一点感想阿拉阿拉，这个学期最舒服的一个月快要走到尽头了呢，从四月份的清明假一直到现在的劳动节假期，整整一个月的时间，每天逃课每天玩手机，每天想干嘛就干嘛，现在再让我回想起去年天天满课的时光，我都不知道我是怎么度过来的emmmmm 这个月主要有两个烦人的事情，第一个就是期中考试吧，虽说已经知道结构期中考试可能不算成绩吧，但是这也不是我逃避它的借口，嗯要花时间去重新学起来，还有一个就是物化了，物化期中考试老师都很认真，所以我也要去认真的去准备它，起码不能挂科吧，额，所以最近要开始找回上学期的那种状态咯诶多我想想啊，从5号到10号这六天时间要复习预习准备考试，怎么想都够呛，额，为了准备它我还额外到网上买了学习指导和习题解答，这尼玛还不及格那就真的是自己的问题了，好好加油吧。 还有一个烦的就是体测了，虽说上个星期刚测完一千米，但是下个星期还要去测引体向上，我我我没臂力真的一个也做不来啊qaq，诶多，期末还要考颠球什么的，要是体育也挂科了那多丢人qaq 嗯，嗯因为长假的缘故我又到学校外面订了两个晚上的酒店准备放松下自我，准备去试试新买的小裙子什么的，诶多说实话我还从来都没试过呢xd，嗯我喜欢安静的环境，想和别人打游戏语音也不会吵到别人，也不会有傻逼室友来吵我烦我，所以说对于我来说，我适合独居生活而不是群居！ 哼唧，如果以后能跟喜欢的人一起合居就好了qaq，嘛，既然已经知道自己放假不可能好好学习了，那还不如玩的爽一点呢，诶多，就写这么多吧，以后估计要经常写日记了hhh]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-206]]></title>
    <url>%2F2019%2F04%2F29%2FLeetcode-206%2F</url>
    <content type="text"><![CDATA[206. 反转链表难度:easy反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 自己的解法：思路:至少需要三个结点p1,p2,p3来完成链表的逆序首先从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点、第三个节点。实现链表逆序的完整步骤如下：1.以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。2.三个临时节点引用p1，p2，p3分别向后移动一格位置。3.重复第1步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。4.重复第2步的工作，三个临时节点引用p1，p2，p3分别向后移动一格位置。5.继续像这样子迭代下去，一直到p2是空为止。6.最后，把head节点的next指向空，成为逆序链表的尾节点。并且把p1赋值给head，让p1所在的节点成为逆序链表的头节点。 实现代码如下:方法1：迭代1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) &#123; return head;//当头结点为空，或者它的下一个结点为空的话，返回head &#125; ListNode *p1,*p2,*p3;//声明三个中间变量来交换 p1 = head; p2 = head-&gt;next; p3 = NULL; while(p2 != NULL) &#123; p3 = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p3; &#125; head-&gt;next = NULL; head = p1; return head; &#125; &#125;; 方法2: 递归递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø 若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。 n1 → … → nk-1 → nk → nk+1 ← … ← nm 我们希望 nk+1 的下一个节点指向 nk。 所以，nk.next.next = nk; 要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。 实现代码如下:1234567public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p;&#125; 复杂度分析 时间复杂度：O(n)。假设n是列表的长度，那么时间复杂度为O(n)。 空间复杂度：O(n)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到n层。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九周小结]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第九周小结不知不觉，一个星期又过去了，好像还是老样子，还是那么喜欢摸鱼，还是那么喜欢混，可能是上几个学期的努力过头了吧，这个学期实在是太轻松了，人就是这样，有的时候没有外部的压力可能就不逼自己，道理谁都懂，可谁都喜欢去犯懒，谁都喜欢去打游戏，看剧之类的，学习的过程是枯燥的，在这个漫长的过程中学习所能得到的正反馈太少了，所以本来从17年高考结束开始就决定学编程，到现在19年快两年了感觉根本没什么长进，我自己都觉得自己是个傻逼。 方向不对，再多努力也是白费，前几天看扬叔写的小说真的是触目惊心，王奋斗不努力吗？并不是他不努力，只是他一步又一步的犯错，本来人试错的成本就已经很高了，更何况还一而再再而三的试错？ 没错，王奋斗的经历确实有点夸张，但正是因为这种夸张作者才想要深切的告诉我们，天坑专业不是一般人能读的啊，不管是学术界还是工业界，不管是去当导师廉价的劳动力还是去化工厂做危险的工作，我觉得都是不可接受的，所以更加坚定了我脱坑搞CS的决心 可怜我那几个室友，现在天天去实验室搬砖像个傻子一样，一点觉悟都没有，等过几年再看看他们是什么处境吧 顺手记录下这个星期所发生的大事吧星期一没上物化课，在宿舍摸了一整天，勉强完成了当天的任务 星期二上了体育课，把假条也给了老师看了，重新去踢了足球比赛但是是真的累啊，不知道为什么每天晚上运动了那么久，结果去比赛还是累的要死。但是下个星期二要测一千米啊啊啊啊，说实话挺烦的。 星期三上午去自习的效率还行，可能这是唯一让我感到满意的一天了吧，晚上去公园茂玩了一晚上，也挺开心的吧，虽然公园茂那里的小吃并不让我特别感兴趣 星期四一天没课，下午我又没去自习，本来是早就要跟基友一起去自习的，但是却都不互相监督，真的是无语呢，所以啊挺想找个跟我一样的人一起去考研一起去学习，甚至能一起恋爱呢(~大雾~) 星期五这一天可真的太无语了，早晨睡了一早晨不说，下午第一次准备去逃马原课，第一次去逃老师就点名，还是基友和我室友一起帮忙说我请假了才搞定的这事，现在想想就心有余悸，如果当时我一开始就冲过去就好了，真的是不幸中的万幸了晚上去找到了我五一订的酒店的位置，看起来还不错吧，物超所值，差不多是花了上回出去住一晚上的价钱住了两个晚上，期待出去住呢还去丹尼斯购物了一波，说实话有点小失望吧，其实大超市也没什么东西好买的，就买了两盒饼干和一点小零食，唯一让我开心的就是里面有卖仲景香菇酱的吧，以后可以不用到网上买了嘻嘻，然后又去公园茂转了一圈，转了半天都不知道吃什么，最后结果去吃了渔粉，说实话不是很好吃，而且也不值这个价55555555，最后是出去花了一百多真的是败家啊，以后要开始省钱了呢星期六一天啥也没做，又浪了一整天，晚上还花了40点了汉堡王的外卖，而且因为天气的原因这一个星期都没跑步，我真的是太草了今天星期天，上午摸过去，下去去自习室吧，晚上签个到去跑步然后就结束这一个星期吧 诶多这个星期买了小裙子订了酒店还有各种乱七八糟的居然花了1k了，这么抠门的我居然能花这么多，其实是心痛死了啊啊啊啊啊啊啊啊，如果不是上个月发现了闲鱼上可以赚点小钱现在我岂不是更穷5555555555555，而且最近闲鱼上买东西的越来越少了，我应该要想点办法去卖更多的东西了，诶多争取以后一个月起码有2K才行？ 所以继续明确一下下个星期的目标和每天的任务吧，不多也不少，但是每天要坚持完成，没完成就给自己惩罚！每天的任务:1.开始准备6级考试，每天十五个英语单词，期中考试过后每天还要两篇阅读理解2.张宇1000题每天五题3.洛谷OJ or Leetcode 每天一题4.程序员小灰 or 极客时间 每天一章5.微信小程序(这个比赛我将信将疑了，因为感觉学JavaScript和那个好费劲，但毕竟是我提出的计划，嘛有时间就去看看吧)6.王道数据结构开始看，题目也开始做吧7.准备期中考试，物化重点复习，结构次重点复习。(五一看看能不能复习一哈子，然后5.11之前复习完) 好了，总结和感悟就这么多吧，以后争取至少每个星期写篇日记吧，还要把刷过的每一道题都放到博客上来，嗯，过几天再把评论区和其他东西完善一下，如果可以的话再搞个域名就更好了，那么Azure加油吧！你现在不是一个人在战斗呢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷Oj-P1101]]></title>
    <url>%2F2019%2F04%2F24%2FluoguOj-P1101%2F</url>
    <content type="text"><![CDATA[洛谷OJ-P1101P1101 单词方阵题目描述给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：12345678910输入： 8 输出： qyizhong *yizhong gydthkjy gy****** nwidghji n*i***** orbzsfgz o**z**** hhgrhwth h***h*** zzzzzozo z****o** iwdfrgng i*****n* yyyygggg y******g 输入输出格式输入格式：第一行输入一个数n。(7≤n≤100)。 第二行开始输入n×n的字母矩阵。 输出格式： 突出显示单词的n×n矩阵。思路：1.用两个数组来表示八个方向const int dx_shift[10] = {1,1,0,-1,-1,-1,0,1};const int dy_shift[10] = {0,-1,-1,-1,0,1,1,1};2.在搜索到y之后沿着一个方向搜索izhong，直至不跳出边界为止，搜索完毕如果符合条件记录到另外一个数组中3.j是步长，这里的j正好对应了yizhong 的第j位 所以正好可以对应起来dx = x + j dx_shift[i];dy = y + j dy_shift[i]; 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//P1101 单词方阵int n;//n * n的矩阵//方向数组表示八个方向const int dx_shift[10] = &#123;1,1,0,-1,-1,-1,0,1&#125;;const int dy_shift[10] = &#123;0,-1,-1,-1,0,1,1,1&#125;;int dx,dy;const int maxn = 110;const string cmp = &quot;yizhong&quot;;char Map[maxn][maxn],result[maxn][maxn];void dfs(int x,int y)//x,y表示当前点的坐标&#123; for(int i = 0;i &lt; 8;i++)//枚举八个方向 &#123; int flag = 1; for(int j = 1;j &lt;= 6;j++)//对同一方向连续探索6次,直至全部符合izhong为止 &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; if(dx &lt; 1 || dx &gt; n || dy &lt; 1 || dy &gt; n)//若越界直接跳出循环,换一种方向继续尝试 &#123; flag = 0; break; &#125; if(Map[dx][dy] != cmp[j])//如果探索的第j位不符合也跳出循环进行下一次搜索 &#123; flag = 0; break; &#125; &#125; if(flag == 0) &#123; continue; &#125; else//符合条件记录到数组中 &#123; result[x][y] = &apos;y&apos;; for(int j = 1;j &lt;= 6;j++) &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; result[dx][dy] = Map[dx][dy]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;Map[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; result[i][j] = &apos;*&apos;; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; if(Map[i][j] == &apos;y&apos;)//如果搜索到y就进行搜索 &#123; dfs(i,j); &#125; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cout&lt;&lt;result[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八周小结]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一下这个星期发生的事情和心得吧星期二上午的体育课运气也太差了，从来都不点名的老师居然这次点名了555555555，害得我要去p一张请假条才行，星期三的早晨的效率挺高的，虽然逃了课。。。可是导员去查了前几个班的签到情况==，这尼玛谁顶得住啊，以后逃课要小心了、、、、今天看扬叔发的想法感觉好有道理 “学生上课的时候不听讲会被认为是违反课堂纪律，我如果觉得上课说话，那属于影响别人上课，但是我上课睡觉，看手机，只要我不发出声，那就不算违反课堂纪律”“你可以说是对老师的不尊重，但是学生是没得选的，如果双方都有平等的选择地位，我不喜欢我可以走，可以不来上课，但是我现在必须要来上课，你就不能以不尊重为理由批评我上课不听讲”“事实上，许多学生开始自己看公开课，看优质教材，用脚投票”是啊，因为劝退的原因我上课不能听讲，老师还经常要点我发言来误会我，有的时候想想也真的很气，不过他说的话真的深感认同 我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？这个星期又很好的摸了一个星期呢，反正每个星期天的豪言壮志，最后都会被自己的懒惰所无情的击败呢 可能是这学期的课过得实在是太轻松了吧，导致自己好像找不会上学期的那种状态了，甚至可以说在学编程方面连寒假的状态都不如了。 可是呢，人可能就是这样的一种动物啊，总喜欢为自己找借口，遇到什么事情都喜欢自我安慰，真的是太脆弱了呢，既然选择了这条艰苦的道路，那么就应该不后悔不放弃嘛，再苦再累又能如何呢？那些厉害的大佬可能这一辈子都追不上了，但是这就是自己可以不继续每天学习的理由吗？ 所以啊，已经过去了8个星期了，差不多两个月了，还有三个月，诶多，中间还要准备期中期末考试，啊真的是烦人，这学期的课我一点底都没有，跟物理相关的课程我就是白痴一个啊啊啊啊啊，反正再怎么样混了两年了，再混可能都毕不了业考不上研了，真是羡慕那些好好学习上课努力认真听讲，晚上回去天天打游戏，考试好好考就能搞个好绩点，然后保研爽一年什么的 哈哈哈哈哈，既然没有了这个选项那就不要天天幻想这啊那了，每天做好自己才是最重要的，所以啊，一定要坚持下去啊Azure，你不是为了你自己而活啊 下个星期的任务吧：1.每天一道算法题(leetcode / 洛谷OJ)2.这个星期一定要学会dfs和bfs算法！！！！！再拖我是狗3.继续学习JavaScript，完成微信小程序的比赛4.每天看一章程序员小灰关于算法的文章，不懂的一定要自己打出来才行！！！5.自己手打代码！自己手打代码！自己手打代码！重要的事情说三遍！6.王道数据结构继续阅读7.张宇数学1000题每天写至少5题！！！8.不要再说什么时间多了，要做的事情一堆呢！9.预习物理化学的内容，把期中考试先过了再说]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>记录自己的心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫评《ようこそ実力至上主義の教室へ》]]></title>
    <url>%2F2019%2F04%2F14%2F20190414%2F</url>
    <content type="text"><![CDATA[很遗憾前年7月的番昨天才被我偶然所发现，然后花了一天不到的时间就补完了，动画里面看到堀北就想起了雪乃，看到路哥就想起了大老师，然而看下来才知道这部番跟春物完全不同，春物是以校园恋爱为主题描述一群正常高中生的生活，而实教是以校园为背景展开一场斗智斗勇的作品，前者偏重于青春的描写，后者偏重于对人性的刻画 大老师和路哥(二老师)也是表面看上去差不多但其实完全不同的两个人，路哥心黑大老师心白。 路哥：我不是，我没有大老师：我也不是谦虚，这锅我背了。 大老师花式自爆收获后宫，而路哥则是个性冷淡，这也不难理解，动画最后一集本以为路哥会在铃音最虚弱的时候闪亮登场，击败坏人，获得美人芳心，迎娶白富美自此走上人生巅峰。然而路哥却开启王之蔑视，他把除了他之外所有人都当成了他赢得胜利的棋子，他根本不相信任何人，动画也随之戛然而止，还有很多东西都没讲清楚，过了两年也没出第二季也让人感觉深感遗憾。这也不难理解，因为从小说喵了个咪只有男主没有女主，动画还是强行魔改小说把铃音当做女主来写，之后几卷就没有铃音的戏份了，所以第二季很难做出来(脑瘫作者就不能跟这个作品好好写个女主吗) 之所以很喜欢这部番，感觉它把学校同学关系的那种真实感描写了出来，你所能看到的只是一个人的表面，很多人其实都是表里不一的，更不用说那些伪善的人了，每个人都喜欢隐藏自己的真实的一面，表里如一的堀北和人格分裂的桔梗就形成了鲜明的对比，路哥也是，表面上一副面瘫脸人畜无害的模样，实际上他把每个人都当做棋子，只要最终赢得胜利的人是他就行了。 引用逼乎上的评价，“有实力者不滥用实力，无实力者也能生存的反实力至上主义教室”嗯我觉得也是对这番最贴切的描述了 同时顺便期待下今年春物的第三季吧，嗯，希望能遇到更多这样有意思的动画。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>漫评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份不再摸鱼]]></title>
    <url>%2F2019%2F04%2F07%2Fdailylife%2F</url>
    <content type="text"><![CDATA[#4月份再摸鱼我是狗&gt;#懒真的是一种病，更可况还是懒癌晚期的我(划掉)，我的博客好像一个月前就弄好了吧，结果现在才想起来要写第一篇日志hhh无药可救了喵。 哼唧，重新看了看自己上个月立下的一个个flag，再摸鱼可能都毕不了业了呢，所以啊，azure从下个星期开始就要好好努力咯，虽然在学校没什么可以一起交流的人，室友也只会天天打游戏，像个傻子一样学化学，放假了还要跟导师免费搬砖，沦为廉价的劳动力还一副理所当然的样子，哼唧，我可不能变成这样呢，答应过别人不做一个普通人(真的是很奇怪的要求呢) 所以我再这么摸鱼下去就是混吃等死了，认识很多大佬每天都那么努力，再看看自己真的是，无话可说，有的时候不逼到最后一刻自己就不会醒悟的 既然选择了劝退这一道路就应该每天都一直努力嘛，其实可以做的事情真的是挺多的，但有的时候要学的东西太多了自己反而麻木了，诚然，在学习的道路上给自己的正反馈的确不多，但是这也不是自己能够为了逃避而找到了合理的借口x，所以我跟我基友一起商量不能再这么下去了，以后要计划好每天，每周以及每个月应该做到的计划，做到与没做到都要有奖励和惩罚才行。 每次自己做完的题解会发布到自己博客上，不管怎么样自己打出来的东西有一个记录也是极好的 下一周的计划:1.每天一道leetcode或者洛谷的题目(周三除外)(不能丢掉算法这方面的内容啊)2.这个星期学会dp算法和dfs&amp;bfs算法(dp摸了这么久了结果还没弄完我也是醉了)3.学习JavaScript相关知识，为微信小程序比赛做准备！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
</search>
