<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AcWing1296-NumberTheory-Dfs]]></title>
    <url>%2F2020%2F03%2F27%2FAcWing1296-NumberTheory-Dfs%2F</url>
    <content type="text"><![CDATA[一个与约数相关的数论问题 - AcWing1296.聪明的燕姿 第三十三天 题目 #输入输出 题意题目的大意就是给一个数S 让你找到有多少数能够满足它约数的和等于S 比如S = 42 这个时候就有3个数满足条件 41 = (1 + 41) == 4220 = (1 + 2 + 4 + 5 + 10 + 20) == 4226 = (1 + 2 + 13 + 26) == 42 分析思路算术基本定理N = P1^a1 * P2^a2 * … * Pn^an则N的约数个数为(a1+1)(a2+1)…(an+1) 假设N的一个约数为D D = P1^b1 * P2^b2 * … * Pn^bn其中bi可以取到0，范围是0&lt;= bi &lt;= ai 因为只有和N的质因数一一对应一定能得到约数因为bi可以从0取到ai,那么每一个bi就有(ai+1)种选法 约数的个数就是每个bi对应多少种选法相乘即约数个数就为(a1+1)(a2+1)…(an+1) 约数之和S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 这个怎么理解呢 因为每一个约数为D = P1^b1 * P2^b2 * … * Pn^bn 那么S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 这个公式的意思就是从每个括号里面取出来一个数然后相乘，就能得到一个约数Di然后所有的约数Di相加就得到约数之和S 举个例子对于S = 42来说，42对应的结果里面有一个为20，20 = (1 + 2 + 4 + 5 + 10 + 20)20 = 2^2*5对于两个质因数2和5来说2可以取0,1,2次，5可以取0,1次所以S = (1+2+2^2)(1+5) = 42 继续分析所以我们最暴力的想法一定就是枚举了，比如对一个数S枚举从1到S-1的所有数的约数，再判断他们的约数和是否等于S 但是这么做显然会超时，因为1 &lt;= S &lt;= 2*10^9 这个时候我们就可以观察我们的约数和的公式S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 假设这个时候有一个约数和S满足(1+2)(1+2+2^2)(1+2+2^2+…+2^k)3x5x9x17x33x65x129 = 635037975 就已经接近1e9的量级了，可见符合条件的项不会很多 那么这个时候我们就可以用dfs进行搜索，看我们能不能得到符合条件的(1+pk+pk^2+…+pk^ak)能够使得S能够整除，即S % (1+pk+pk^2+…+pk^ak) == 0然后S /= (1+pk+pk^2+…+pk^ak),再dfs到下一层 应该先从小到大枚举P1234for(p : 2,3,5,7,...) for(a : 1,2,3,...) if(S mod (1+p1+p1^2+...+p1^a1) == 0) dfs(下一层) 这个时候我们还需要继续思考特殊情况 如果ai = 1的话，S = (1+Pi)的时候，因为Pi为质数，那么S-1也一定为质数，那么这个时候只需要判断S-1是否为质数即可 又S只会有两种情况，就是一种情况包括一个因子里面有(1+Pi)，另一种情况不包括(1+Pi)S = (1+Pi)(1+Pj+Pj^2…..)S = (1+Pi+Pi^2)(1+…..) 但是这两种情况都可以看出来Pi ^2 &lt;= S所以我们dfs枚举Pi的上限就是$\sqrt{ S }$ 所以dfs应该设置成三个参数dfs(last,product,S) 1.last参数表示上一个枚举的质数是谁，我们这样枚举的目的就是先把前面符合条件的质数枚举完了再枚举后面的质数，这样不会带来重复，降低了时间复杂度 比如质数为P = 2,3,5,7…. 如果枚举2之后再dfs到下一层，那么这个时候就应该再从3开始进行枚举而不是再从头开始枚举 2.product参数product表示 S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)中 当前进行到哪一个括号里面的最高次项Pi^ai的乘积和比如S = (1+2+2^2)(1+3+3^2+3^3)(1+….)则dfs到第三层的时候product = 2^2*3^3 (product : 1 – &gt; 2^2 – &gt; 2^2*3^3) 又由算术基本定理可知一个数N = P1^a1 * P2^a2 * … * Pn^an product = P1^a1 * P2^a2*….. 如果product要从第一层(一开始product初始化为1)进到第二层，此时product(2) = product(1) * P1^a1S = S’ / (1+p1+p1^2+…+p1^a1) 然后再dfs(last,product(2),S) ==(等价于) dfs(last , product(1)*P1^a1 , S’/(1+p1+p1^2+…+p1^a1)) 3.S参数从上面的分析可知S参数就代表着从一开始的S除以(1+pk+pk^2+…+pk^ak)后剩余的乘积 所以每一层我们都应当判断S-1是否为质数，如果S-1是质数的话,也需要记录，但是不需要返回上一层继续往下搜即可就比如2424 = (1+23) = (1+2)(1+7) = (1+3)(1+5)第一层的时候判断23是质数，所以记录res[len++] = 1*23同时也需要继续往下做然后依次判断2、7 或者3、5能不能满足条件只要有S-1为质数，说明就有满足条件的数，这个时候就需要记录结果 为什么S-1一定要大于上一层的质数？因为我们要保证质数是从小到大枚举的，只有剩下的S-1是大于上一层的质数的时候，(1+S)才有可能成为最初的那个S的一个因子 因为我们要表示S’ = (1+ 2 + 2^2+…)(1 + 3 + 3^2 + …)…(1+S)越往后枚举对应的那个Pi也越大，所以S-1一定要大于上一层的质数才能满足条件 S == 1对应的是什么情况？S == 1对应的就是S’只由一个括号即只有一个P,S’ = (1+p+p^2+…+p^k)组成的情况比如 7 = (1 + 2 + 2^2) —–&gt;对应413 = (1 + 3 + 3^2) —–&gt;对应915 = (1 + 2 + 2^2 + 2^3) —–&gt;对应8这种情况表明，我从p = primes[i]开始枚举，一个p得到的序列和就把一开始的S’给整除了或者说这个序列和与S’相等，即此时的p得到的序列和(1+p+p^2+…+p^k) == S’ 所以此时S’ / (1+p+p^2+…) == 1dfs到下一层直接就是dfs(last,p^k,1)那么dfs到下一层S == 1的时候,product = p^k就是对应我们要找的那个数 注意点1.求质数的过程应该用线性筛的方法去做2.dfs(last,product,S)其中last应该初始化为-1这样我们在一开始判断S-1大于前面的质数的时候应该特判,S-1 &gt; ((last &lt; 0) ? 0 : primes[last])因为最小是(1+2)那么S起码是2,所以应该有S &gt; 1 即S-1 &gt; 0 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50000;//N = sqrt(2e9)bool st[N];int primes[N],cnt = 0;//线性筛int S,res[N],len;void get_primes(int n)&#123; for(int i = 2;i &lt;= n;i++) &#123; if(!st[i]) primes[cnt++] = i; for(int j = 0;primes[j]*i &lt;= n;j++) &#123; st[primes[j]*i] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125;int is_prime(int n)&#123; if(n &lt; N) return !st[n];//没有被筛过说明就是质数，返回true for(int i = 0;primes[i] &lt;= n / primes[i];i++) &#123; if(n % primes[i] == 0) return false; &#125; return true;&#125;void dfs(int last,int product,int S)//last表示上一个用的质数的下标是什么,product当前最高次项的结果,S表示每次处理后剩余多少&#123; if(S == 1) &#123; res[len++] = product; return ; &#125; //比如20 = 2^2 * 5 //N = P1^a1 * P2^a2 * ... * Pn^an //S = (1+p1+p1^2+...+p1^a1)(1+p2+p2^2+...+p2^a2)...(1+pn+pn^2+...+pn^an) //42 = (1 + 2 + 2^2)*(1 + 5),其中2^2和5就分别是最高次项p1^2*p2^1 if(S-1 &gt; ((last &lt; 0) ? 0 : primes[last]) &amp;&amp; is_prime(S-1)) &#123; res[len++] = product * (S-1); &#125; for(int i = last+1;primes[i] &lt;= S / primes[i];i++) &#123; int p = primes[i]; for(int j = 1+p,t = p;j &lt;= S;t *= p,j += t) &#123; if(S % j == 0) &#123; dfs(i,product*t,S/j); &#125; &#125; &#125;&#125;int main()&#123; get_primes(N-1); while(cin&gt;&gt;S) &#123; len = 0; dfs(-1,1,S); sort(res,res+len); cout &lt;&lt; len &lt;&lt; endl; if (len) &#123; sort(res, res + len); for (int i = 0; i &lt; len; i ++ ) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>NumberTheory</category>
        <category>dfs</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diver-dp]]></title>
    <url>%2F2020%2F03%2F25%2FDiver-dp%2F</url>
    <content type="text"><![CDATA[跟一般背包问题有区别的二维费用背包问题 - AcWing 1020.潜水员第三十二天！striving 题目 输入输出 分析如图所示，对于一般的题目来看，它似乎只是一个二维费用背包问题 但是这个题目的不同之处就在于它的要求是体积至少为j时候的最少费用 以一维费用举例的话1.体积最多为j,初始化f[N]全部初始为0，要保证体积V&gt;=0 2.体积恰好为j,只能初始化f[0] = 0，其余全部为正无穷，要保证体积V&gt;=0 3.体积至少为j,只能初始化f[0] = 0，其余全部为正无穷，不用保证体积V&gt;=0的情况 体积最多为j，那么体积不为0的情况也包含f[0] = 0的情况因为一个物品都不选的时候，总体积为多少都无所谓，那么此时f[N]全部为0 体积恰好为j，那么一个物品都不选的时候，体积只能为0，所以只有f[0] = 0合法，其余的情况都不合法根据题目情况设置成正无穷还是负无穷 体积至少为j，一个物品都不选的情况和体积恰好为j的情况一样，因为不选物品体积就只能为0 那为什么体积至少为j的时候就不用保证体积V&gt;=0呢？在这个题里面结合具体情况理解来看我觉得就是就算j &lt; V[i]的话，表示还需要的氧气或者氮气的体积j比现在提供的V[i]要少 但是提供的氧气或者氮气的体积多一点也不要紧啊，依然能满足潜水员的使用，所以没问题 但即使所需要的氧气或者氮气所需的是数量是负数，负数会越界 但其所需数量与0是等价的，因此可以通过所需数量为0来转移 当体积为0的时候就一定意味着每一个气缸都没有选，而气缸的重量都是大于0的 代码如下123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 22,M = 80,K = 1e4+10;int m,n,k;int f[N][M],O2[K],N2[K],W[K];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i &lt;= k;i++) &#123; scanf("%d%d%d",&amp;O2[i],&amp;N2[i],&amp;W[i]); &#125; memset(f,0x3f,sizeof f); f[0][0] = 0; for(int i = 1;i &lt;= k;i++) &#123; for(int j = n;j &gt;= 0;j--) &#123; for(int l = m;l &gt;= 0;l--) &#123; f[j][l] = min(f[j][l],f[max(0,j-O2[i])][max(0,l-N2[i])]+W[i]); &#125; &#125; &#125; printf("%d",f[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>dp</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheFactorChain-Of-X]]></title>
    <url>%2F2020%2F03%2F25%2FTheFactorChain-Of-X%2F</url>
    <content type="text"><![CDATA[数论相关知识一 - AcWing 1295.X的因子链第三十一天！一个多月了！ 题目 #输入输出 分析分析题意 1.最大长度如果想让X的因子组成的因子链最长，那么它的因子链一定得是质数才行，不然如果是合数的话就可以拆分成两个以上的和从而使它的长度增加 所以问最大长度就是问对X分解质因数后质因数的总和 2.最大长度序列对于X = 540 = 2^2 * 3^3 * 5来说序列的最大长度就是2 + 3 + 1 = 6最长长度就为 2 4 12 36 108 540x2 x2 x3 x3 x3 x5或者 2 6 12 36 108 540x2 x2 x2 x3 x3 x5…….等等 那么因为所有的2和所有的3都可以互换位置，那么我们就要去掉2和3他们可以互换位置的情况，即除以2!*3!从而只剩一种情况 最大长度的子序列个数就为(2+3+1)!/(2!*3!*1!) = 720/(2*6*1) = 60 3.分解质因数A.我们可以用线性筛的方法来分解质因数,st[N]数组表示有没有被筛的意思，如果没有被筛，表明当前这个数是质数，然后用这个数去筛掉其他合数 因为每个数只会被筛一次，所以时间复杂度为O(n) B.我们在筛质数的图中可以开一个minp数组，来记录对应的数X的最小质因数是谁 这样子可以方便我们对X分解质因数 X最小的质因数为p = minp[X],然后min[X / p]是另一个质因数，依次类推可以得到X的所有质因数 比如540 = 2^2*3^3*5 123456789101112131415161718void get_primes(int x)&#123; for(int i = 2;i &lt;= x;i++) &#123; if(!st[i]) &#123; minp[i] = i; primes[cnt++] = i; &#125; for(int j = 0;i*primes[j] &lt;= x;j++) &#123; int t = i*primes[j]; minp[t] = primes[j]; st[t] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125; 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;/*对于X = 540 = 2^2 * 3^3 * 5来说序列的最大长度就是2 + 3 + 1 = 6最长长度就为 2 4 12 36 108 540x2 x2 x3 x3 x3 x5或者 2 6 12 36 108 540 x2 x2 x2 x3 x3 x5等等那么因为所有的2和所有的3都可以互换位置，那么我们就要去掉2和3他们可以互换位置的情况，即除以2!*3!只剩一种情况最大长度的子序列个数就为(2+3+1)!/(2!*3!*1!) = 720/(2*6*1) = 60*/typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int primes[N],minp[N],X;bool st[N];int cnt = 0;void get_primes(int x)&#123; for(int i = 2;i &lt;= x;i++) &#123; if(!st[i]) &#123; minp[i] = i; primes[cnt++] = i; &#125; for(int j = 0;i*primes[j] &lt;= x;j++) &#123; int t = i*primes[j]; minp[t] = primes[j]; st[t] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125;int main()&#123; get_primes(N-1); while(scanf("%d",&amp;X) != -1) &#123; int k = 0,tot = 0; int count[N]; while(X &gt; 1) &#123; int t = minp[X]; fac[k] = t,count[k] = 0; while(X % t == 0) &#123; count[k]++; X /= t; tot++; &#125; k++; &#125; LL res = 1; for(int i = 1;i &lt;= tot;i++) res *= i; for(int i = 0;i &lt; k;i++) &#123; for(int j = 1;j &lt;= count[i];j++) &#123; res /= j; &#125; &#125; printf("%d %d\n",tot,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Number-theory</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheMaxXOR]]></title>
    <url>%2F2020%2F03%2F24%2FTheMaxXOR%2F</url>
    <content type="text"><![CDATA[最大异或对(字典树)第三十天！ 题目 输入输出 分析思路暴力解法12345678int res = 0;for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; i;j++) &#123; res = max(res,a[i]^a[j]); &#125;&#125; 暴力解法的时间复杂度显然超时，所以我们需要对内层循环进行优化 那么内层循环的含义是什么？ 内层循环的含义就是从a[0]到a[i-1]这些中找到一个与a[i]异或最大的值 那么这个操作就可以用Trie树进行优化 1.因为要使异或对最大，把a[i],a[j]都转化成二进制数，那么我们从高位开始就要开始与a[i]不同 2.因为0&lt;=Ai&lt;2^31,那么从30位开始从高往低去存储Ai对应的二进制数，从而形成一个字典树 3.我们应该先存储再查询，因为如果先查询再存储的话，那么当根节点为0即字典树里面还什么都没有的情况就要特判，为了避免这种情况我们就先存储再查询 4.查询的时候因为要使得异或最大，所以如果要查询a[i]对应的最大异或值对应的a[j]，那么a[j]的二进制表示就要尽可能的与a[i]的不同，比如a[i]为(11101)那么a[j]最好就为(00010) 所以再查询字典树的时候，如果a[i]当前的二进制位为1，那么就往字典树的0方向走，如果二进制位为1，就往字典树的1方向走但是如果没有对应相反的方向的话，就只能从相同的方向去走了 在每次查询一开始就初始化res = 0,然后在循环中依次res*2+u或者res*2+!u因为我们字典树就是从高位开始存储的，所以这样做没问题 所以我们用O(n)的时间复杂度就解决了问题，这里运用的正是空间换时间的思想 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010,M = 31*N;int n;int a[N];int son[M][2],idx;void insert(int x)&#123; int p = 0; for(int i = 30;i &gt;= 0;i--) &#123; int t = x &gt;&gt; i &amp; 1; if(!son[p][t]) son[p][t] = ++idx; p = son[p][t]; &#125;&#125;int query(int x)&#123; int p = 0,res = 0; for(int i = 30;i &gt;= 0;i--) &#123; int t = x &gt;&gt; i &amp; 1; //如果从根节点开始和a[i]另一个方向走 if(son[p][!t]) &#123; p = son[p][!t]; res = res*2 + !t; &#125; else//如果没有另一个方向，就只有往这个方向走了 &#123; p = son[p][t]; res = res*2 + t; &#125; &#125; return res;&#125;int main()&#123; scanf("%d",&amp;n); int res = 0;//因为0异或任意值都是任意值，所以res可以设置成0 for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); for(int i = 0;i &lt; n;i++) &#123; insert(a[i]);//先插入再查询，避免了特判的情况 int t = query(a[i]); res = max(res,a[i]^t);//把每次的结果都与res取一个最大值，这样一重循环就能解决问题 &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>TrieTree</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TrieTree]]></title>
    <url>%2F2020%2F03%2F24%2FTrieTree%2F</url>
    <content type="text"><![CDATA[Trie字符串统计(字典树) 第二十九天！ Trie树Trie树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。 此外Trie树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。 它的Key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。 它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。 存储如图所示，对于很多字符串我们从根节点开始，把根节点设为0，然后对每个字符串依次从前往后存储到一课树中，到达字符串的末尾就用一个cnt[N]++数组打上一个标记，表示以这个字母结尾的字符串是有一个字符串的 查找从根节点开始走，与要寻找的单词开始匹配 1.如果找到的下一个结点不存在要寻找的单词，就返回false 2.如果要寻找的单词到结尾了没有cnt[N]数组的标记，表示Trie树里也没有要寻找的单词，返回false 题目 输入输出 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std; //trie树，字典树const int N = 100010;int son[N][26];//每一个结点最多只会连26条边，因为只有小写字母,且这个数组存放的是每一个字母对应的idx//且第一维存放的是父节点的idx，第二位存放的是子节点字母从a到z映射到0到25的值int cnt[N];//以当前这个点解结尾的单词有多少个int idx;//下标是0的点，既是根节点，又是空节点char str[N];void insert(char str[])&#123; int p = 0;//从根节点开始 for(int i = 0;str[i];i++)//字符串结尾是\0 &#123; int u = str[i] - 'a'; //如果p这个结点不存在u这个儿子 if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++;//循环完之后即为最后一个点，让这个点的cnt++，表示以这个点为结尾的多了一个&#125;int query(char str[])&#123; int p = 0; for(int i = 0; str[i];i++) &#123; int u = str[i] - 'a'; if(!son[p][u]) return 0;//如果要寻找的下一个结点不存在，返回false p = son[p][u]; &#125; return cnt[p];//返回出现了多少次&#125;int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; char op[2]; scanf("%s%s",&amp;op,&amp;str); if(op[0] == 'I') insert(str); else printf("%d\n",query(str)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>TrieTree</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum-match-of-bipartite-graph]]></title>
    <url>%2F2020%2F03%2F21%2FMaximum-match-of-bipartite-graph%2F</url>
    <content type="text"><![CDATA[二分图的最大匹配第二十八天,差不多四十多天才完成了接近一个月的量，深深感受到人的惰性是多么可怕 关于二分图的定义，可以看我上一章染色法判定二分图里面的相关知识，这里不再赘述 二分图最大匹配的思路如果所示，对于一个二分图来说，左右两边为两个集合，我们要求左右两边最多能匹配多少条边一开始A连F，匹配A-F 然后下一个点B连E，匹配B-E 下一个点C连F，但是这个时候F已经被A相连了这个时候就回过头来找F对应的A，看A还有没有其他能相连的点，然后发现A还和H相连 这个时候就让A匹配H，A-H，这个时候F就没人连，然后C就可以和F匹配了，即C-F 最后一个点D匹配G 所以最终所有能匹配的边即为A-H,B-E,C-F,D-G即最多匹配四个边 如何去实现这个过程？我们可以用邻接矩阵去连接从左集合到右集合的边 然后用一个match[i]来记录右边集合已经匹配的是左边集合中的哪个点这样我们遇到矛盾的时候就可以快速找到右边集合对应匹配的左边集合的那个点 然后看左边集合的那个点时候还可以找到除了当前匹配这个点的另外的点 如果能找到，那么就皆大欢喜返回true，如果不能，就返回false 注意点1.最后我们从左边的每一个点开始寻找右边有没有能点能匹配的时候要加一个判重数组st[N]st数组用来防止重复搜索相同的点。而且当图中有环的时候，不加st数组可能会无限循环下去，就出现段错误了 且st数组每次搜索前都需要重置成false，因为匹配结果记录在match数组中，st数组用来判重，避免在某次匹配中重复遍历点和边。2.我们只用加从左边集合到右边集合的一条边即可，因为我们用match数组记录右边数组已经匹配的点，然后就可以直接find(match[j])判断是否成立 题目 输入输出 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 510,M = 1e5+10;//因为只用加一个边，所以M不用翻倍int h[N],e[M],ne[M],idx;bool vis[N];int match[N];int n1,n2,m;void add(int a,int b)&#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125;bool find(int x)//判断x能否与二分图另一个连通块的点连上边&#123; for(int i = h[x];i != -1;i = ne[i]) &#123; int j = e[i]; if(!vis[j]) &#123; vis[j] = true; //如果j还没有已经匹配的对象的话 if(match[j] == 0 || find(match[j]))//因为已经使vis[j]等于true了， &#123; //所以在find已经match好了的t = match[j]的时候就不会再重复匹配j，而是去找下一个能够匹配的点 match[j] = x; return true;//如果能够匹配，返回true表示x已经找到匹配的对象 &#125; &#125; &#125; return false;//否则返回false表示匹配不成功&#125;int main()&#123; scanf("%d%d%d",&amp;n1,&amp;n2,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); add(a,b);//添加a到b的一条边，因为我们的操作只需要从a找到b，就算是遇到已经匹配好的情况 //也是从已经match好了的b对应的match[b]重新去寻找除了b能够匹配的点，所以这里只需要add一条边 &#125; int res = 0; for(int i = 1;i &lt;=n1;i++)//我们只需要从左边的二分图开始进行匹配即可 &#123; memset(vis,0,sizeof vis);//匹配结果记录在match中，vis数组用来判重，避免在某次匹配中重复遍历点和边。 if(find(i)) res++; &#125; printf("%d",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>bipartite-graph</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bipartite-graph]]></title>
    <url>%2F2020%2F03%2F21%2Fbipartite-graph%2F</url>
    <content type="text"><![CDATA[染色法判定二分图 第二十七天，一个多月了，才发现坚持一件事是多么困难 染色法判定二分图什么是二分图 简而言之就是两个子集的内部的点没有边相连边只在两个子集之间连接 二分图的一个重要性质二分图当且仅当图中不含奇数环 因为如果存在奇数环(环当中点的数量为奇数)，从起点开始，起点属于左边的集合A那么下一个点就属于右边的集合B，下一个点的下一个点就属于左边的集合A 依次类推，可以推回起点是属于右边的集合，这与一开始起点属于左边的集合矛盾了 所以如果一个图是二分图，它肯定不存在奇数环 判断一个图是不是二分图从一个点开始，把它染色成1，把它相邻的点都染成2，把相邻的点的下一个相邻点染成1，然后依次类推 所以在染的过程中如果出现了矛盾，那么就不是一个二分图即一条边的两个点颜色不能相同 判断矛盾的条件1.染当前这个点，判断他相邻的点颜色如果和他相同的话，矛盾如果没出现矛盾的话，说明这个图是二分图 题目 输入输出 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5+10,M = 2e5+10;int h[N],e[M],ne[M],idx;//因为要加a到b和b到a的边，所以e,ne的大小要翻倍int n,m;int color[N];void add(int a,int b)&#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++;&#125;bool dfs(int u,int c)&#123; //没有被染色，先把u这个点染成c这个颜色 color[u] = c; //遍历u这个结点连接的结点，依次染成不同的颜色 for(int i = h[u];~i;i = ne[i]) &#123; int j = e[i]; //还没有被染过色的话 if(color[j] == 0) &#123; //就把当前结点染成3-c，这样做的好处是我们一开始把u染成1 //然后相邻的被染成3-1 = 2，染成2之后再进入dfs中c = 2，则相邻结点染成3-2 = 1 //如果相邻结点继续染色后返回为false产生矛盾的话说明当前的图不为二分图，返回false if(!dfs(j,3-c)) return false; &#125; //如果染过色的话就判断这个结点和相邻的结点颜色是否相同，如果相同返回false else if(color[j] == c) return false; &#125; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); add(a,b),add(b,a); &#125; int flag = 1; //因为二分图不一定是连通的，所以要从每个点开始判断 for(int i = 1;i &lt;= n;i++) &#123; if(color[i] == 0 &amp;&amp; !dfs(i,1)) &#123; flag = 0; break; &#125; &#125; if(flag) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>bipartite-graph</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recordingtime]]></title>
    <url>%2F2020%2F03%2F17%2Frecordingtime%2F</url>
    <content type="text"><![CDATA[记录自己的每一天,总结与反思 从今天开始记录自己每天干了些什么，完成多少任务，应该怎么去改进与反思 第三周3.31 汤家凤 1800题 英语单词 英语阅读 codeforces div3 算法提高班 洛谷dfs AC saber 贪吃蛇项目！ 操作系统 整理博客 线性代数 数据结构 完成以上任务至少70% 3.301. 汤家凤 2. 1800题 3. 英语单词 4. 英语阅读 5. codeforces div3 6. 算法提高班 7. 洛谷dfs 8. AC saber 9. 贪吃蛇项目！ 10. 操作系统 刷数学题不看手机晚上十二点前睡觉！用电脑尽量少干不相关的事情，争取每天九点前做好每一件事，九点后自己想干嘛干嘛尽量少看东方财富！！！ 总结今天状态很不多，明天继续保持！ 第二周3.281. AC saber 复习 2. PAT每日一题 3. 汤家凤数学 4. 1800题继续做 5. 英语单词 6. 英语阅读 7. 贪吃蛇项目继续开始 8. 数据结构 9. 算法提高课 10. 蓝桥杯真题继续刷 从明天开始尝试不设番茄钟进行学习同时，争取一天不看手机！ 3.25早晨 1. 汤家凤数学（8：00-10：00） 2. 数学1800题（ 10：10-11：30） 3. 英语单词（11:30-12:00) 中午 1. 睡觉（12：50-13：20） 2. 英语单词（13：20-13 : 50） 下午 1. 复习并查集（14：00-14：30） 2. 总结Acwing潜水员到博客中 3. 算法提高课dp（14：30 - 15：30） 4. 蓝桥杯数论继续学习并总结（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 继续完成贪吃蛇项目 （19 ：30 - 21 ：00） 十点之后的时间自行安排继续加油！今天完成任务的一半差不多，效率很低很低，明天开始对自己设置惩罚如果没完成80%任务！ 3.24早晨 1. 英语单词（7：30-8：00） 2. 汤家凤数学（8：00-10：00） 3. 数学1800题（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习快排与归并排序（14：00-14：30） 2. 算法提高课dp（14：30 - 15：30） 3. 蓝桥杯数论开始学习（15：30-17：30） 4. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 开始动手贪吃色项目（20：30 - 21：30） 十点之后的时间自行安排 总结今天的效率还行，能达到大约80%的感觉，但是在很多地方仍然需要继续更加专心才行，感觉番茄todo的每个番茄钟可以调到45分钟，适当的长一点对自己也有好处，起码不用再经常经常惦记着什么时候结束了，自己能够更加专注的去刷题今天开始了贪吃蛇项目，以后每天会分出一个半小时的时间去完成它！ 既然选择了开始，就要坚持下去。而且还要养成英文检索的习惯！加油 3.23早晨 1. 英语单词（7：30-8：00） 2. 汤家凤数学（8：00-10：00） 3. 数学1800题（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习模拟散列表（14：00-14：30） 2. 复习堆排序（14：30 - 14：50） 3. 复习字典树、最大异或对（14：50-15：30） 4. 蓝桥杯数论开始学习（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 开始动手贪吃色项目（20：30 - 21：30） 十点之后的时间自行安排明天加油啦，已经有小朋友比你还努力了，你还有什么不努力的理由呢？ 第一周3.21的任务安排周末的两天要加油啊！！！！早晨 1. 英语单词（7：30-8：00） 2. 数学1800题 （8：00-10：00） 3. 算法提高课dp（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习染色法判定二分图（14：00-14：30） 2. 复习匈牙利算法（14：30 - 14：50） 3. 复习字典树（14：50-15：30） 4. 蓝桥杯数论开始学习（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30 - 21：30） 十点之后的时间自行安排 3.20的任务安排早晨 1. 英语单词（7：30-8：00） 2. 数学汤家凤（8：00-10：00） 3. 数学1800题（10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习Prim算法（14：00-14：30） 2. 复习kruskal算法（14：30 - 14：50） 3. Floyd（14：50-15：30） 4. 蓝桥杯复习贪心最后两题以及数论开始学习（15：30-17：00） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30-21：30） 十点之后的时间自行安排 总结今天的效率依旧不尽如人意，还是因为早晨看股市的缘故导致自己喜欢分心，周末需要尝试一下自己不看股市真正专注的情况了下午还好，但是PAT还是没抽时间去做题，晚上也是因为想吃外卖等因素导致没有完成今天的任务，今天的完成度还是只有65%左右但是今天把要交的作业都弄到手了，明天抽时间做完，明天多抽时间在做算法题上了 3.19的任务安排早晨 1. 英语单词（7：30-8：00） 2. 数学汤家凤（8：00-10：00） 3. 数学1800题（10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习八数码问题（14：00-14：30） 2. 八皇后（14：30 - 14：50） 3. dijkstra和SPFA（14：50-15：30） 4. 蓝桥杯复习贪心专题（15：30-17：00） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30-21：30） 十点之后的时间自行安排 总结今天的学习效率还是不尽如人意，效率只有60%不到的样子，原因还是因为炒股看东方财富、以及困觉的原因，明天一定要避免这种情况发生！！！早晨多抽出时间来写1800题，下午多写写题目，今天PAT和英语阅读都没做，明天花时间补上一篇！明天一定要坚持试一试效率看能不能到90% 3.18的任务安排早晨1.英语单词 7:30-8:002.数学网课 4章 8:00-10:003.1800题 10:10-11:30 中午1.英语单词 11:30 - 12:00(or 12:00-12:30)2.睡觉 12:50 - 13:30 下午14:00-17:301.复习字符串哈希2.继续学习双指针BFS图论3.开始刷蓝桥杯的题目4.PAT每日一题 晚上1.英语阅读 18:30 - 19:302.数据结构 19:45 - 20:303.操作系统 20:30 - 21:30洗澡半个小时22：00以后自己安排时间 总结今天基本上完成了80％的任务，除了操作系统和蓝桥杯的题目没有刷之外基本上都还可以，数学刷题的速度需要加快但是由于早晨和下午看股市导致自己无法专心到学习中来，以后要从股市中脱身出来专心考研学习！！！]]></content>
      <categories>
        <category>recording</category>
      </categories>
      <tags>
        <tag>记录自己的每一天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-1215]]></title>
    <url>%2F2020%2F03%2F15%2FAcWing-1215%2F</url>
    <content type="text"><![CDATA[一道树状数组与逆序对思想结合的题目 第二十六天。心碎 题目 输入输出 分析思路由样例可以分析得到，这道题就相当于一个冒泡排序，每次交换相邻两个人 每次从前往后去扫，如果前面比后面大就交换 但是这其中的思想就是一种逆序对的思想 因为冒泡排序每排序一次，逆序对的数量就减1 所以冒泡排序交换的次数就是逆序对的数量 所以针对一个小朋友来说 如果前面有K1个小朋友比它高，那么必然会交换K1次到这个小朋友的后面 同理如果后面有K2个小朋友比它高，那么必然会交换K2次到这个小朋友的前面 所以交换的次数就是K1+K2次 于是我们可以用一个树状数组来进行存储，树状数组的大小为题目中最大的数值 以数值来进行存储 查询一下大于这个数的数有多少个，然后加到sum[i]中 然后把这个数加入到树状数组中 同理查询一下小于这个数的数有多少个，然后加到sum[i]中 然后把这个数加入到树状数组中 最后sum[i]中存储的就是每个数左右两边对应的k1+k2然后用等差数列求和公式sum[i]*(sum[i]+1)/2 因为最坏情况下可能要交换10^5次，那么10^5*(10^5+1)/2 = 5*10^9，但是int的范围大约在2*10^9，所以最后的结果可能会爆int，所以要在乘积里面就转换成long long res += 1LL*sum[i]*(sum[i]+1)/2 注意点1.因为从前往后循环的过程中把每个身高的人数记下来了，所以可以查询小于当前身高的人数。后半部分同理，所以要从后往前循环！2.第二次从后往前求的时候记得要把树状数组清零再求 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//树状数组的写法const int N = 1000010;typedef long long LL;int a[N],C[N],sum[N];//树状数组维护的是每个身高的人数int n;int lowbit(int x)&#123; return x &amp; -x;&#125;int add(int x)&#123; for(int i = x;i &lt; N;i+= lowbit(i)) C[i]++;//人数加1&#125;int query(int x)&#123; int res = 0; for(int i = x;i &gt;= 1;i -= lowbit(i)) res += C[i]; return res;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); LL res = 0; //求每个数前面有多少个比它大，对于a[i]来说，求a[i]+1到N里面有多少个数就是比它大的数 for(int i = 1;i &lt;= n;i++) &#123; sum[i] = query(N-1) - query(a[i]);//数组的最大的下标为N-1 add(a[i]); &#125; //把树状数组清零，再从后往前 memset(C,0,sizeof C); //求每个数前面有多少个比它小，对于a[i]来说，就是求从1到a[i]-1有多少个数比它要小 for(int i = n;i &gt;= 1;i--) &#123; sum[i] += query(a[i]-1); add(a[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; res += 1LL*sum[i]*(sum[i]+1)/2; &#125; printf("%lld",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2392-dp]]></title>
    <url>%2F2020%2F03%2F08%2Fluogu-P2392-dp%2F</url>
    <content type="text"><![CDATA[P2392 kkksc03考前临时抱佛脚(可以转化成01背包的一个问题)第二十五天，坚持。 题目 输入输出 分析思路这一题的思路跟一开始见到的想法不一样 一开始我以为如果一共有三道题目，分别要4分钟、3分钟、2分钟 我以为写如果同时写4分钟的题和3分钟的题，必须4分钟的题写完了才能写下一道 但是根据样例来看并不是这样，比如4分钟内同时写4分钟的和3分钟的题，3分钟的题写完了的时候就可以直接写下一道题，那么就需要4 + (2 - (4 - 3)) = 5 因为可以有两个脑处理问题，如果把所有的时间平均成两半最好了，也就是两个脑所消耗的时间差为0最好，但显然不一定所有的数据都一定能满足两个脑能同时为t/2，所以我们要尽可能的保证两个脑子所消耗的时间差最小 既然不能保证同时为t/2，那么一定有一个脑子处理的时间小于t/2，另一个大于t/2 于是这题就可以转换成一个01背包问题，即在体积为t/2的情况下，能够把背包尽可能填满的最大值，这里价值也是时间，那么最后f[t/2]就是在t/2体积的情况下能够装满其中一个脑子的最多时间，那么另外一个脑子用的时间就是t - f[t/2]，最后取一个max，max(f[t/2],t - f[t/2])就是一科里面所用的最少的时间了 举一个例子10,8,7,3,2,1 合理的方案就是写10分钟和8分钟的，这时候t = 10 然后8分钟写完了，写那个7分钟的，t = 10 7分钟的写了2分钟还能5分钟写完 所以还剩5,3,2,1 这个时候写5分钟同时写3分钟的，t = 10 + 5 = 153分钟写完了同时再写2分钟的 则写完15分钟后还剩下1分钟的作业，最后t = 15 + 1 = 16 最后左脑10 + 3 + 2 + 1 = 16右脑8 + 7 = 15 所以就相当于把这么多的物品平均分到两个篮子里面使得两个篮子的物品总和相差最小，越平均越好 代码如下123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 610,M = 21;int f[N];int num[M];int s[4];int main()&#123; for(int i = 0;i &lt; 4;i++) scanf("%d",&amp;s[i]); int t = 0; for(int k = 0;k &lt; 4;k++) &#123; int sum = 0; for(int j = 1;j &lt;= s[k];j++) &#123; scanf("%d",&amp;num[j]); sum += num[j]; &#125; memset(f,0,sizeof f); //cout&lt;&lt;sum/2&lt;&lt;"----"&lt;&lt;endl; for(int i = 1;i &lt;= s[k];i++) &#123; for(int j = sum/2;j &gt;= num[i];j--) &#123; f[j] = max(f[j],f[j-num[i]]+num[i]);//转换为01背包问题的写法 &#125; &#125; //cout&lt;&lt;f[sum/2]&lt;&lt;endl; t += max(f[sum/2],sum-f[sum/2]); &#125; printf("%d",t); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1363-dp]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-1363-dp%2F</url>
    <content type="text"><![CDATA[一个关于背包问题具体方案的求解 第二十四天，继续整理一些比较典型的题目 题目 样例 分析思路 如图所示，可以把这个题转换为一个背包问题来求解，最后如果要求具体的方案，可以最后的状态一步一步向前转移来判断，用状态的转移最后求出具体的方案 因为f[n][0]表示从前n个物品，且总体积模3余0的最大价值，那么我们应该把digits[N]数组从小到大排序，因为我们最后是从后往前推导状态能否转移过来 所以可以从后往前，把较大的数放到后面来判断，如果状态能够转移就先选最大的数，然后依次判断状态能够转移继续选数，因为是从大到小枚举，所以能选则选 因为我们最后求得的f[n][0]表示的是价值最大的选法，就是可以选的数字最多是多少，然后再从最大的数字从后往前推状态的转移即可，如果可以转移就表示能选digits[i]就先选，然后再转移判断能不能继续选 注意点1.因为存在全是{“0”,”0”,”0”,”0”…..}这种情况，为了避免消除前导0，我们可以直接判断res途中是否为”0”，因为从大到小枚举，已经出现0了，那么后面接着的不可能比0大，所以直接返回”0” 2.f[0][1],f[0][2]都是不合法的状态要赋给一个很小的值才行 代码如下1234567891011121314151617181920212223242526272829303132class Solution &#123;public: const int N = 1e4+10; string largestMultipleOfThree(vector&lt;int&gt;&amp; digits) &#123; sort(digits.begin(),digits.end());//因为我们是从最后的状态来往前推，所以数组从小到大排序即可 int f[N][3],num[N]; memset(f,0,sizeof 0); int n = digits.size(); f[0][1] = f[0][2] = -1e8;//因为f[0][1],f[0][2]都是不合法的状态，没有数不可能模余1或2，所以要设置成一个很大的负数 for(int i = 1;i &lt;= n;i++) num[i] = digits[i-1]; for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt;= 2;j++) &#123; f[i][j] = max(f[i-1][j],f[i-1][(j + 3 - num[i] % 3 )%3]+1); &#125; string res = ""; if(f[n][0] &lt;= 0) return "";//如果f[n][0]小于等于0，表示没有数字符合情况，直接返回空字符串 for(int i = n,j = 0;i;i--) &#123; if(f[i][j] == f[i-1][(j + 3 - num[i] % 3 )%3]+1)//如果能转移到右边选第i个物品的情况 &#123; res += to_string(num[i]);//选第i个物品 j = (j + 3 - num[i] % 3 )%3;//继续转移状态 &#125; if(res == "0") return res;//因为存在全是&#123;"0","0","0","0".....&#125;这种情况， //为了避免消除前导0，我们可以直接判断res途中是否为"0"，因为从大到小枚举，已经出现0了，那么后面接着的不可能比0大，所以直接返回"0" &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>dp</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1368]]></title>
    <url>%2F2020%2F03%2F03%2FLeetCode-1368%2F</url>
    <content type="text"><![CDATA[一个典型的01BFS的题目(最短路) 第二十三天，开始整理除了模板题之外的其他题目传送门 题目 样例 分析思路这题从题意上分析可知可以抽象成从点(0,0)走到点(n-1,m-1)的路径中最少修改的次数，其也跟最短路有关(一般的最短路的问题是问最短距离，这个最少的修改次数也可以跟最短路相关) 如果最短路的边权全部都是1的话可以用BFS进行求解，但是因为这个图的权值是0和1都存在，如果走的方向相同当前格子就为0，否则就为1，这个时候就不能用简单的BFS进行求解，而是用01BFS进行求解 01BFS，就不是简单的用queue去存储而是用一个双端队列deque去存储，如果当前边权为0就加入到队头、如果是1就加入到队尾，这样可以保证队列里面的单调性，确保我们取出的队头一定是最小的 说白了01BFS就是一个特殊的dijkstra算法，只不过是把堆优化版的dijkstra中的优先队列改成双端队列而已，队头必然是最小值，而且因为是从起点开始拓展的，如果边权为0加入队头，如果为1就加入队尾，然后依次拓展，这样一定保证队列里面单调的，这样子我们每次取的队头一定是最小值且是从起点拓展的。 同理，既然是最短路算法可以解决这个问题，我们同样可以用堆优化的dijkstra和SPFA去解决问题，思路跟上述类似不再详述，具体的过程在下列代码中 注意点为什么不能用dp？因为这个图更新的时候有一种环形的依赖关系，状态的更新可能是有循环的，没有一个明显的拓扑序 代码如下(01BFS)1234567891011121314151617181920212223242526272829303132333435typedef pair&lt;int,int&gt; PII;int n = grid.size(),m = grid[0].size(); int d[n+1][m+1]; bool vis[n+1][m+1];//判断是否拓展过 memset(d,0x3f,sizeof d); memset(vis,0,sizeof vis); int dx[5] = &#123;0,0,0,1,-1&#125;,dy[5] = &#123;0,1,-1,0,0&#125;; deque&lt;PII&gt; q; d[0][0] = 0; q.push_front(&#123;0,0&#125;); while(q.size()) &#123; PII t = q.front(); q.pop_front(); if(vis[t.first][t.second]) continue; vis[t.first][t.second] = true; for(int k = 1;k &lt;= 4;k++) &#123; int x = t.first+dx[k],y = t.second+dy[k]; if(x &lt; 0||x &gt;= n||y &lt; 0|| y &gt;= m) continue; int w = grid[t.first][t.second] != k ? 1 : 0; if(d[x][y] &gt; d[t.first][t.second] + w) &#123; d[x][y] = d[t.first][t.second] + w; &#125; if(w) q.push_back(&#123;x,y&#125;); else q.push_front(&#123;x,y&#125;); &#125; &#125; return d[n-1][m-1]; 代码如下(SPFA)123456789101112131415161718192021222324252627282930313233343536typedef pair&lt;int,int&gt; PII; const int N = 110;int dx[5] = &#123;0,0,0,1,-1&#125;,dy[5] = &#123;0,1,-1,0,0&#125;; int n = grid.size(),m = grid[0].size(); int d[N][N]; bool vis[N][N] = &#123;false&#125;;//这个数组是判断点是否在队列中 memset(d,0x3f,sizeof d); d[0][0] = 0; queue&lt;PII&gt; q; q.push(&#123;0,0&#125;); vis[0][0] = true; while(q.size()) &#123; auto t = q.front(); q.pop(); int x = t.first,y = t.second; vis[x][y] = false; for(int i = 1;i &lt;= 4;i++) &#123; int newx = x + dx[i],newy = y + dy[i]; if(newx &lt; 0 || newx &gt;= n || newy &lt; 0|| newy &gt;= m) continue; int w = grid[x][y] == i ? 0 : 1; if(d[newx][newy] &gt; d[x][y] + w) &#123; d[newx][newy] = d[x][y] + w; if(!vis[newx][newy]) &#123; q.push(&#123;newx,newy&#125;); vis[newx][newy] = true; &#125; &#125; &#125; &#125; return d[n-1][m-1];]]></content>
      <categories>
        <category>Leetcode</category>
        <category>SPFA</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BellmanFord-and-SPFA]]></title>
    <url>%2F2020%2F02%2F29%2FBellmanFord-and-SPFA%2F</url>
    <content type="text"><![CDATA[BellmanFord和SPFA算法第二十二天。 Bellman-Ford算法题目 输入输出 分析思路dijkstra算法不能处理有负权边的情况Bellman-Ford算法适用于带负环的图，如果题目限制了最短路经过的边的个数，如上图的代码，那么有负环也无所谓了，因为限制k次导致我们不能无限的经过负环实现思路：1234for(循环n次) for(循环所有边a,b,w) dist[b] = min(dist[b],backup[a]+w)//其中所有边就可以直接用一个结构体数组来存储，不一定需要邻接表，只要能遍历到所有边就可以了 为什么用backup[N]数组来存放上一个的结果如图所示，如果题目要求k = 1，那么我们从1到3只能选择下面一条路径去求如果不用backup数组来存放上一个的话那么d[1] = 0d[2] = min(d[1]+1,d[2]) = 1此时再继续循环d[3]= min(d[2]+1,d[2]) = 2此时d[3]就是用上一个已经更新了的2来继续更新的此时则发生串联那么我们只调用上一个的backup数组d[1] = 0;backup[1] = 0,backup[2] = INF,backup[3] = INF;d[2] = min(d[2],backup[1]+1) = 1//1–2(1)d[3] = min(d[3],backup[2]+1) = INF//2–3(1)d[3] = min(d[3],backup[1]+3) = 3//1–3(3) 时间复杂度为O(nm) 注意点1.为什么是d[n] &gt; 0x3f3f3f3f/2？因为存在负权边，那么虽然n也是正无穷，但是经过负权边可能会把n的正无穷减小一点，但是也不会减太多，最多减500*10000，所以写成d[n] &gt; 0x3f3f3f3f/2即可判断2.memset函数是以字节为单位赋值的，每个int包含4个字节，所以memset完之后所有数会变成0x3f3f3f3f 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510,M = 10010;int n,m,k;int d[N],backup[N];struct Edge&#123; int a,b,w; &#125;edges[M];int bellman_ford(int s)&#123; memset(d,0x3f,sizeof d); d[s] = 0; for(int i = 0;i &lt; k;i++) &#123; memcpy(backup,d,sizeof d); for(int j = 0;j &lt; m;j++) &#123; int a = edges[j].a,b = edges[j].b,w = edges[j].w; d[b] = min(d[b],backup[a] + w); &#125; &#125; if(d[n] &gt; 0x3f3f3f3f/2) return -1; return d[n];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i = 0; for(int i = 0;i &lt; m;i++)&#123; int a,b,w; scanf("%d%d%d",&amp;a,&amp;b,&amp;w); edges[i] = &#123;a,b,w&#125;; &#125; int t = bellman_ford(1); if(t == -1) puts("impossible"); else printf("%d\n",t); return 0;&#125; SPFA算法题目 输入输出 分析思路SPFA算法是bellman-ford算法的优化在bellman-ford算法中，他要遍历所有边来进行更新，但是每一次迭代不一定每一条边都需要更新 dist[b] = min(dist[b],dist[a]+w) 那么SPFA可以对其进行优化dist[b]如果想变小的话，那么一定是dist[a]变小了如果dist[a]不变，那么dist[b]也一定不变 那么我们每次就可以用一个队列(堆、优先队列，但是一般来说用队列就可以了)进行存储，队里面就存放的就是所有变小的结点，只要队列里面不空，就取出队头t，更新t的所有出边，如果更新成功，就把b加入队列，如果队列里面已经有b了，就不用再存放进队列里面了 它的基本思路就是我更新过谁，我就再拿谁去更新别人，一个点如果没有被更新过，那么它就没有必要去更新别人，只有前面的点变小了，后面的点才会跟着变小 我的理解就是，它这个点变小了，他肯定会影响更多的点，所以就需要放入队列里面进行操作 注意点1.spfa只会更新所有能从起点走到的点，所以如果无解，那么起点就走不到终点，那么终点的距离就是0x3f3f3f3f 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int h[N],e[N],ne[N],d[N],w[N],idx;bool vis[N];//vis[i]是判断是否存入过队列中int n,m;void add(int a,int b,int c)&#123; e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int spfa(int s)&#123; queue&lt;int&gt;q; q.push(s); vis[s] = true;//存入队列，vis[s] = true d[s] = 0; while(!q.empty()) &#123; int t = q.front(); q.pop(); vis[t] = false;//从队列中取出就改为false for(int i = h[t];i != -1;i = ne[i]) &#123; int j = e[i]; if(d[j] &gt; d[t] + w[i]) &#123; d[j] = d[t] + w[i]; if(!vis[j]) &#123; q.push(j); vis[j] = true;//加入队列就改为true &#125; &#125; &#125; &#125; if(d[n] == 0x3f3f3f3f) return -1; return d[n]; &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h); memset(d,0x3f,sizeof d); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t = spfa(1); if(t == -1) puts("impossible"); else printf("%d",t); return 0;&#125; SPFA判断负环题目 输入输出 分析思路在SPFA算法中dist[x]表示从起点s到x的最短距离那么我们可以用一个cnt[N]数组来存放，表示边数12345dist[x] = dist[t] + w[i]cnt[x] = cnt[t] + 11----------t——x| |--------------- 因为上面表示从1到t再到x的路径比下面的要短那么从1到t再到x的边数就是从1到t的边数再+1即cnt[x] = cnt[t] + 1此时如果cnt[x]&gt;=n的话，意味着从1到x至少经过了n条边，经过了n条边如果没有环的话就意味着有n+1个点，但是我们题目只有n个点，说明最短路径中存在环，这个环一定是负权的，因为如果是正权的，那经过这个环路径会变大，那我肯定不会经过这个环所以SPFA算法可以用来判断是否有负环 注意点1.有负环的话相当于某些点到起点的距离为负无穷，然后SPFA算法是正确的，且初始时这些点的距离为0,0大于负无穷，所以一定会把这些距离为负无穷的点不断更新，所以不需要把d数组赋值为正无穷 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int h[N],e[N],ne[N],d[N],w[N],idx,cnt[N];bool vis[N];//vis[i]是判断是否存入过队列中int n,m;void add(int a,int b,int c)&#123; e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int spfa()&#123; queue&lt;int&gt;q; for(int i = 1;i &lt;= n;i++) &#123; vis[i] = true; q.push(i); &#125; while(!q.empty()) &#123; int t = q.front(); q.pop(); vis[t] = false; for(int i = h[t];i != -1;i = ne[i]) &#123; int j = e[i]; if(d[j] &gt; d[t] + w[i]) &#123; d[j] = d[t] + w[i]; cnt[j] = cnt[t] + 1; if(cnt[j] &gt;= n) return 1; if(!vis[j]) &#123; q.push(j); vis[j] = true; &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h); //memset(d,0x3f,sizeof d); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t = spfa(); if(t) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>BellmanFord</category>
        <category>SPFA</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OptimizationOfDijkstra-byheap]]></title>
    <url>%2F2020%2F02%2F28%2FOptimizationOfDijkstra-byheap%2F</url>
    <content type="text"><![CDATA[堆优化的djiksra二十一。 题目 输入输出 分析dijkstra算法是针对单元最短路的一个算法n为点的数量,m表示边的数量但是朴素的dijkstra算法的时间复杂度为O(n^2)堆优化的dijkstra算法时间复杂度为O(mlogn) 因为朴素的dijkstra算法时间复杂度最高的部分就是两重循环找到离t距离最近的点，那么在一堆数里面找最小的数就可以用堆来进行优化了，那么时间复杂度会变成O(mlogn)具体的分析思路和关键步骤看如下代码即可 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;typedef pair&lt;int,int&gt; PII;//维护距离的时候还需要知道结点编号，所以需要用一个pair来存储int h[N],e[N],w[N],ne[N],idx = 0,d[N];int n,m;bool vis[N] = &#123;false&#125;;void add(int a,int b,int c)//记住模板&#123; //e[i]存放的是从a指向b的结点 e[idx] = b; //w[i]存放的是a到b的边权 w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int dijikstra()&#123; fill(d+1,d+1+n,INT_MAX); d[1] = 0; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//用小根堆，使得堆最上面的元素最小 heap.push(&#123;0,1&#125;); while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int distance = t.first,ver = t.second; if(vis[ver]) continue; vis[ver] = true; //h[i]、w[i]中的i都是指的下标idx，求d[j]时候中的j是具体的点，所以j = e[i]取出对应被指向的那个点是谁 //ver是起点，i = h[ver]表示从起点能指向的下一个点，然后继续寻找，找到它能够到达的所有的点 for(int i = h[ver];i != -1;i = ne[i]) &#123; int j = e[i];//i = h[ver]为被指向那个的点对应的下标，然后e[i]就是存放被指向那个点是谁 if(distance + w[i] &lt; d[j])//w[i]指的是从起点指向下一个点对应的边权 &#123; //比如a指向b，那么w[b]就表示a到b的距离 //distance就表示从起点到ver的距离 d[j] = distance + w[i];//distance + w[i] &lt; d[j]表示从ver经过i这个点到j比直接到j的距离要短的话，就更新 heap.push(&#123;d[j],j&#125;);//并把更新后的距离和对应点的编号都插入到堆里面 &#125; &#125; &#125; if(d[n] == INT_MAX) return -1; return d[n]; &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h);//设置从起点指向最后一个点到-1结束，取边界 while(m--) &#123; int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); add(a,b,c);//用邻接表进行存储就不需要再对重边进行处理，因为它可以保证会选最短的边 &#125; printf("%d",dijikstra()); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200225]]></title>
    <url>%2F2020%2F02%2F25%2F20200225%2F</url>
    <content type="text"><![CDATA[记录下今天的感悟 算是一个新的系列吧其实挺想笑的，算了算从去年三月份拿钱给原来的好哥们帮我投资中信证券开始，到今天差不多算快一年了吧，一年的时间，心态还是没什么变化，学费倒是交了不少，不过可能也是投资路上的一条必经之路吧 今天的急跌确实是让我有点慌张了，但是哪次大跌我自己都不这样呢？所以保持一个平常心来看待挺重要的，一天两天的涨跌放到一个月几个月甚至半年来看真的不算什么，所以，投资是一个长期的过程，而且我当前自己的资金也有限，承受风险的能力也弱，所以当前最好只专注一个去做，不追涨只补跌，切记切记！ 今天让我最感慨的就是一直在做的欧菲光了，三个月前从17块多第一次买入就买到了最高点，然后一次一次降成本到了16块多，最后开年了割肉去追高医药股，自己亏了一千块，然后又买回欧菲光，最后到前几天实在是忍不住17块多卖了，然后就一直涨四天涨到了22 有时候就在想，很多事情为什么都这么巧呢？其实自己根本就没必要太在意一时的涨跌，专注于自己当前的优质的票其实就很好了，因为钱是赚不完的，不能吃着碗里的看着别人锅里的，切记切记，所以当前一定只做手里的TCL，别的票一律都不考虑！直到十块左右再考虑出吧 今天确实看到有人说了风险很高了，我也确实留了个心眼，因为现在科技股的估值确实都太高太高了，根本就不是价值投资了，说的好听就是趋势，说的不好听就是传花击鼓了，不知道什么时候自己就是最后一棒了，所以我估计最多还有半个月的行情，到时候就必须慢慢止盈出场了。切记！切记！ 那今天就先写这么多吧，以后有机会可以多写写自己每天的感悟和心态的]]></content>
      <categories>
        <category>DiaryOfInvestment</category>
      </categories>
      <tags>
        <tag>投资心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MatrixOfFastPower]]></title>
    <url>%2F2020%2F02%2F25%2FMatrixOfFastPower%2F</url>
    <content type="text"><![CDATA[矩阵快速幂第二十天。 题目 输入输出 分析思路 注意点1.在计算矩阵快速幂的时候可能会爆int，所以要用long long存储2.f[N] = f[1]*A^N-1 因为f[n] = {fn,fn+1,Sn}那么f[2]就对应Sn经过快速幂最后得到的Sn的值3.对于计算fn*A12345for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt; N; j ++ ) temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m; a代表1X3的矩阵，b代表3X3的矩阵 这两个矩阵相乘后得到1X3的矩阵，所以是a的每一行a[j]去乘以b的第i行的j个数从上往下 4.对于计算A*A1234567int temp[N][N] = &#123;0&#125;; for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt; N; j ++ ) for (int k = 0; k &lt; N; k ++ ) temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m; a和b都代表3X3的矩阵，那么最后相乘会得到3X3的矩阵 a[i][k]*b[k][j]表示a的每一行的第k个数乘以b的每一列的第k个数 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;int n,m;const int N = 3; //int f[N];int a[3][3] = &#123;&#123;0,1,0&#125;,&#123;1,1,1&#125;,&#123;0,0,1&#125;&#125;;void mul(int a[],int b[],int c[][N])&#123; int temp[N] = &#123;0&#125;; for(int i = 0;i &lt; N;i++) &#123; for(int j = 0;j &lt; N;j++) &#123; temp[i] = (temp[i]+(LL)b[j]*c[j][i]) % m; &#125; &#125; memcpy(a,temp,sizeof temp); &#125;void mul(int a[][N],int b[][N],int c[][N])&#123; int temp[N][N] = &#123;0&#125;; for(int i = 0;i &lt; N;i++) &#123; for(int j = 0;j &lt; N;j++) &#123; for(int k = 0;k &lt; N;k++) &#123; temp[i][j] = (temp[i][j] + (LL)b[i][k]*c[k][j])% m; &#125; &#125; &#125; memcpy(a,temp,sizeof temp); &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); n--; int f[N] = &#123;1,1,1&#125;; while(n) &#123; if(n &amp; 1) mul(f,f,a);//res = res *a; mul(a,a,a);//a *= a; n &gt;&gt;= 1; &#125; cout&lt;&lt;f[2]; //f[N] = f[1]*A^N-1 因为f[n] = &#123;fn,fn+1,Sn&#125;那么f[2]就对应Sn经过快速幂最后得到的Sn的值 return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>FastPower</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashOfString]]></title>
    <url>%2F2020%2F02%2F24%2FHashOfString%2F</url>
    <content type="text"><![CDATA[字符串哈希 第十九天，加油！ 题目 输入输出 样例 分析思路这题可以用字符串哈希的方式去解决把字符串看成是一个P进制的数str = “ABCABCDEYXC…..”那么h[0] = 0;h[1] = “A”的hash值h[2] = “AB”的hash值h[3] = “ABC”的hash值h[4] = “ABCA”的hash值…1.那么对于1到N的字符串来说如果想求L到R区间的hash值因为h[R]表示1到R的hash值h[L-1]表示1到L-1的hash值那么对于P进制来说，由于从左到右是从高位往低位走对于h[R]来说，下标R对应的为P^0,R-1为P^1,…,依次类推1对应的就是P^(R-1)对于h[L-1]，下标L-1对应的为P^0,L-2为P^1,…,依次类推1对应的就是P^(L-2)那么我们把h[L-1]向左移直到与h[R]对齐，左移的位数就是R-1-(L-2) = R-L+1比如123456789，我们要求789这个哈希值那么就找到7之前的哈希值123456然后向左移3位得到123456000最后123456789 - 123456000 = 789所以从L到R这段的hash值就表示为h[R] - h[L]*P^(R-L+1) 2.对于字符串hash来说ABCD假设映射为(1234)p那么ABCD的hash值就为(1*P^3+2*P^2+3*P^1+4*P^0)mod Q那么映射的hash值就是0到Q-1的数了PS:Q经验值取2^64，p一般取131或者13331 注意点1.字符串哈希默认P进制中的P = 131或者133312.不能把某一个字母映射成0，假设A映射成0，A的hash值为0，那么AA的hash值也为0，这样不同的字符串映射成了同一个数字，所以需要避免这种现象3.因为映射的Q为2^64,我们可以不用取模运算，直接用unsigned long long 来存储我们所有的h[i]，溢出的时候就相当于模上2^644.预处理前缀就是h[i] = h[i-1]*P + str[i]; 应用可以应用于一个字符串里面判断有没有两段是完全相同，这个方法比KMP要更好而且很多拓展的题目也可以应用到这个字符串哈希方法 草稿 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010,P = 131;int n,m;char str[N];ULL h[N],p[N];ULL get(int l,int r)//计算(l,r)的hash值&#123; return h[r] - h[l-1]*p[r-l+1]; &#125;int main()&#123; scanf("%d%d%s",&amp;n,&amp;m,str+1); p[0] = 1;//令P^0 = 1 for(int i = 1;i &lt;= n;i++) &#123; p[i] = p[i-1] * P;//预处理P^i h[i] = h[i-1]* P + str[i];//计算字符串的前缀和取模hash值，因为用的是ULL类型所以就不用取模运算了 &#125; while(m--) &#123; int l1,r1,l2,r2; scanf("%d%d%d%d",&amp;l1,&amp;r1,&amp;l2,&amp;r2); if(get(l1,r1) == get(l2,r2)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing240-UnionFind]]></title>
    <url>%2F2020%2F02%2F22%2FAcWing240-UnionFind%2F</url>
    <content type="text"><![CDATA[一个稍微复杂一点的并查集模型摸了两天，今天是第十八天，争取一周能有五篇吧 题目 输入输出 分析思路我们可以用一个并查集的思路来做这道题不管是不是同类我们都放到一个集合里面或者说是放到一个子树里面我们可以设置距离根节点距离为1的点为吃掉根节点的，距离为2的点为被根节点吃的，距离为0的点(即模3余0)判断思路1.如果x,y均大于n，说明是假话2.A.当t == 1的时候，如果x和y的祖宗节点px,py相同的话，那么说明x和y在同一个集合里面，这个时候就判断x到根节点的距离d[x]和y到根节点的距离d[y]的关系，因为如果只有x和y到根节点距离相等的时候表示x和y是同类,那么距离不等的时候就不是同类，即(d[x] - d[y]) %3 != 0的时候表示距离不等，为假B.当t == 1的时候，如果x和y的祖宗节点px,py不相同的话，那么说明x和y不在同一个集合里面，那么这个时候就令x的祖宗结点px指向y的祖宗结点py这个时候px到根节点的距离需要计算令px指向py，(d[x] + ？)%3 = d[y] % 3则？ = d[y] - d[x] ，？ = d[px];即d[px] = d[y] - d[x];下面代码里有更形象的解释3.当t == 2的时候A.当x和y的祖宗结点相同的时候即px == py时，说明x和y在同一个集合里面如果x比y的距离多1,即(d[x] - d[y]-1)%3 == 0，说明他俩就是x吃y，否则不是下面代码里有更形象的解释B.当x和y的祖宗结点不相同的时候即px != py时，说明x和y不在同一个集合里面，这个时候就令x的祖宗节点指向y的祖宗节点，因为x吃y所以(d[x] + d[px]) % 3 == (d[y] + 1) % 312345678910因为是x吃y，那么x到根节点的距离比y要多1 因为距离根节点为1的点是吃根节点的，距离为2的点是被根节点吃的 ----------------- | | v | | | 0-----&gt;1-------&gt;2 比如0是根节点，1是吃根节点的距离为1,2是被根节点吃的距离为2 那么2吃1的话即2到根节点的距离要比1到根节点的距离多1 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;using namespace std;const int N = 50010;int n,m;int p[N],d[N];//d[i]表示到父节点的距离，只不过find之后才会变成到祖宗节点的距离int find(int x)&#123; if(p[x] != x)//如果x不是树根的话 &#123; int t = find(p[x]);//先找到根节点，并存起来 //p[x] = find(p[x]); d[x] += d[p[x]];//d[x]就是点x到点p[x]之间的距离，而d[p[x]]就是点p[x]到根节点的距离 p[x] = t; &#125; return p[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) p[i] = i; int res = 0; while(m--) &#123; int t,x,y; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x &gt; n|| y &gt; n) res++; else &#123; int px = find(x),py = find(y); if(t == 1) &#123; //如果x和y在同一个根节点上，但是x到根节点的距离和y到根节点距离模3不相同，说明x和y不是同类 //因为如果是同类的话到根节点的距离模3应该相同 if(px == py &amp;&amp;(d[x] - d[y]) %3 != 0) res++; else if(px != py)//如果x和y不在同一个根节点上 &#123; p[px] = py;//令x的根节点指向y的根节点，即px----&gt;py d[px] = d[y] - d[x];//那么px到根节点的距离就是如下所示 /* d[x] x-----px | |？ V y-----py d[y] 令px指向py，(d[x] + ?)%3 = d[y] % 3 则? = d[y] - d[x] ，？ = d[px]; 即d[px] = d[y] - d[x]; */ &#125; &#125; else//如果t == 2 &#123; //x吃y，那么x到根节点的距离比y要多1 //因为距离根节点为1的点是吃根节点的，距离为2的点是被根节点吃的 /* ----------------- | | v | | | 0-----&gt;1-------&gt;2 比如0是根节点，1是吃根节点的距离为1,2是被根节点吃的距离为2 那么2吃1的话即2到根节点的距离要比1到根节点的距离多1 */ if(px == py &amp;&amp; (d[x] - d[y]-1)%3 != 0)//x和y在同一个集合里面 &#123; //如果x比y的距离多1,即(d[x] - d[y]-1)%3 == 0 //说明他俩就是x吃y，否则不是 res++; &#125; else if(px != py)//x和y不在一个集合里面 &#123; p[px] = py;//令x的祖宗节点指向y的祖宗节点 d[px] = d[y] + 1 - d[x]; //因为x吃y所以(d[x] + d[px]) % 3 == (d[y] + 1) % 3 /* d[x] x-----px | |d[px] V y-----py d[y] */ &#125; &#125; &#125; &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-154-SlidingWindow]]></title>
    <url>%2F2020%2F02%2F19%2FAcWing-154-SlidingWindow%2F</url>
    <content type="text"><![CDATA[AcWing154.滑动窗口第十五天！今天开始单推AKi！！！！！！！！ 题目 样例 输入输出 分析思路这题应该用单调队列的思路去解决问题1.如果用暴力方法来维护的话每次需要遍历一遍队列然后去找到最大值和最小值每次把一个数插入队尾然后再删除队头时间复杂度为O(NK)挪动N次，扫描K次 2.如何去优化？比如当前队列里面3,-1,-3只要-1在，-3一定在，那么一定不会用到-1，所以我们就可以把这个元素删掉所以在队列里面，如果后面有一个元素比当前这个元素小的话，就可以把当前这个元素删掉了所以删掉一定不会用到的元素后，那么队列里面应该变成从小到大的元素了因为如果如果后面一个元素比当前元素小，就会删掉当前这个元素所以最大值和最小值就不用再继续遍历了，可以直接从队头/队尾取出最值，时间复杂度为O(1)同理求最大值的方法对称再来一遍就行了 注意点1.单调队列应该存放数组的下标，这样可以方便我们去判断队头是否滑出了窗口2.至少扫描了K个数之后再进行输出即i &gt;= k-1,表示扫描了0到k-1这k个数之后再输出队头元素 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;const int N = 1000010;int n,k,a[N],st[N];int hh = 0,tt = -1;//hh为队头,tt为队尾int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); //找到窗口中的最小值 for(int i = 0;i &lt; n;i++) &#123; //判断队头是否还在窗口内 //如果队头小于队尾，且滑动窗口超过了最左边的队头，那么hh就右移 if(hh &lt;= tt &amp; i - k + 1 &gt; st[hh]) hh++; //如果队尾的值大于a[i]，即队尾的元素大于后面那个元素，这个时候就把队尾大的元素出队 //直到队列里面都是比后面元素a[i]小的时候停止 while(hh &lt;= tt &amp;&amp; a[st[tt]] &gt;= a[i]) tt--; //这个时候再把a[i]的下标加入队列中，加入下标到队列中的好处是可以判断是否超过边界 st[++tt] = i; //最小值一定是在队头的位置 if(i - k + 1 &gt;= 0)//当至少扫描了K个数之后输出 printf("%d ",a[st[hh]]); &#125; cout&lt;&lt;endl; hh = 0,tt = -1; //找到窗口中的最大值 for(int i = 0;i &lt; n;i++) &#123; if(hh &lt;= tt &amp; i - k + 1 &gt; st[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[st[tt]] &lt;= a[i]) tt--; st[++tt] = i; if(i - k + 1 &gt;= 0) printf("%d ",a[st[hh]]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>SlidingWindow</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[intervaldp-qujiandp]]></title>
    <url>%2F2020%2F02%2F16%2Fintervaldp-qujiandp%2F</url>
    <content type="text"><![CDATA[一个需要思考的区间dp问题第十四天desu！ 题目 输入输出 分析题目提取模型分析题目我们可以知道密码是由A、B、C、D四个回文子串串成的一个序列但是因为年代久远，A、B、C、D中有的密码脱落了所以它组成的这个序列就不是回文子串了我们需要找到当初最少添加多少个字母才能重新组成一个回文子串——&gt;添加n个字母组成回文子串,意味着原序列S里面也有n个字母没有对应的字母——&gt;继续转化,即转化为原序列S中删除n个字母可以形成回文串比如ABCDCBA,原本需要加一个D形成回文子串,我们可以转化为减去一个D形成ABCCBA回文子串——&gt;所以我们需要找到原序列S中的最长回文子序列即ABCDCBA里面的”ABC_CBA”回文子序列可以不连续 用dp的思想去解决问题显然，这题可以用区间dp的思路去解决问题状态用f[L,R]表示所有S[L,R]之间回文子串集合长度的最大值我们可以从f[L,R]来分解为四个部分1.如果S[L] == S[R]即区间[L,R]的两个端点相等的话那么f[L,R] = f[L+1,R-1] + 2;即等于去除这两个端点里面子序列的值加上22.如果S[L] != S[R]那么可以继续分情况讨论A.如果S[L]这个端点不在回文子序列里面B.如果S[R]这个端点不在回文子序列里面C.如果S[L]和S[R]都不在回文子序列里面然后f[L,R]对上述三种情况取一个max即可，虽然这三种情况有重复的部分，但是不影响我们取最大值，且C这种情况可以包含到AB两种情况中去那么f[L,R] = max(f[L+1,R],f[L,R-1]); 注意点1.我们这题应该从长度为1来开始进行枚举比如ABCBAC,A、B、C、B、A、C对应的f[L][R] = 1,即L == R的时候然后依次AB、BC、CB、BA、AC依次进行枚举这样子长度从小到大进行枚举，从而保证不漏2.我们求出的是最长回文子序列的长度f[0][n-1]，还要用n减去f[0][n-1]从而得到要删去字母的个数，同时也是题目要求添加字母形成回文串的个数 代码如下：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1010;int f[N][N];//f[L][R]表示区间[L,R]之间的所有回文子序列集合长度的最大值， //最后f[0][n-1]对应的就是最大回文子序列的长度，n - f[0][n-1]即为脱落的种子数//注意，最大回文子序列和最大回文子串不同，最大回文子序列可以不连续而最大回文子串需要连续string str;int main()&#123; cin&gt;&gt;str; int len = str.size(); for(int i = 1;i &lt;= len;i++) &#123; for(int l = 0;l + i -1 &lt; len;l++ ) &#123; int r = l + i - 1; if(l == r) &#123; f[l][r] = 1; continue; &#125; if(str[l] == str[r]) f[l][r] = f[l+1][r-1] + 2; else f[l][r] = max(f[l+1][r],f[l][r-1]); &#125; &#125; cout&lt;&lt;len - f[0][len-1]; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SumOfCountInversions]]></title>
    <url>%2F2020%2F02%2F14%2FSumOfCountInversions%2F</url>
    <content type="text"><![CDATA[逆序对的数量 第十三天,加油！ 逆序对的定义对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对。重要的地方在于，一个元素可以不只是在一个逆序对中存在。如果 k &gt; j &gt; i 且 a[i] &gt; a[j] &gt; a[k]，那么这里有两个逆序对，分别是 (a[i], a[j]) 和 (a[i], a[k]), a[i]是可以使用多次的。 题目 输入输出 思路这道题可以用分治的思路解决，因为我们观察可知如果把一个数组一分为二，那么有三种情况1.两个数都在左边2.两个数都在右边3.两个数一个在左边一个在右边 假设数组的左右两边都已经按顺序排序好了我们这个时候就要考虑第三种情况假设数组为4,5,6,8,12,1,2,3,7,8这个时候我们枚举左边进行排序比如4比1大，那么4右边一直到中间的数一定也都比1大这个时候我们直接令res = mid - i + 1即为1对应的逆序对然后依次类推 为什么要排序？如上图所示，当进行排序过后方便我们进行计算以上面的数组为例归并排序最后分组8 | 5 | 12| 4| 6 | 8| 2 | 3 | 7 | 1 | 当一半一半的递归下去进行分组的时候8 和 5分到了左右两边这个时候第一种情况和第二种情况为0考虑第三种情况因为8比5大所以res += 1然后把8和5进行排序成5和8依次类推再合并进行5,8|4,6,12然后再合并左右两边，从而得到最终的结果 为什么这样排序不会改变逆序对数量？我个人的理解是左边的逆序对和右边的逆序对分别单独计算不会改变既在左边也在右边的逆序对，把左右的逆序对数目统计了之后就可以分别排序然后再计算第三种情况的逆序对数目 总之，这题就是在归并排序里面加一个计算逆序对的思想 注意点1.这题的数据会爆int，所以要转化成long long的形式记录数据2.当l == r的表示[l,r]区间只有一个数，返回0 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 100000 + 10;int a[N],tmp[N];int n;LL merge_reverse(int l,int r)&#123; if(l == r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_reverse(l,mid)+merge_reverse(mid+1,r); int i = l,j = mid + 1,k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) &#123; if(a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; tmp[k++] = a[j++]; res += mid - i + 1; &#125; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for(int i = 0;i &lt; k;i++) a[l+i] = tmp[i]; return res; &#125;int main()&#123; cin&gt;&gt;n; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); cout&lt;&lt;merge_reverse(0,n-1); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[difference_chafen]]></title>
    <url>%2F2020%2F02%2F13%2Fdifference-chafen%2F</url>
    <content type="text"><![CDATA[差分模板 Day12,struggling! 差分的意义对于一维数组A[i],在[l,r]区间上使得每一个数同时加上一个C这个操作需要O(n)的时间复杂度而差分可以让我们从O(n)的时间复杂度降低到O(1)的复杂度 一维差分操作原数组a[N]存放每个数,b[N]为差分数组使得b[1] = a[1];b[2] = a[2] - a[1];b[3] = a[3] - a[2];…b[N] = a[N] - a[N-1]; 从而b[1] + b[2] + b[3] + … + b[i] = a[i];即b[N]数组的前缀和为a[i] 思路对于一个区间[l,r]上，我们想要让a[l]到a[r]所有数都加上C那么我们可以使b[l] += C,b[r+1] -= C;因为b[l] += C意味着求前缀和的时候在区间[l,N]的所有数都加上了一个Cb[r+1] -= C意味着求前缀和的时候在区间[r+1,N]的所有数都减去了一个C这样使得求前缀和的时候得到a的时候[l,r]区间都加上了一个C因为只要b[l] += C之后，最后求前缀和的时候l之后r之前的对应的a都会加到b[l]即a[i] = b[1] + b[2] + … + b[l] + … + b[i] 同理如果i在l之前的区间则不会加到b[l]，如果在r之后的区间也会加到b[r+1]，加C减C抵消 一维差分的例题题目 输入输出 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100000 + 10;int a[N],b[N];int n,m;int l,r,c;void insert(int l,int r,int c)&#123; b[l] += c; b[r+1]-=c;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a[i]); insert(i,i,a[i]); &#125; while(m--) &#123; scanf("%d %d %d",&amp;l,&amp;r,&amp;c); insert(l,r,c); &#125; for(int i = 1;i &lt;= n;i++) &#123; b[i]+=b[i-1]; &#125; for(int i = 1;i &lt;= n;i++) &#123; printf("%d ",b[i]); &#125; return 0;&#125; 注意点我们在进行插入操作的时候可以把a[N]看成一个全为0的数组然后在区间(i,i)的地方一个一个插入a[i]. 二维差分思路二维差分就是把一维差分的操作扩展到了二维 即二维数组a[i][j]存储每个数b[i][j]存储差分和计算b[i][j]的二维前缀和求出a[i][j] 关键对于矩阵(x1,y1),(x2,y2)这一块区域如果要同时加上C对应的操作为b[x1][y1] += C;b[x2+1][y1] -= C;b[x1][y2+1] -= C;b[x2+1][y2+1] += C; 注意图里面虽然是紧挨着的，但是计算机里面是对应一个一个坐标所以我们要从(x2+1,y1)和(x1,y2+1)开始 题目 输入输出 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000 + 10;int a[N][N],b[N][N];int n,m,q;void insert(int x1,int y1,int x2,int y2,int c)&#123; b[x1][y1] += c;//相当于(x1,y1)到右下角的区域全部加了c b[x2+1][y1] -=c;//相当于(x2+1,y1)到右下角的区域全部减去c b[x1][y2+1] -=c;//相当于(x1,y2+1)到右下角的区域全部减去c b[x2+1][y2+1] += c;//相当于(x2+1,y2+1)到右下角的区域全部加了c&#125;int main()&#123; scanf("%d %d %d",&amp;n,&amp;m,&amp;q); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; scanf("%d",&amp;a[i][j]); insert(i,j,i,j,a[i][j]); /*等价写法 b[i][j] = a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; 因为a[i][j]是b[i][j]的前缀和，那么a[i][j] = b[i-1][j] b[i][j]的前缀和数组为S[i][j] S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + b[i][j]; 因为a就是b的前缀和数组，所以S可以转换为a 那么a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + b[i][j]; 即b[i][j] = a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; */ &#125; int x1,y1,x2,y2,c; while(q--) &#123; scanf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c); insert(x1,y1,x2,y2,c); &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; printf("%d ",b[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 注意点同一维差分，我们在进行插入操作的时候相当于在区域[(i,j)(i,j)]这个地方插入a[i][j]]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing1209-dfs]]></title>
    <url>%2F2020%2F02%2F11%2FAcWing1209-dfs%2F</url>
    <content type="text"><![CDATA[AcWing1209.带分数第十一天~ 题目 输入输出 分析思路n可以表示成n = a + b / c的形式且a、b、c组成的数字为1到9且只能出现一次那么a、b、c就是1到9组成的全排列然后再随机分配成3个数 思路1第一种思路就是枚举1到9的全排列然后把每次的排列隔两个板子分成3个数然后再判断是否符合n = a + b / c 时间复杂度9!*9(枚举全排列的时间复杂度为n!*n)*C(8,2)(即9个数之间插两块板子) = 91445760差不多九千多万的复杂度大致的思路即为1.枚举全排列2.枚举位数3.判断等式是否成立 注意点在把1到9的全排列用两个板子分成三段可以用一个calc函数来进行计算calc(i,j)表示对数组里面i到j位转换为对应的数，即123456789int calc(int l,int r)&#123; int re = 0; for(int i = l;i &lt;= r;i++) &#123; re = re*10 + num[i]; &#125; return re;&#125; 思路2第二种思路是在第一种思路上进行的优化因为n = a + b / c，那么即b = n*c - a*c我们只需要枚举a和c就可以求出b来再判断1.b里面是否有0或者a和c重复的数字2.最后判断1到9里面是否还有数字没用到过这样可以降低时间复杂度大致的思路就是1.枚举a2.在枚举a的基础上去枚举c3.根据a和c求出b，然后再去判断是否满足条件(枚举a的基础上去枚举c其实是一个嵌套的dfs) 注意点这里 b = n*c - a*c中c可能有8位然后和n最大6位相乘会爆int，需要转化成long long 进行计算 思路1对应的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 10;int num[N];//num数组存放每次全排列的结果int used[N] = &#123;false&#125;;//定义一个数组来判断全排列的时候哪些数用过哪些数没用过int res = 0,n;int calc(int l,int r)&#123; int re = 0; for(int i = l;i &lt;= r;i++) &#123; re = re*10 + num[i]; &#125; return re;&#125;void dfs(int u)&#123; if(u == 9) &#123; for(int i = 0;i &lt; 7;i++) for(int j = i+1;j &lt; 8;j++) &#123; int a = calc(0,i); int b = calc(i+1,j); int c = calc(j+1,8); if(a &gt; n) continue; if(b == n*c - a*c) res++; &#125; return ; &#125; for(int i = 1;i &lt;= 9;i++) &#123; if(!used[i]) &#123; used[i] = true; num[u] = i; dfs(u+1); used[i] = false; num[u] = 0; &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; dfs(0); cout&lt;&lt;res; return 0;&#125; 思路2对应的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 10;int n;bool st[N], backup[N];int ans;bool check(int a, int c)&#123; LL b = n * (LL)c - a * c; if (!a || !b || !c) return false; memcpy(backup, st, sizeof st); while (b) &#123; int x = b % 10; // 取个位 b /= 10; // 个位删掉 if (!x || backup[x]) return false; backup[x] = true; &#125; for (int i = 1; i &lt;= 9; i ++ ) if (!backup[i]) return false; return true;&#125;void dfs_c(int u, int a, int c)&#123; if (check(a, c)) ans ++ ; for (int i = 1; i &lt;= 9; i ++ ) if (!st[i]) &#123; st[i] = true; dfs_c(u + 1, a, c * 10 + i); st[i] = false; &#125;&#125;void dfs_a(int u, int a)&#123; if (a &gt;= n) return; if (a) dfs_c(u, a, 0); for (int i = 1; i &lt;= 9; i ++ ) if (!st[i]) &#123; st[i] = true; dfs_a(u + 1, a * 10 + i); st[i] = false; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs_a(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing93-dfsCombination]]></title>
    <url>%2F2020%2F02%2F10%2FAcWing93-dfsCombination%2F</url>
    <content type="text"><![CDATA[一个简单的递归实现的枚举问题 第十天，好好总结之前学过的东西！明天得开始好好按计划执行了 题目 输入输出 分析思路这题是要我们从1到n这n个整数里面随机选出m个数且按照从小到大进行输出 举例假设我们从1到5这5个数里面随机选出3个来我们可以从三个位置来进行分析如果所示我们第一个位置选1之后，那么第二个位置只能从2到5进行选择所以我们dfs函数的参数应该这样考虑1.因为要枚举每个位置，用一个数组way[N]来记录每个位置放什么数2.要用一个参数来判断枚举到哪个位置，用一个变量u来表示当前枚举到第几个位置3.因为枚举完一个数到一个位置之后，后面的数只能比已经枚举的数要大，所以要用一个变量start来表示当前最小可以从start开始枚举4.排列性枚举里面需要判重数组，因为他不知道哪个数有没有用过，但是组合枚举就不需要这个判重数组了 代码如下1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 26;int n,m;//n表示1到n个数，m表示从n个数中随机选取m个int way[N];//定义一个数组来存放每个位置对应的数void dfs(int u,int start)//u表示当前数组枚举在第几个位置,start表示可以从start向后选&#123; if(u == m+1) &#123; for(int i = 1;i &lt;= m;i++) cout&lt;&lt;way[i]&lt;&lt;" "; cout&lt;&lt;endl; return ; &#125; for(int i = start;i &lt;= n;i++) &#123; way[u] = i; dfs(u+1,i+1); way[u] = 0; &#125; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,1); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EulerSieve]]></title>
    <url>%2F2020%2F02%2F09%2FEulerSieve%2F</url>
    <content type="text"><![CDATA[欧拉筛模板 Day 9! 12345678910111213141516171819202122int primes[N], cnt;int minp[N];bool st[N];void get_primes(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) &#123; minp[i] = i; primes[cnt ++ ] = i; &#125; for (int j = 0; primes[j] * i &lt;= n; j ++ ) &#123; int t = primes[j] * i; st[t] = true; minp[t] = primes[j]; if (i % primes[j] == 0) break; &#125; &#125;&#125; st[i] == 0表示没有被筛过,1表示被筛过否则从小到大枚举质数，然后把质数的i倍都筛掉1.我们筛掉的一定是合数，primes[j]一定不大于i的最小质因子，故一定是用最小质因子筛除的 2.合数一定会被筛掉，因为合数一定包含一个最小质因子设数N的最小质因子为pN = p * N/p则当i枚举到N/p的时候,因为p是最小质因子一定在primes数组里面会被枚举到t = N/p * p = N即合数N一定会被筛掉 核心本题的核心在于if (i % primes[j] == 0) break;这句话上当 i是prime[j]的倍数时，i = kprime[j]，如果继续运算 j+1，i * prime[j+1] = prime[j] * k prime[j+1]，这里prime[j]是最小的素因子，当i = k * prime[j+1]时会重复，所以才跳出循环。 举例假设2, 3, 4, 5, 6, … 12 请问12在什么时候被筛去的呢？ 按上述解释以及程序计算，在i == 4时，质数表中已有2, 3，可以4 * 3 == 12. 后续 i == 6时， 质数表2, 3, 5，也可以 6 * 2 == 12 筛去12. 跟着程序算一次便知，i == 4时只筛去了8，为何不筛去12，因为12的最小质因数为2，由4 mod 2 == 0也可以看出4不是最小质因数，与2配对的因数6将在后面筛去12，这样才是用最小质因数去筛。 而线性的证明，只需由上述例子中看出每个被筛去的数都是唯一的由 最小质因数（其实也就是最小正因数，易证）配对的因数（相应的最大因数）筛去，每个数只被筛去一次，故为O(n)。]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SegmentTree]]></title>
    <url>%2F2020%2F02%2F08%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[线段树 第八天！加油啊！！！！奥利给！ 线段树的两个功能1.单点修改，时间复杂度为O(logn)2.区间查询，时间复杂度为O(logn) 四个基本操作1.pushup: 用子节点的信息更新当前结点信息2.build: 在一段区间上初始化线段树3.modify: (单点)修改4.query: 查询操作 根据具体例子来写一个线段树同上次用树状数组的那题，这次用线段树进行求解 题目 输入输出 线段树会存到一个一维数组里面其中下标为x的结点 父节点为x/2 或 x &gt;&gt; 1 左儿子是2x 或 x &lt;&lt; 1 右儿子是2x+1或 x &lt;&lt; 1|1 因为线段树是一棵树，所以一开始第一层会有n个点然后第二层有n/2个点，第三层有n/4个点依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数所以最后一层最多有2n个n + n/2 + n/4 + …+ 1 + 2n &lt; 4n 所以结点个数小于4n我们设置的数组大小应为4*N我们用一个结构体数组来存放各个结点的信息1234struct Node&#123; int l,r; int sum;&#125;tr[4*N]; 其中l,r代表当前结点的左右边界,sum为当前结点左右边界里面所有数的和 具体的四个基本操作pushup操作pushup是把子节点的信息更新到父节点这里的题就对应着把子节点的值更新以后，向上更新到父节点1234void pushup(int u)&#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1|1].sum;&#125; build操作我们这里设置一个函数build(u,l,r)表示把(l,r)这一段的数初始化为线段树其中u一般为根节点,l,r一般为我们要初始化成线段树的数组的边界1234567891011void build(int u,int l,int r)//u为当前结点边界,l,r为左右边界&#123; if(l == r) tr[u] = &#123;l,r,w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid+1,r); pushup(u);//把信息往上传递 &#125;&#125; 我们设置mid = l + r &gt;&gt; 1然后u的左儿子对应的就是build(u &lt;&lt; 1,l,mid)右儿子对应的就是build(u &lt;&lt; 1|1,mid+1,r) 需要注意的点当l == r的时候表示到达了根节点，这个时候直接赋值同时在进行每个操作的时候同样要进行初始化即tr[u] = {l, r};表示进入这个函数后u结点对应的边界为l到r query操作在这个题目里面query操作对应的就是计算区间和了我们定义query(u,l,r)为计算区间(l,r)的区间和，其中u一般为根节点开始12345678910111213int query(int u,int l,int r)&#123; //如果结点u对应的边界l1,r1在区间l到r之间，直接返回sum if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; //否则计算u对应边界的中点 int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; //如果l小于u对应的中点，说明需要到u的左儿子里面继续寻找 if(l &lt;= mid) sum += query(u &lt;&lt; 1,l,r); //同理如果r大于u对应的中点，说明需要到u的右儿子里面继续寻找 if(r &gt; mid)sum += query(u &lt;&lt; 1|1,l,r); return sum;&#125; modify操作在本题里面modify为修改某个点对应的值我们定义modify(u,x,v)为修改下标为x对应的值要加上v，u一般从根节点开始1234567891011void modify(int u,int x,int v)&#123; if(tr[u].l == tr[u].r) tr[u].sum += v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1,x,v); else modify(u &lt;&lt; 1|1,x,v); pushup(u); &#125;&#125; 本人的理解就是有点二分查找的意思，u从根节点开始假设一个数组下标为1,2,3,4,5,6,7，我们要修改下标为5的数那么根节点u边界为1到7mid = 1 + 7 &gt;&gt; 1 = 4 &lt; 5这个时候就要从5到7去找，即u的右儿子继续寻找mid = 5 + 7 &gt;&gt; 1 = 6 &gt; 5这个时候就找5到6，即u的左儿子继续寻找然后mid = 5 + 6 &gt;&gt; 1 = 55 == 5这个时候即为根节点，修改对应的值后再pushup(u)更新结点 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;//线段树//对应的操作//pushup: 用子节点的信息更新父节点//build: 在一段区间上初始化线段树//modify: 单点修改或者修改操作//query: 查询操作/*假设第一层有n个点，那么第二层有n/2个点，第三层有n/4个点 依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数 所以最后一层最多有2n个 n + n/2 + n/4 + ...+ 1 + 2n &lt; 4n 所以结点个数小于4n 线段树存到一个一维数组里面 下标为x的结点 父节点为x/2 或 x &gt;&gt; 1 左儿子是2x 或 x &lt;&lt; 1 右儿子是2x+1或 x &lt;&lt; 1|1*/const int N = 100010;int n,m;int w[N];struct Node&#123; int l,r; int sum;&#125;tr[4*N];void pushup(int u)&#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1|1].sum;&#125;void build(int u,int l,int r)//u为当前结点边界,l,r为左右边界&#123; if(l == r) tr[u] = &#123;l,r,w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid+1,r); pushup(u);//把信息往上传递 &#125;&#125;int query(int u,int l,int r)&#123; if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; if(l &lt;= mid) sum += query(u &lt;&lt; 1,l,r); if(r &gt; mid)sum += query(u &lt;&lt; 1|1,l,r); return sum;&#125;void modify(int u,int x,int v)&#123; if(tr[u].l == tr[u].r) tr[u].sum += v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1,x,v); else modify(u &lt;&lt; 1|1,x,v); pushup(u); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;w[i]); build(1,1,n); int k,a,b; while(m--) &#123; scanf("%d%d%d",&amp;k,&amp;a,&amp;b); if(k == 0) printf("%d\n",query(1,a,b)); else modify(1,a,b); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinaryIndexedTree]]></title>
    <url>%2F2020%2F02%2F06%2FBinaryIndexedTree%2F</url>
    <content type="text"><![CDATA[树状数组及其模板题第七天！777777777 从求区间和的问题来进行深入思考对于这种求区间和的问题，一般我们都是通过一个前缀和数组计算S[n]-S[m-1]从而求得区间[m,n]的和但是，如果我们中途要随时给第x个整数加上某一个数v那么我们需要重新更新前缀和数组S，时间复杂度为O(n)如果进行K次这样的操作那么时间复杂度为O(Kn)我们难以接受 于是我们就要想一个办法来解决这个问题降低时间复杂度 于是我们就应用树状数组来解决问题 树状数组的两个应用1.给区间中的某个位置加上一个数2.求前缀和从而方便得到区间和 树状数组仍然是一个数组C[N]，只不过它存的不是从1到N的前缀和而是从区间(x-2^k,x]即C[x] = (x-2^k,x]其中k表示当前下标x对应的数在第k层 举例设有原数组A[N],树状数组C[N]其中对于奇数来说C[1] = A[1]C[3] = A[3]C[5] = A[5]C[7] = A[7]C[9] = A[9]C[11] = A[11]C[13] = A[13]C[15] = A[15] 对于偶数来说第一种C[2] = A[1] + A[2]C[6] = A[5] + A[6]C[10] = A[9] + A[10]C[14] = A[13] + A[14] 第二种C[4] = A[4] + C[3] + C[2] = A[1] + A[2]+ A[3]+A[4]C[8] = A[8] + A[7] + C[6] + C[4] = A[1]+ … + A[8]….C[16] = A[1] + … + A[16] 不难看出，如果把x转换为二进制表示C[x]就表示区间(x-2^k,x]这个前开后闭区间的和其中k表示二进制后面有多少个0对应到我们样例中就是第几层到当前下标x对应层的和 lowbit运算我们定义lowbit(x) = x &amp; -x拿x = 6来举例x|—-0000001101001100-x|—1111110010110100x&amp;-x|-0000000000000100即6对应1后面有2个0lowbit(6) = 2(lowbit(x)也可以理解为能整除x的最大2的幂次) 于是我们可以把区间(x-2^k,x]转换为(x-lowbit(x),x] 最后求出树状数组C[N]即可进行更多的操作 AcWing 1264. 动态求连续区间和题目 输入输出 树状数组模板题 注意点1.lowbit运算 即x &amp; -x2.在下标为x的位置加上v 我们就需要更新树状数组C[i] 即把下标为x,x+lowbit(x),x+2*lowbit(x),…,的树状数组更新3.求前缀和因为C[x]表示区间(x-lowbit(x),x]这个里面的区间和我们只需从x开始从后往前加和直到i等于0为止比如12345res += C[x];y = x - lowbit[x];res += C[y]//而C[y]表示区间(y-lowbit(y),y]即区间一直往前延伸直到为0为止然后依次类推 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n,m,k;int a[N],tr[N];int lowbit(int x)//进行lowbit运算&#123; return x &amp; -x;&#125;void add(int x,int v)//add函数表示在下标为x的位置加v&#123; for(int i = x;i &lt;= n;i += lowbit(i)) tr[i] += v;&#125;int query(int x)//利用树状数组求前缀和&#123; int res = 0; for(int i = x;i &gt; 0;i -= lowbit(i)) &#123; res += tr[i]; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) add(i,a[i]);//生成树状数组 int a,b; //查找操作 while(m--) &#123; scanf("%d %d %d",&amp;k,&amp;a,&amp;b); if(k == 1) add(a,b); else printf("%d\n",query(b) - query(a-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quickSort]]></title>
    <url>%2F2020%2F02%2F05%2FquickSort%2F</url>
    <content type="text"><![CDATA[快速排序[模板]因为各种事情断了两天，就算是第六天吧！接下来还会一直坚持的 题目 输入输出样例 分析思路快速排序的思路,对于一个数列q[N]1.确定分界点 q[l]、q[r]或者是q[l + r &gt;&gt; 1]或者是l到r区间上的随机点值得注意的是如果数据范围很复杂最好不取两个端点而是取中间的点 2.调整区间使得最后调整的区间x点左边都小于等于xx点右边都大于等于x 3.递归处理左右两个区间 注意点1.如果是取区间的中点那么l + r &gt;&gt; 1有可能要改成l + r &gt;&gt; 1 防止出现死循环2.最后左右递归区间的时候要注意那个分界点对x取点的影响，防止出现死循环3.因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r) 反之则划分为(l,i-1),(i,r),这个时候对应的x的取值就要相应改变 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100000 + 10;int n;int f[N];void quick_sort(int num[],int l,int r)&#123; if(l &gt;= r) return ;//如果l&gt;=r则直接返回 int i = l-1,j = r+1; //这里i和j要从区间左右两端的外侧开始，因为后面是先i++,j--然后再进行判断 int x = num[(i + j) / 2]; //当区间划分为下面这种的时候 //quick_sort(num,l,i-1); //quick_sort(num,i,r); //int x = num[(i + j + 1) / 2]; x应该上取整才能防止死循环 while(i &lt; j) &#123; do i++; while(num[i] &lt; x); do j--; while(num[j] &gt; x); if(i &lt; j)swap(num[i],num[j]); &#125; //因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r) //反之则划分为(l,i-1),(i,r) quick_sort(num,l,j); quick_sort(num,j+1,r);&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;f[i]); quick_sort(f,1,n); for(int i = 1;i &lt;= n;i++) printf("%d ",f[i]); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing122-GreedyAlgorithm]]></title>
    <url>%2F2020%2F02%2F02%2FAcWing122-GreedyAlgorithm%2F</url>
    <content type="text"><![CDATA[一个稍微复杂的贪心问题 第五天了，我真的是一天都没有停下来呢。 题目 输入输出格式 分析思路n个小朋友围成一个环，然后每个人只能给左右两个人传递糖果且传递x个糖果消耗的代价为x 第一直觉肯定是糖果多的人怎么传给糖果少的人一时半会看不出来用什么方法可以解决问题，我们于是可以先建立一个数学模型 建立数学模型我们可以设n个小朋友现在手里的糖果数分别为A1,A2,A3 … ,An-1,An我们约定，从An传递到An-1为Xn个糖果数 其中,Xn为正表示糖果从An传递到An-1 反之如果为负，则表示从An-1传递到An 则依题意可知我们最终要求的就是|X1| + |X2| + |X3| + … + |Xn|的最小值 第二次做题的思路然后转化成求一个点到各个C[i]的距离之和最小，就是排序之后的C[i]数组的中点到各个C[i]点之差的和即为最小的距离之和 代码如下12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000000 +10;typedef long long LL;int A[N],C[N],S[N];//A[i]记录原数据,S[i]为A[i]的前缀和数组LL n,sum = 0,avg,res;int main()&#123; scanf("%lld",&amp;n); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;A[i]); sum += A[i]; S[i] = S[i-1]+A[i]; &#125; avg = sum / n; for(int i = 1;i &lt;= n;i++) &#123; C[i] = S[i-1]-avg*(i-1); &#125; sort(C+1,C+1+n); for(int i = 1;i &lt;= n;i++) &#123; res += abs(C[n/2]-C[i]); &#125; cout&lt;&lt;res; return 0;&#125; 第一次做题的思路那么，显而易见最后每个点的结果一定是Ā每个点起初都是Ai，结果都是Ā那么我们通过每个点可以得到n个关系式即A1 - X1 + X2 = ĀA2 - X2 + X3 = ĀA3 - X3 + X4 = Ā … An-1 - Xn-1 + Xn = ĀA1 - Xn + X1 = Ā 整理上式X1 - X2 = A1 - ĀX2 - X3 = A2 - Ā…Xn-2 - Xn-1 = An-2 - ĀXn-1 - Xn = An-1 - ĀXn - X1 = An - Ā 感觉跟差分数列差不多的样子于是我们从最后一项依次递加i项比如最后两项相加可以得到X2 = X1 - ((n-1)Ā - An - An-1 -…- A2)最后三项相加可以得到X3和X1的关系依次类推我们可以得到Xi与X1的一个线性关系从而我们可以把所有的Xi转换成X1+Ci继续进行求解 继续整理Xn = X1 - (Ā - An)Xn-1 = X1 - (2Ā - An - An-1)…X2 = X1 - ((n-1)Ā - An - An-1 -…- A2)X1 = X1 于是我们要求的|X1| + |X2| + |X3| + … + |Xn|可以转换成|X1 - C1| + |X1 - C2| + |X1 - C3| + … + |X1 - Cn| 即转换成在直线上求一点X使得X到C1,C2,C3,…,Cn的距离最小 其中C1 = Ā - AnC2 = 2Ā - An - An-1…Cn-1 = (n-1)Ā - An - An-1 -…- A2Cn = 0 可以发现其中的一个递推关系就是Cn - Cn-1 = Ā - An-1又C1 = Ā - An我们可以根据这个递推关系求出所有的Ci然后再对Ci从小到大排序找到Ci的中间的点就是使得它到其他Ci距离之和最小的点 注意点1.数列最好从1开始方便计算2.当数列从1开始的时候，中间点即为(n+1)/2，需要+13.数据可能爆int，所以要用long long 长整形表示结果 总结这题是AcWing 104. 货仓选址的一个进阶题目，或者说是区间选点加了一个套子难点在于我们在考试的时候如果遇到这种题很难静下心来去分析出题目的数学模型并进行进一步的整理所以需要我们多做题多总结模型才行啊（ 代码如下：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000000 +10;typedef long long LL;int A[N],C[N],S[N];//A[i]记录原数据LL n,sum = 0,avg;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;A[i]);//数据范围较大最好用scanf进行输入 sum += A[i];//计算所有糖果的和 &#125; avg = sum / n;//计算糖果的平均值 int k = 1; C[k] = avg - A[n];//初始化，C[1] = Ā - An for(int i = n;i &gt; 1;i--) &#123; C[k+1] = C[k] + avg - A[i-1];//根据Cn - Cn-1 = Ā - An-1递推关系来算出所有C[i]的值 k++; &#125; C[n] = 0; sort(C+1,C+n+1);//对各个点到原点的距离进行排序 LL res = 0; for(int i = 1;i &lt;= n;i++) &#123; res += abs(C[(n+1)/2] - C[i]);//找到中间的那个点再计算到其他个点的距离之和 &#125; cout&lt;&lt;res;//因为数据保证一定有解，所以我们直接输出res return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mergeSort]]></title>
    <url>%2F2020%2F02%2F01%2FmergeSort%2F</url>
    <content type="text"><![CDATA[归并排序模板今天是第四天！ 归并排序的三个要点1.确定分界点 mid = l + r &gt;&gt; 12.递归排序 然后分成左右两个部分继续递归3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余然后再赋值给原数组 *注意点merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return; 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100010;//归并排序的三个要点/*1.确定分界点 mid = l + r &gt;&gt; 12.递归排序 然后分成左右两个部分继续递归3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余 然后再赋值给原数组* 注意点 merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return;*/int q[N],tmp[N];//设一个额外的tmp数组来int n;void merge_sort(int q[],int l,int r)&#123; if(l &gt;= r) return ;//当区间里面的个数为1个或者没有的话就直接返回 int mid = l + r &gt;&gt; 1; merge_sort(q,l,mid); merge_sort(q,mid+1,r);//把原数组分成左右两边然后继续归并排序 int k = 0,x = l,y = mid+1;//k为tmp里面有几个数 while(x &lt;= mid &amp;&amp; y &lt;= r) &#123; if(q[x] &lt; q[y]) tmp[k++]= q[x++]; else tmp[k++] = q[y++]; &#125; while(x &lt;= mid) tmp[k++] = q[x++];//如果还有剩余的就存放进tmp数组里面 while(y &lt;= mid) tmp[k++] = q[y++]; for(int i = 0;i &lt; k;i++) q[l+i] = tmp[i];//把tmp数组里面的数重新赋值给原数组&#125;int main()&#123; cin&gt;&gt;n; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;q[i]); merge_sort(q,0,n-1); for(int i = 0;i &lt; n;i++) printf("%d ",q[i]); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binarySort]]></title>
    <url>%2F2020%2F01%2F31%2FbinarySort%2F</url>
    <content type="text"><![CDATA[四个常用的二分模板第三天 二分查找的条件判断如果1 2 3 4 4 5 6 7我们如果想找到大于4的最小的那个数，即num[mid] &gt;= 4都得满足条件才行同理找小于4的最后一个数就是num[mid] &lt; 4，使得num[mid]所有的数都得满足小于4这个条件才行 代码如下12345678910111213141516171819202122232425262728293031323334353637383940int main()&#123; int num[9] = &#123;1,2,3,3,4,4,5,5,7&#125;;//测试数据 int L = 0,R = 8; int target = 5;//求小于等于target的最后一个数的下标 while(L &lt; R) &#123; int mid = L + R + 1 &gt;&gt; 1; if(num[mid] &lt;= target) L = mid; else R = mid - 1; &#125;//求大于等于target的第一个数的下标 while(L &lt; R) &#123; int mid = L + R &gt;&gt; 1; if(num[mid] &gt;= target) R = mid ; else L = mid + 1; &#125;//小于target的最后一个数的下标 while(L &lt; R) &#123; int mid = L + R + 1 &gt;&gt; 1; if(num[mid] &lt; target) L = mid ; else R = mid-1; &#125;//大于target的第一个数的下标 while(L &lt; R) &#123; int mid = L + R &gt;&gt; 1; if(num[mid] &gt; target) R = mid; else L = mid + 1; &#125; cout&lt;&lt;L; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个看起来很复杂的组合问题用dp求解]]></title>
    <url>%2F2020%2F01%2F31%2FAcWing1214-dp%2F</url>
    <content type="text"><![CDATA[AcWing1214. 波动数列Day3，striving 题目 输入输出样例 分析思路分析题目的大意一开始分析这道题咋一看是个序列模型，但其实是个组合模型因为可以肯定的是第一个数是不变的设为X那么数列即为X X+d1 X+d1+d2 X+d1+d2+d3 … X+d1+d2+…+dn-1其中di = {+a,-b}整理可得nx + (n-1)d1 + (n-2)d2 + … + dn-1 = S转换后 x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n 则当S和di确定的时候x是一定确定的任何一个满足要求的合法序列对应一个d1到dn-1的取值，反过来也成立这是一一对应的关系 即原序列不同的方案数，等于所有d1到dn-1合法的取值的方案数 转换题目转换为求所有满足要求的所有d1到dn-1所有取法的方案数那么满足的要求是什么？1.di为+a或者-b2.因为x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n 那么S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]即有多少种选法的d1到dn-1的取值代入序列之和对n的余数等于总和S对n的余数 用dp的思路去求解问题状态的表示这道题目就相当于一个组合问题，可以相当于背包问题来做分析状态应该用两维去表示f[i,j]状态对应的集合即为所有从前i个数(前i个di)，且当前总和(总和即表示代入[(n-1)d1 + (n-2)d2 + … + dn-1])除以n的余数的方案的集合属性应该为数量 状态计算f[i,j]考虑最后一步，抓住最后一个不同点最后一步有两种情况因为最后一步是+dn-1有可能是+a,也有可能是-b d1 + d2 + … di(+a)d1’+ d2’+ … di(+a)不管前面的di是多少,di都为+a所以可以所有先去掉这个最后这个di去掉之后就相当于只考虑前i-1项，然后代入(n-1)d1 + (n-2)d2 + … + dn-1但是为了方便我们变换成d1 + 2d2 + … + (n-1)dn-1 (一一对应)(不换也可以)假设前i-1项的原序列和为C则有C(mod n) + ia(mod n) == j(mod n)即 C(mod n) = (j - ia)(mod n)即f[i,j] = f[i-1,(j - ia)%n] 同理当di = -b时f[i,j] = f[i-1,(j + ib)%n] 注意点1.凡是问满足要求不同选法的数量或者最大值时，都可以用以上类似的背包问题的模型2.这题不能用dfs来做因为长度n为1000，dfs时间复杂度为2^1000，不予考虑3.这个题取模的时候有可能为负数那么需要把负余数转换为正余数所以需要写一个函数get_mod4.S的范围包含负数,所以最后不能直接写S%n，也应代入get_mod函数中5.初始化f[0][0] = 1，表示当一项都不选的时候方案数为1，一项都不选代入原序列和为0,0对n取模的余数也为0 结论最后把f[i][j]所有的方案数都求出来最后对应的f[n-1][get_mod(s,n)]即为结果因为S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]所以j = get_mod(s,n)时候对应的方案数为我们所求的结果因为对应的最后一项为dn-1所以i = n-1，表示前n-1项 代码如下：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int maxn = 1010,MOD =100000007; int n,s,a,b;int f[maxn][maxn];int get_mod(int x,int y)//因为x有可能为负数，那么我们取模的时候需要加上y再取模得到正余数&#123; return (x % y + y) % y;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; f[0][0] = 1;//初始化，当一项都不选的时候方案数为1 for(int i = 1;i &lt; n;i++) &#123; for(int j = 0;j &lt; n;j++) &#123; f[i][j]= (f[i-1][get_mod(j-a*i,n)] + f[i-1][get_mod(j+b*i,n)]) % MOD; &#125; &#125; cout&lt;&lt;f[n-1][get_mod(s, n)];//注意S也有可能为负数 return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由两个简单dp组合而成的复杂dp问题]]></title>
    <url>%2F2020%2F01%2F30%2FAcWing1212-dp%2F</url>
    <content type="text"><![CDATA[第二天，坚持。 题目 分析题目题目有两个限制1.只能往右或者往下走2.一定要按照递增的顺序取物品3.一共要恰好取K件 数据范围n和m都为50所以这个题的维度可能比较多 分析f里面一定要有两维i,j来存坐标如果还要存当前取的数的坐标那么就会有四维了这是一个不明智的行为但是我们发现所有数的大小很小，才0到12，有很强的限制所以不需要存最后一个数是哪个数，只需要存最后一个数是多少就行了还有一维就是存最后一个取的物品价值是多少即f[i,j,k,c]前两维表示坐标,k表示当前取多少件,c表示取最后一件的价值是多少 计算时间复杂度50*50*50*12*13 = 390000用最多的时间复杂度10^7/390000约等于25即状态转移的计算量(大概还可以再循环一次)所以大概是五重循环的样子，前四重是状态，还有一重是状态的转移 y氏dp分析法分析dp问题 分为四种情况两大类AB分析最后一步A最后一步从上往下走 B最后一步从左往右走然后A B两类又可以继续划分A：A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品B：B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品 考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的对应的C应该从之前已经选取k-1个物品中最大的价值C’，这个时候直接从0到V进行循环相加即可 对应的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;/*分为四种情况两大类AB分析最后一步A最后一步从上往下走 B最后一步从左往右走然后A B两类又可以继续划分A：A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品B：B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的对应的C应该从之前已经选取k-1个物品中最大的价值C`*/const int N = 51,MOD = 1000000007;int f[N][N][13][14];//f[i,j,k,c]int W[N][N];int n,m,k;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; cin&gt;&gt;W[i][j]; W[i][j]++;//所有物品的价值都+1 &#125; &#125; //初始化 f[1][1][1][W[1][1]] = 1; //取第一件物品 f[1][1][0][0] = 1; //不取第一件物品,这里初始化C为-1其实更好理解,因为C的范围是在0到12，也就是说有可能为0 //取-1表示没取第一件物品，所以C初始化为-1，后面所有的物品价值都会大于-1 //但是数组下标最好不取负数，所以把所有的物品价值W[i][j]都++，第一件不取C初始化为0 for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; if(i == 1 &amp;&amp; j == 1) continue;//已经初始化 for(int u = 0;u &lt;= k;u++)(u和v都是从0开始的) &#123; for(int v = 0;v &lt;= 13;v++) &#123; int &amp;val = f[i][j][u][v];//用一个val做别名免除很长的f[i][j][u][v] val = (val + f[i-1][j][u][v]) % MOD;//每加一次都需要取模 val = (val + f[i][j-1][u][v]) % MOD; if(u &gt; 0 &amp;&amp; v == W[i][j])&#123;//因为要取出一件来，所以u必须大于0(保证u-1大于0)，且只有当C对应的为W[i][j]时才能取出这一件来 for(int c = 0;c &lt; v;c++) &#123; val = (val + f[i-1][j][u-1][c]) % MOD;//因为MOD为1000000007，那么最多只能加两个数取模，否则有可能爆int val = (val + f[i][j-1][u-1][c]) % MOD; &#125; &#125; &#125; &#125; &#125; &#125; int res = 0; for(int i = 1;i &lt;= 13;i++) res = (res + f[n][m][k][i]) % MOD;//最后再把走到[n,m]取了k个数，价值从1到13(因为之前把W[i,j]都加了1)每个相加再取模得到最后的结果res cout&lt;&lt;res; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维前缀和]]></title>
    <url>%2F2020%2F01%2F29%2FAcWing796-TwoDimensionOfSum%2F</url>
    <content type="text"><![CDATA[二维前缀和 什么是前缀和？前缀和的定义:对于给定的数列A，它的前缀和数列S是通过递推来求出来的部分和即S[0] = A[0];S[1] = A[0] + A[1];S[2] = A[0] + A[1] + A[2];…S[n] = A[0] + A[1] + A[2] + … + A[n]; 这样做有什么好处？对于一个数列来说，我想求从下标m到n这一个区间的和如果不处理的话一个一个累加A[m] + A[m+1] + … + A[n]需要O(n)的复杂度我如果询问n次那么每次都要累加n次时间复杂度就是O(n^2) 很显然，如果每次询问的区间有重叠的话那我们每次都要累加多余的次数这个时候我们就要想办法去消除这种多余的步骤来降低我们的时间复杂度 于是我们可以提前预处理数组，取一个前缀和数组来存放数列的前缀这样，如果要求区间[m,n]的和的话值为S[n] - S[m-1]通过预处理把时间复杂度降到了O(1) (用前缀和数组存放也是一种空间来换时间的思想) 这便是一维前缀和的情况但是如果我们遇到了二维的情况应该怎么办呢？ 下面来用一个例题来为讲解二维前缀和 二维前缀和传送门 题目： 输入输出样例 从例题给的数据开始举例当前的二维数组(前缀和数组的下标统一从1开始)原数组A[i][j]表示存放原始数据二维前缀和数组S[i][j]表示从A[1][1]到A[i][j]这个矩阵的所有的和 怎么求二维前缀和数组？ 假设我想求[2,2]这个点的二维前缀和可以利用容斥原理即图中的两个黄色部分(黄色部分包括那个小的蓝色部分)中间那个蓝色部分被加了两次所以要减去最后剩下那个白色部分A[2,2]加上即得到了整个二维前缀和 用代码表示即s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; 计算了二维前缀和接下来就要计算子矩阵的和了假设我要计算从[x1,y1]到[x2,y2]这一部分的前缀和同样利用容斥原理大的矩形S[x2,y2]减去y1旁边的小矩形(黄色部分)s[x2,y1-1]减去x1旁边的小矩形(黄色部分)s[x1-1,y2]最小的那个部分减去了两次需要重新加回来s[x1-1,y1-1]即s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] 代码如下1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1010;int a[maxn][maxn],s[maxn][maxn];int n,m,q;int x1,y1,x2,y2;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; scanf("%d",&amp;a[i][j]); s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];//计算二维前缀和 &#125; &#125; while(q--) &#123; scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf("%d\n",s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]);//从二维前缀和计算子矩阵的和 &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记念自己的21岁。]]></title>
    <url>%2F2020%2F01%2F22%2F20200122%2F</url>
    <content type="text"><![CDATA[一个旁观者的自我陈述不知道自己在写什么东西…可能自己观察自己也是很难的一件事吧。不经意之间，又来到了一个我自己特别熟悉但是又不想去面对的日子——1.22 没错，原来自己又老了一岁啊(叹气)，从去年正式20岁的那股兴奋劲，一年之后自己并没有多少变化，反倒每天过的更加颓废、更加消沉，人生好像也早已没有了奋斗的目标 可能是我潜意识地觉得自己老了吧，我本身的心态也不好，面对各种事情想的并不是如何去挑战如何去解决，反倒是心底里先一步就胆怯了，我，好像真的变了吗？ 原来的我是个多么自信的一个人呐，做什么也不服输，不相信自己的能力比任何人差。但不知道从什么时候开始，慢慢的，我就好像失去了那股奋斗的动力，失去了那种自信，在潜意识里面接受了不如别人的事实渐渐地，我开始变得逐渐内向了起来，不喜欢说话，不喜欢去交朋友，不喜欢和陌生的人接触交流，整天活在自己的小世界里面没错，在现实里面我可能是一个非常喜欢自闭的人吧，平时跟室友之类的人接触也只是表面应和下，学校里面说实话也没几个真正能够称得上朋友的人 不过在网络里面我却表现的很活跃，认识了不少朋友，平时能够一起说笑其实是一件很开心的事情，既然现实里面没有性格类似且兴趣相近的人，那么只有网上才能够把我们聚到一起了，但是这样做最后导致的结果就是我和很多我以前的好朋友都失去了联系，尤其是我的初中同学们，他们大多都在优秀的大学里面不断的提升自己，随手转发的说说其实都时刻鼓舞着我要像他们学习，我也挺向往他们那样的生活的，不论是网上还是现实之中都活的挺开心的，我从心底里羡慕别人，但是却又迟迟不敢自己去行动，去改变自己，没错，可能是我太在意别人的看法了吧，准确的说是不是那么熟的人面前我不太敢表现自我，只有关系特别好的人面前我才敢把自己真正的性情展现出来，所以口嗨确实很爽但是落实到实际行动里面我还是不太行qwq 不说废话了，多立flag然后贴到墙上才能时刻提醒自己吧就像看到一个up主所说的，“坐在一个沙漠里面，周围没有人，就会感到自己非常的渺小，希望新的一年自己能够在b站这个平台上不再渺小”然后今年他真的做到了，拿到了百大，也突破了百万粉而他今年立的一个个flag，也全都实现了这实在是太鼓舞我了，看着自己喜欢的up从默默无闻到现在这样的成就，而自己依旧没有什么变化这种心态是很复杂的，但是也给予了我一个不断前进的动力吧！我也希望能够收获更多，收获友情乃至爱情是我不断向往的事情。 新的一年，希望在知乎这个平台变得不再那么渺小吧！一起加油！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认真你就输了]]></title>
    <url>%2F2019%2F12%2F25%2F2019-year-end-summary%2F</url>
    <content type="text"><![CDATA[随便写一点东西先占个坑，这几天慢慢把年度总结写一下吧！这一年有过遗憾也有过精彩的时刻，有过欢乐也有过失落的时候，我想好好地写一写今年的感受。 致终将逝去的20岁。 看了看自己去年写的一些东西，真的是笑了出声，明明有很多事想去做也明明有大把的时间为什么会变成这样子呢看着自己慢慢变老一无所有，看着别人应有尽有呐呐，这真的是你想要的么？ 一条一条的来说，不想回避也没啥不好意思的，我的脸皮已经很厚了(bushi 1.每天坚持刷算法题，刷完洛谷提高组的题目 这个确实是没有坚持下来，有的时候甚至一个星期都没有做几道算法题。未来打算就是去每天参加leetcode上的周赛和双周赛以及洛谷上的相关题目反正2020年一定要好好坚持下来！ 2.学习C++，java什么的 咳咳，这个目标和我当初想的差距比较远，去年的这个时候还没有意识到现在该干嘛，C++和java其实两个学好一个就行了，所以明年会继续学好C++呢 3.学习前端三件套(html+css+js) 这个本来在寒假我其实就学的差不多了，但是大半年没用了估计也忘得差不多了，所以给我的启示就是你决定做什么事情一定要经常去做去练去刷题去实践才行吧。 4.每天学习英语,6月一次性过6级 每天学习英语这个还是没有坚持下来，但是6月份确实一次性的过了六级还是让我很开心吧，但是考的分数并不高，12月份准备刷分来着但是也没有好好的去准备只是又裸考了一次，嘛，明年要坚持每天学习英语并且养成阅读的习惯，重点准备考研英语吧。 5.每周刷数学一题目，准备考研 这个确实没有坚持下来，嘛，我对数学还是有自己的一份热爱的吧，虽然没能坚持下来，但是明年可能需要我重新找回那一份的感觉吧。 6.准备CCF和PAT的比赛 这个今年没有准备，但是明年三月份准备去考PAT,CCF以后有机会也会去考虑吧 7.学习LINUX 这个其实很早就开始计划要学习了，但是一直没有学习上的动力驱使着我去学习这个所以只是下了个虚拟机装了Ubuntu但是还没有开始学习，明年大概没时间去学习，但是未来有时间一定会去接触的。 8.玩单片机或者树莓派 硬件方面本来准备接触的，但是今年居然一直没抽出时间去接触去了解，但是明年还是专注于软件方面，先把基础知识先补齐全再说吧。 9.准备数模比赛，微信小程序比赛之类的 数模比赛是没机会去参加，因为如果要参加的话学校就会强制要求暑假参加集训并且还要参加两轮考试才能被参加，我真的不想再吐槽这学校官僚主义有多严重了，反正就是跟我的计划冲突我也不想去强制参加什么集训反正国赛是放弃了，美赛也没精力去参加了，其实挺遗憾的，只能在其他方面补救了。 微信小程序比赛这个最后不了了之了，不想再说了。 总之以后如果下定决心去参加什么比赛的话就一定要坚持到底，所以明年的目标我会考虑的很清楚，不会给自己定很多没意义的目标。 嘛，总之花了两天时间回顾了自己今年立下的一个个flag，明天再来回顾下今年自己发生的各种事情吧！ 去年的事不想再回忆了，不过在我脑子里也真的没什么事能够留下印象，有印象的就是一开年元旦给我发的比赛证书，过年时豪情万丈，上半年课少的轻松，暑假结识了一个志同道合的大佬然后又碌碌无为的情况还有十月份出去旅游的开心以及不烦恼和十一月份的校赛，还有十二月份到今年初复习周的痛苦。 嘛，原来一年的事情一句话就能说完嘛，说明19年真的是很没有激情、很没有意思、很没有动力，20岁最黄金的开头就这么被我浪费了，剩下来的时间可要好好珍惜才行，呐。 过去的就让它过去吧，就像昨天回到家跟家里聊起了过去种种的遗憾种种的失落，都在懊悔着当初我该怎么怎么样现在也不会这个样子但是，已经没用了啊哈哈，虽说我人生的遗憾确实挺大的，我还是有信心在未来能够填满我当初失去的，以及没有得到的，我统统都要拿回来才行呢。 嘛，现在再回头来看看自己4月份建博客以来的日记，简直个个都是黑历史一般的存在(雾)，就像再看那年今日的说说一样，都会感觉当初自己都好傻好笨 其实我自己的文笔一直都不算很好吧，第一我本来就不喜欢写东西，其次就是我也不喜欢表达自己的感情，最后导致了我也不太会写文章，有的时候逻辑什么的都不太清晰看知乎上别人都一条一条特别清楚就感觉自己差距真的挺大的。 嘛，不过我自己心里清楚我缺少最多的东西就是自信，嘛，在之前的博客里面写的很多东西其实也很多都透露出来了这一点，不自信-&gt;不敢表达自己的想法-&gt;有各种各样的担忧-&gt;不去行动-&gt;自闭，形成了一个循环了 就像有个朋友有一天跟我说，“你啊，整天把自己关在心里，一个人在角落默默努力，看上去比我还孤独比我还自闭”，当场瞬间就哭了 是啊，谁会喜欢孤独呢？谁喜欢一个人天天自闭，想找人说话都不能，我体会不到那些真正享受孤独的人的那种感受，我不希望我能有一天能够体会到，一点也不。 我也想和朋友们一起说说笑笑，一起去吃饭，一起去唱歌，一起去看电影 其实初中之前我是一个挺开朗的人，有一大堆优秀的朋友能够交流，那时的我也不胖甚至还有点小帅，如果你说当时的我能够成为我现在的样子，可能没有一个人会信吧然后高中是一个黑暗的三年，大学也不在我满意的范围里面，然后整个人就越来越内向越来越自闭，不喜欢和外人说话不喜欢到现实里面和别人交流，只喜欢在网上和别人打字，网络可能是我最后的稻草了吧，在这里你也看不到我我也看不到你，大家都能放下戒心来聊天，其实我挺享受的，所以现实中的我和网上的我是两个人，我不希望这两者能够产生任何联系，也不希望有人能够同时认识这两个我，除非是特别特别亲密的人，我的戒备心其实也挺重的。 不过现在的我也没多少人关注就是了，归根到底还是什么样的水平认识什么样的人，反正我是这样的观点，我觉得自己当前的层次水平达不到平均水平，需要花时间去沉淀自己才行，所以我不喜欢去结交朋友，但是并不代表不想认识优秀的人，如果有人来找我我还是很乐意接受去分享给你我曾经的故事以及每天的喜怒哀乐，其实如果兴趣相投的话，每天其实能有一堆话可以说的。 心里话想说的差不多也都说完了，接下来还是好好想想今年该完成的几个目标吧上半年大概的目标1.准备三月份的pat 2.准备四月份的蓝桥杯 3.准备上半年学校的天梯赛 4.确定考研的学校、专业、方向，并开始准备初试 全年坚持的目标 1.坚持每天一道leetcode/洛谷/其他OJ 2.日常更新回答or文章 3.开始接触做视频 4.坚持写日记 5.坚持每天学习英语，坚持每天两道数学题 嗯…暂时想到的就这么多吧，等完成了某个目标之后我会及时更新的，等回了学校我也会写一份贴墙上，就先写这么多吧。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191216]]></title>
    <url>%2F2019%2F12%2F16%2F20191216%2F</url>
    <content type="text"><![CDATA[都好起来了呢最近一直都在发生好的事情，而且是一连串的发生，好像并不算是巧合呢。上个星期三的早晨，本来是很平淡的一天，我还在漫不经心的复习着英语，突然知乎上有人私信我. 本来以为又是知乎管理员之类的私信，正想把碍眼的那个消息的小红点给按掉的时候. 原来是那个人重新注册知乎然后发现了我留下的呼唤重新找到了我一瞬间，开心激动的心情瞬间充满了我的脑海里面. 可能这就是所谓的缘分所谓的幸福吗？ 当你发现原来曾经做过很多不可挽回的事情突然发现有了新的转机的那种感受，真的很难言说出来. 再重新看看几个月前自己写下的怨恨的话，写下的种种不满，在现在看来是多么的幼稚多么的可笑，也许人不经历点事情是不会成长的吧. 所以以后我也不会说自己多么多么的成熟，因为在很多事情面前自己都还只能够算是一个孩子罢了。希望今后能够不断的进步不断的成长吧. rebegin]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191209]]></title>
    <url>%2F2019%2F12%2F09%2F20191209%2F</url>
    <content type="text"><![CDATA[炒鸡开心的两天！！！！！好开心好开心好开心啊，这几天发生的事情让我从心底里感受到了什么叫做真正的快乐，虽然在别人眼里看来可能真的没什么，但是对于我来说确实算是一个挺不错的经历了吧 先说说比赛的相关的事情吧，从二十多天前就知道了校赛要来了，原来的我对待这种事情都是特别犹豫的，各种各方面的原因都会困扰着我不敢勇敢的做出最终的选择正因为如此，我可能在大学这两三年的过程中错过了一个又一个的机会吧，比如上个学期本来是有机会去参加我喜欢的社团来着，但是当时我觉得自己已经大二了，已经错过了最好的加入的机会了，然后我就没去参加，但是我的室友去参加了，然后我只能眼睁睁的看着我的室友在社团里面交到好多朋友，认识到好多大佬，现在想想还是后悔的要死，因为大学明明有这么多的人，我却没机会认识到别人(潜意识里面我是觉得交朋友的话至少要到同一个水平上，不然很容易就躺列了之类的，这并不是我想要看到的结果)，可能我就是这么一个人吧，不满足自己的现状希望不断改变来提升自己，可能只有自己哪天成为了自己心目中想要成为的人我才会停止脚步吗(但很明显不会有那么一天) 咳咳，还是回到正题上来吧，我不想再错过这一次校赛的机会，不管我多老不管我多捞，我希望大学里面能够尽可能的多参加比赛啊，错过了现在的机会等我真正老了哪还会再有能够拼搏的机会呢？ 于是我选择了参加，和一个朋友再拉了一个他的同学我们三个人于是便组成了一个队伍，在前半个月里面我们并没有在一起配合着练习，而是在图书馆里面选择了自己提升自己，虽然现在看来我在这半个月准备的时间还是有所不足，在学习的过程中最大的感受就是一定要做笔记才行，因为很可能你半个月前学过的东西你半个月之后再看就完全不懂了，现在就是我之前暑假学过的很多知识点我现在再看又完全不懂了，等于我的暑假相当于白费的感觉，不仅是今年的暑假，以前的两年也是差不多的这样子，养不成每天学习每天刷题的习惯，也就是半途而废的那种，每次都是等到期中或者期末考试就要中断一段时间的学习，然后长时间不去刷leetcode或者洛谷之类的OJ就完全不习惯了，然后过半个月就又傻眼了所以这次我不想再重蹈覆辙了，因为留给自己的时间也不多了，12月到寒假结束的2月可能是我最后提升自己的机会了，也许人都是到了最后的关头才会急的人吧，再过一年零半个月不到的时间就是我去考研的时间了，当那种限期到来的时候的感觉是真的很煎熬，我希望我每天能过的充实起来，不仅只是在学习上，也可以在很多其他方面上呢，比如写写日记，刷刷知乎答答题之类的亦或者做做自己喜欢的视频啊，我觉得都是很有意义的事情呢~~那种感觉就好像是真正的找到了自己人生目标的感觉，虽然我现在还没有真正的意识到自己真正喜欢哪个领域的内容，但是我平时喜爱的东西已经能够让我兴奋起来了，也能够从中学到很多东西，这种东西这种感觉果然是别人教不来的，也许恋爱也会是这种样子吗(我到底在想什么啊) 诶多，好像又偏题了呢，咳咳，到了比赛的前三天我们才正式见面，第一天更是只匆匆的认识了下，然后第二天和第三天我们打印了试题去模拟了下试题，虽然模拟的感觉让我们感觉自己的水平还不太够，但是也别无办法了，毕竟只有短短的三天供我们去模拟了 然后就真正到了昨天的比赛日了，还是挺难忘的一天吧！早晨七点就被昨天已经约定好的老爸打电话把我叫醒，醒的时候整个人的精神状态还算是不错吧，前一天十一点左右就睡着了(幸好我的室友还算是好说话的人，要按照平时估计要开黑开到十二点之后，但我这次说了明天有比赛的话他们就挺安静的了) 诶多，然后就起床了，肚子巨不舒服，去上了厕所之后还是不太舒服，这个不适感一直伴随到我比赛临近开始都没有消除，和同学一起去了比赛的场地拿了参赛证，还有个吊牌(看起来还蛮正规的，好歹也是个校赛吧)算是个参加比赛的证明了，就算没得奖的话(我这么想着，起码不要报名费吧)，然后等到开幕式了，开幕式上真的是好多大佬啊，还有大佬代表来发言(这就是我想要的目标啊)，他们在自己的专业去参加比赛不仅提升自己的水平，为自己将来的发展铺平了道路，而且还很可能能够得到保研的资格，是我梦想中想要的生活(还是当初吃了选择的亏，这点深有体会以后有机会再聊聊吧) 从开幕式上我了解到一共有将近一百五十支队伍四百多个人来参加这个比赛，这个队伍在我看来是有点多了，不过我也并没有害怕，反倒是觉得越来越有意思了，想看看我跟别人队伍的差距到底在哪，嗯，然后就进了机房去调试机器了，上午的热身赛真的是让我一言难尽，三道题目其中两道题考到了素数，还有一道题考到了脑筋急转弯，我对素数什么的还不算很熟悉…欧拉筛什么的，反正就是很难受，但是已经到了比赛的那天了也顾不上那么多了。 十一点一起去食堂去吃饭，下午一点就要开始比赛也不敢吃太多，毕竟肚子还不是很舒服了，点了个小份的大盘鸡也没吃太饱就回宿舍了，十二点差一刻戴耳机睡觉，一直趴到了十二点半，没睡着，戴着耳机懵懵地趴了半天，然后洗了个脸清醒了，于是和队友就直接去比赛的场地了。 到了上午调试过的位置以后，周围已经是有很多人了，那种气氛有点压抑但是也没什么办法只能硬着头皮上了，嗯，很平静的就宣布比赛开始了，发了三本题目的册子和比赛账号，于是我们便开始为期四个小时的比赛了，一开始我从后面的K题开始看，然后其他人从前面的A题开始看，我们看到了几道签到题，于是我开始写K题到OJ上，可惜出事不利，我好像忘了特殊的情况，直接上来WA呜呜，队友刚开始也看着很不开心的样子，又试了一次继续WA，吓得我赶紧退下主位来给大佬去坐，自己赶紧装装样子去看别的题(其实当时心里是有点不开心，毕竟开门”红”确实让人很难受)，好在后来我们及时调整了状态，先就把签到题全部A了，然后再去思考那几题还有点思路的题，具体的过程就不细说了，反正过程算是很惊险的，其中最重要的就是两道重要的题我们A出来了，一道是C题一道是E题，虽然我自己A了E，也给大佬提供了C题的思路，我觉得我在这次比赛里面的功劳勉强还算大吧_(:」∠)，但是没有大佬的帮助我觉得我们这次连二等估计都莫得嘤嘤嘤，其中最遗憾的就是本来如果时间策略好一点我们其实可以再A出一道题就能拿一等奖甚至第一了(还是有点耿耿于怀噫)但是总体上的结果也算是让我满意了吧，起码也不枉费我这几十天的努力吧！最后朋友还请了我们俩吃了顿饭，我觉得这顿饭可能是最温馨最香的一次饭吧，毕竟是用我们共同的努力所换来的。 说完了第一件比赛的事，第二件事可能就是蓝桥杯报名的一件事了吧，这件事也是让我整整难受了一个多星期吧，以为这个比赛是个人都能随便报的，结果还是要院校一起报名，但是众所周知我的专业是不负责这个比赛的，结果就是我只好去通过别的院的老师去报名，但是别的院的老师告诉我要去找自己院负责竞赛的老师去联系才行，但是我那个专业又没负责这个比赛的，所以就非常的矛盾，然后拖了几天吧，好多人互相推皮球好像都不想负责(三百多的报名费都不想赚真的是)好在今天终于是解决了，真心想感谢那个组委会老师，虽然是被规则所限定了，但是一直在给我想办法，给了我好几个老师的电话去主动拨打去联系，简单的一句“不行再来找我”真的是给了我莫名的信心，让我的心非常温暖，虽然在别人看来这可能只是一件微不足道的小事，但是在我很绝望很心塞的时候，组委会老师坚定的承诺确实是给了我莫名的鼓舞，他也从不耐烦语气也很温柔，以后我如果能够成为给别人带来价值，能够帮助他人的人我觉得其实也很棒呢！ 所以，大概这就是这几十天以及这两天发生的故事吧，坚持学习然后心里煎熬了那么就大概也终于到了结束的时候吧，看着自己在日程表上一天一天划日期，虽然没怎么按着自己的计划来进行，但是结束之后再看会觉得自己心里有种很温暖的感觉。没错，既是结束，也是一个新的开始，我从这个过程里面也了解了很多，也学到了很多，对自己最近几年的人生目标萌发了点自己的想法，虽然还不是很清晰，但我相信只要能坚持那些好的习惯坚持自己的爱好，虽然今年立的flag确实没怎么完成，但是我希望，明年的这个时候我能够胸有成竹，意气风发！但是这绝不只是口里说说就能够成功的。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra]]></title>
    <url>%2F2019%2F11%2F30%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[浅谈Djikstra算法前言：前几天在算法笔记上看到了晴神对于最短路径算法Dijikstra的一个深入的分析，我感觉挺感兴趣的，顺便想借此机会来深入分析，顺带也是更新下博客了咳咳，顺带说一句我的博客看起来挺乱的，等有时间会做一个分类吧，但我不想把它变成单纯的一个技术博客，而是记录一个我的学习，生活，感悟，以及展示自己兴趣爱好的地方(虽然现在从哪方面看上去这人都挺low的) 好吧，那就开始我对Djikstra算法的认识吧 从最短路径算法Djikstra初谈什么是Djikstra? 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 这是百度百科上的定义，用我们生活中的例子来讲就相当于我们每天在地图上用的导航，导航可以帮我们在错综复杂的街道上，找到一条从出发地到达终点的最短路径 所以我们需要一个好的算法来干这事，而这种算法就叫做最短路算法(SSSP) 而其中Djikstra算法就是最短路算法中的一种(当然也是最简单的一种) 至于为什么叫Djikstra算法，因为Dijkstra算法是由一个叫Dijkstra的荷兰人发明的，故称此算法为Dijkstra算法。(怎么这么多废话) 好了，那现在进入正题 Dijkstra算法的工作原理？因为这个算法是为了求出来在一系列限制条件下两个地方的最短路径，那么我们一般怎么找到从一个地方到另外一个地方的最短路呢？ 对，我们首先得有一张地图才行啊 就拿我国庆去上海玩的经历来说吧 你现在刚从火车站出来搭地铁到人民广场这个下站了，天色已经很晚了，，但是你突然想走去黄浦江边的外滩去看风景 你可能要问，诶我为什么不继续坐地铁到那个南京东路下站然后再走去外滩啊，这样不是更近吗？(然鹅不幸的是国庆的前几天南京东站的晚上基本上都是被封的) 所以你只能选择走去外滩，当然你不可能像红色箭头这样飞过去了，不然警察叔叔会罚你 $10^{10} RMB的，所以你只能找到合适的道路走过去，也就是说你只能走那些标记为“路”的地方 于是我们就可以把每一个路口或建筑看作一个点，有些点与另一些点之间有边连接，这个边其实就是马路，连结了两个地方。 当然，有些马路的车流量比较大，有些在比较小；于是有的马路通过需要花费的时间多，有的花费的时间少。我们把一条马路通过所需要花费的时间，称作这条边的权值。所有的点和边连在一起，就成为了一个图。(没错如果你想直接从人民广场直接直接走到外滩几乎是不可能的，人流量可以把你窒息死) 图这种东西大概长这样： 一个圆就是一个点，圆上的数字是点的序号，绿色的线是边，边旁边的橙色数字是边的权值。之所以加上箭头，是因为我们假设所有马路都是单行线（双向车道改成两条单向车道不就好了）。 具体的Dijikstra算法的证明过程在这里不再给出，具体的过程可以自行百度好了(其实是我的证明水平还8太行) 但是djikstra算法不适用于有负边权的图，在这里不再赘述(才不会告诉你别人已经有更好的解释了啦) 戳这里 对我的理解来说，Djikstra算法最直观的一个解释就是以起点开始寻找有没有其他中介点能够使起点到达其他顶点的距离能够变小 Djikstra算法的一个伪代码12345678910111213141516bool vis[maxn] = &#123;false&#125;;void Djikstra(G, d[],s)&#123; 初始化 for(循环n次)&#123; u = 使d[u]最小的还未访问的顶点的标号 vis[u] = true;//记下u已被访问 for(从u出发能到达的所有顶点v)&#123; if(vis[v] == false &amp;&amp; 以u为中介点使s到达顶点v的最短距离d[v]更优) &#123; 优化d[v]; &#125; &#125; &#125;&#125; 其中G为邻接矩阵，s为起点 vis[i] == true时表示顶点Vi已被访问，vis[i] == false时表示顶点Vi还未访问 d[]表示起点s到达顶点Vi的最短距离，初始化时除了起点的d[s]赋为0，其余的顶点都赋予一个很大的数(比如INT_MAX或者自己赋一个很大的INF)(即相当于把除了起点与其他顶点的边权确认后，其余各个顶点之间的距离设为无穷大(即INF)，这样可以保证后来各个点的最短距离d[i]都是从起点s得来的) 举一个简单的例子拿一个简单的有向图来举例子吧 起点的d[s] = 0，其余点的d[i] = INF; 开始循环，起点1可以到达点3和点2先把vis[1] = true;下次就不再循环到起点1因为d[1] + weight[1][3] &lt; d[3]所以更新d[3]d[3] = d[1] + weight[1][3] = 3;同理d[1] + weight[1][2] &lt; d[2]所以更新d[2]d[2] = d[1] + weight[1][2] = 6; 继续循环，寻找d[i]中最小的点(即离起点最近的)再开始计算这时候d[3] = 3最小(因为d[1]已经被标记过了不再访问)此时就以点3为中介点，看起点以它为中介点到达另外点的距离能不能变短标记vis[3] = true;此时d[3] + weight[3][2] &lt; d[2]; 3 + 2 &lt; 6(即从1-&gt;3-&gt;2的距离比1-&gt;2的离更小)所以更新d[2] = d[3] + weight[3][2] = 5; 又以点3中介点可以到达点4d[3] + weight[3][4] &lt; d[4]; 3 + 3 &lt; INF此时更新d[4] = d[3] + weight[3][4] = 6; 同理以点3中介点可以到达点5d[3] + weight[3][5] &lt; d[5]; 3 + 4 &lt; INF此时更新d[5] = d[3] + weight[3][5] = 7; 此时还能访问的d[2] = 5,d[4] = 6,d[5] = 7,d[6] = INF;然后继续循环发现d[2]最小，于是再以2为中介点进行寻找vis[2] = true;d[2] + weight[2][4] &gt; d[4]; 5 + 5 &gt; 6此时不更新，由于2只能到达4所以结束循环 此时还能访问的d[4] = 6,d[5] = 7,d[6] = INF;于是以点4为中介点进行循环vis[4] = true;由于点4可以到达点5和点6d[4] + weight[4][5] &gt; d[5] 6 + 2 &gt; 7不更新，继续循环d[4] + weight[4][6] &lt; d[6] 6 + 3 &lt; INF所以d[6] = d[4] + weight[4][6] = 9;然后结束循环 此时还能访问的d[5] = 7,d[6] = 9;以点5为中介点进行循环vis[5] = true;由于点5可以到达点6d[5] + weight[5][6] &gt; d[6] 7 + 5 &gt; 9所以不更新，结束循环 此时还能访问的d[6] = 9;vis[6] = true;最后发现除了6自己以外其他点都已访问过，所以结束循环 最后的结果就是d[1] = 0d[2] = 5d[3] = 3d[4] = 6d[5] = 7d[6] = 9 至此算法结束。如果您人脑模拟出来跟上面的图示有不一致的地方建议您重新阅读本拙文。如果您还看不懂请戳这里。 具体实现的代码，以邻接矩阵作为举例这里是以PAT1003为举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;//最大的城市数//N表示一共有N座城市 M表示一共有M条道路 C1 C2分别表示起点和终点int N,M,C1,C2;bool vis[maxn] = &#123;false&#125;;//定义一个数组来判断城市是否被访问int G[maxn][maxn];//表示城市与城市之间的距离int pre[maxn];//存储前驱结点int d[maxn];//记录最短距离,d[u]表示从起点s到达顶点u的最短距离int weight[maxn];//每个点的权值int w[maxn];//记录起点到每个点的最大权值int num[maxn];//num[u]表示起点s到达顶点u的最短路径条数void dijkstra(int s)//s表示起点&#123; fill(d,d+N,INT_MAX);//把所有点的距离都抹掉 d[s] = 0;//把起点的最短距离设置为0 w[s] = weight[s];//起点开始的权值即为起点的权值 num[s] = 1; for(int i = 0;i &lt; N;i++)&#123; //循环n次 int u = -1,MIN = INT_MAX;//u设置为-1是为了方便当找不到可以连接的点时方便判断,MIN存放最小的d[u], for(int j = 0;j &lt; N;j++) &#123; //找到未访问顶点中d[]最小的顶点,因为从起点开始更新了后面的d[u],然后下次循环就要从这个点寻找能到达顶点中距离最小的那个点 if(d[j] &lt; MIN &amp;&amp; vis[j] == false) &#123; u = j;//找到跟起点相距最短的那个点 MIN = d[j];//更新最短的距离 &#125; &#125; if(u == -1) return ;//如果找不到小于INT_MAX的d[]，意味着剩下的顶点和起点s不连通 vis[u] = true;//标记为已访问 for(int v = 0;v &lt; N;v++) &#123; //如果u能到达v 且 v未访问 -&gt; 则以u为中介点到达v可以使d[v]更优 if(G[u][v] != 0 &amp;&amp; vis[v] == false ) &#123; //当以u为中介点的时候能使d[v]变小 if(d[u] + G[u][v] &lt; d[v] ) &#123; d[v] = d[u] + G[u][v];//覆盖d[v] w[v] = w[u] + weight[v];//更新w[v] num[v] = num[u];//覆盖num[v] &#125; else if(d[u] + G[u][v] == d[v])//找到一条相同长度的路径后 &#123; if(w[v] &lt; w[u] + weight[v])//如果这条路径的点权之和更大 &#123; w[v] = w[u] + weight[v];//更新 &#125; num[v] += num[u];//有相同路径长度,则相加num[u],因为当d[u] + G[u][v] &lt; d[v]时候已经算出一个num[v]是符合条件的 &#125; //那么当d[u] + G[u][v] == d[v]时之前d[u] + G[u][v] &lt; d[v]算的num[v]仍然符合条件,则继续加上现在相等时候的num[u] &#125; &#125; &#125;&#125; 分析算法的复杂度？从复杂度来看，主要是外层循环O(V)与内层循环(寻找最小的d[u]需要O(V)、枚举v需要O(V))产生的，总复杂度为O(V*(V+V)) = O(V^2). 但其实Djikstra算法是可以优化到O(nlogn + m)的级别的为什么？因为必须把每个点都标记为已访问(即vis[i] = true)，所以外层循环的O(V)时间是无法避免的但是寻找最小的d[u]的过程可以不必要一个一个重新循环去寻找最小的那个的d[u]可以通过堆优化来降低复杂度，最简单的做法就是直接用STL中的优先队列priority_queue(STL依赖症) 看了上面的代码你可能已经发现了一个问题，那就是如果题目除了最短路径还有其他的要求怎么办？比如PAT1003里面就要求找到从起点到终点的最短路径的条数以及最短路径的数目之和即最短的路径可能不止一条 于是有三种主要的方式来进行考察①新增边权，即以新增的边权花费为例cost[u][v]表示从u -&gt; v的花费，并增加一个数组c[]，令起点s到达顶点u的最少花费为c[u]同理初始化的时候c[s] = 0,其余均为INF这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和c[v]而当d[u] + G[u][v] == d[v]时且c[u] + cost[u][v] &lt; c[v]时更新c[v](即可以是s到v的最少花费更优时更新c[v]) 样例代码:12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; &#125; else if(d[u] + G[u][v] == d[v] &amp;&amp; c[v] &gt; c[u] + cost[u][v])&#123; c[v] = c[u] + cost[u][v]; &#125; &#125;&#125; ②新增点权，即以新增的点权代表城市能收集到的物资为例，用weight[u]表示城市u中的物资数目，并新增一个数组w[]，即从起点s到达顶点u可以收集到的最大的物资为w[u]，初始化的时候w[s] = weight[s],其余均为0，这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和w[v]而当d[u] + G[u][v] == d[v]时且w[u] + weight[u][v] &gt; w[v]时更新w[v](即可以使s到v的最大物资更优)代码与上面类似不再给出 ③求最短路径条数，只需要增加一个数组num[]，令从起点s到达顶点u的最短路径条数为num[u]，初始化时num[s]为1，其余num[u]均为0这样可以使当d[u] + G[u][v] &lt; d[v]使num[v]继承num[u]而当d[u] + G[u][v] == d[v]时将num[u]加到num[v]上 代码如下12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; num[v] = num[u]; &#125; else if(d[u] + G[u][v] == d[v])&#123; num[v] += num[u]; &#125; &#125;&#125; 鉴于时间关系暂时就先总结这么多，Dijikstra算法其实能扩展的东西还有很多，比如如果题目要求具体的最短路径的话还要另外增加一个记录前驱结点的数组之类的东西，等以后有时间我再来补齐吧!]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191120]]></title>
    <url>%2F2019%2F11%2F20%2F20191120%2F</url>
    <content type="text"><![CDATA[平静的生活也需要心灵的慰藉最近在读吴军老师这几年出的新书《见识》感觉给我带来的东西确实挺多的，不像是豆瓣上别人说的那种鸡汤文吴军老师确实是在用他漫长人生中遇到的种种事例来举例子所得到的一些感悟和体会，比如在谷歌时期工作时候遇到的很多优秀的同事从中学习到了很多优点，亦或者是谷歌的两个联合创始人拉里佩奇和谢尔盖布林的一些故事，从中可以感受到谷歌之所以能取得如今这样的成功，并不是偶然。并把他所遇到的人和事都亲口讲述出来。确实和我的切身体会差不太多，除了没有职场的那些经历，其他的在我不长的人生中其实已经有太多的感悟了。提到“见识”，就会想起高中数学老师给我讲的那句话，我至今仍然时刻记在心中“眼界决定境界，态度决定高度”当时上高中的时候还不以为然，现在真正出来了，到了新的世界才感受到了自己的渺小，自己的无知，然后会产生一种很大的遗憾感，把自己的前几年拿来和那些有见识有眼界的人的来比简直就是可笑 人生需要做减法有的时候我们是不是应该静下来思考一个问题，每天自己到底在忙什么？每天给自己布置那么多的任务到底有用吗？整天下来确实很忙，但是自己真的学到东西了吗？ 我很赞同吴军博士他在这里表达的一个观点，就是我们需要对我们自己的事情做减法诚然，的确有那种每天做很多事还能做的很好的人，但那毕竟是少数。大多数人其实每天能做好一两件事已经达到一个人每天精力的上限了正因为如此，我们需要给自己做减法，吴军博士在书中阐述自己能够成功的原因不是因为很会合理安排时间(当然合理安排每天的时间并不是说一点用也没有)，而是因为他每天少做很多不必要的事情。我们不禁反问自己，自己每天真的需要做那么多那么多的事情吗？难道有些事情不做天就会塌下来吗？仔细想想确实，对于我自己来说，这两三年来确实给自己布置了太多任务了，每天忙来忙去但是其实到头来收获其实没有多少，自己现在的各种意义上的水平和自己两三年刚入学的时候其实并没有多少提升，想想就很惭愧，但是这也从另外一个方面体现出一个人的思考和每天的习惯对一个人的影响有多大，但是这不正是因为自己之前没有多少见识，只会一味的伪努力去感动自己，可能一时确实还以为自己不错，哎呀又不怎么打游戏又不干别的事，但是长期来看伪努力和那些天天打游戏上课摸鱼的又有什么区别呢？还不都是什么都不会，还不如当初好好玩呢(暴论)，所以最后落得个学也没学好，玩也没玩好的尴尬的地步了。所以我特别认同他的话，“人生需要给自己做减法”，不仅仅是学习工作中，其实各种意义上都是如此，每天如果能够做好一两件事并且能够坚持的下来，对于一个人的潜移默化的好处是不可言喻的。但是现在的人可能就是如此，或者说人本身就有一种贪婪的本性，就是什么都想要，什么也不想舍弃，“我全都要”的调侃可能是每个人心中都想要达到的目标，但是现实往往并没有如此的简单，因为本身“做好一件事”其实就已经要花费人大量的时间和精力了，更何况是还要涉及很多领域的知识(当然我在这里针对的是像我这种平凡的普通人来说)对于我来说我其实对很多方面都很感兴趣，政治，历史，计算机，经济，金融，甚至是投资这方面的知识，当然一个人兴趣多是好事，但是也要分阶段分精力去学习才行，对于我来说今年还剩下一个月的时间，明年的这个时候就要准备考研计算机了，对于我来说最重要的东西当然是计算机专业相关知识的学习了，其他的东西都可以放一放，所以我要抓紧时间去学习算法相关的知识，不仅是为了准备半个月之后的比赛，更是为了自己的前途和明年的考研要开始做准备了。道理听起来确实简单，但是很少有人能够真正地自我剖析，能够真正的明白自己当前任务的主次才行，所以很多事都是说起来容易做起来难，这跟平时人们常说的“道理谁都懂”等诸如此类的话罢了，先达到每天能做好一件事的水平之后再去干更多的事情要认识到人的精力和能力都是有限的，尽可能地去做那些捡西瓜的事而不是去捡芝麻，把宝贵的时间浪费在一点微不足道的蝇头小利上，付出和收入实在是不成正比。的确，人的眼光往往是短视的，就跟在a股投资差不多，赚短期赚快钱是一件很爽的事情但同时伴随着高风险，很可能一不小心你就栽跟头了，这个时候人们容易追涨杀跌从而亏得叫苦连天，只有长期坚定不移的投资才能给自己带来合理的回报。同理，做人又何尝不是如此呢，在我的身边其实就有两类人，一类是贪图享受，每天从早到晚都只会打打游戏看看剧聊聊天，日子过得好不自在。另一类就是所谓的伪工作者，每天从早到晚待到自习室感动自己，以为自己很努力，甚至还要发说说发朋友圈作秀，但其实一点用也没有，到头来跟前一类人没多大区别。我们所要避免的就是成为这两类人，提早的认清自己，认清自己将来的目标将来的发展，认清每天应该要做什么事情，哪些是重要的哪些是不重要的 &lt;未完待续…..&gt;这篇blog我会随着这本书的感悟每天都写一点，嗯，也是看完书对自己的一种记录吧，每天都写一点收获和体会，不一定要刻意的去对待，但是把得到的收获每天记录下来警醒自己我觉得是有必要的。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>每天一点小感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1032]]></title>
    <url>%2F2019%2F11%2F13%2FPAT-1032%2F</url>
    <content type="text"><![CDATA[1032 Sharing传送门 题目的大意就是: 给出两条链表,要你找出两条链表第一个相交点如果有相交点,给出相交点地址值,如果没有,返回-1 思路：1.给出两条链表，我把所有的结点都标记为false(或者0)，然后我标记第一条链表的所有点为ture(或者1)，我再从第二条链表开始遍历，如果遇到标记点为1就为相交点，如果没遇到就说明两条链表没有相交点 注意事项：1.这题应该用静态链表比较合适，用map容易超时2.再用静态链表的时候定义maxn一定要大一点,因为数组的index值也很大(比如11111,22222)，否则数组会越界，PAT会报错“段错误”3.最后输出的时候要用print(“%05d”)来输出，因为我是用int型来保存地址的嘛，所以在输入00002的时候他会保存为2，那么我在输出的时候就应该在前面补0才行4.静态链表的next结点不是指针 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;//PATA 1032 Sharing//题目大意：给出两条链表,求出两条链表的第一个共用结点const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125;node[maxn];int main()&#123; int s1,s2;//s1和s2分别为第一二条链表的首节点 int N;//N表示一共有N个结点 cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;N; int result = -1; int address,next; char data; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;address&gt;&gt;data&gt;&gt;next; node[address].data = data; node[address].next = next; &#125; for(int i = 0;i &lt; N;i++) &#123; node[i].flag = false; &#125; for(int p = s1;p != -1;) &#123; node[p].flag = true;//flag为true表明在第一条链表上 p = node[p].next; &#125; for(int q = s2;q != -1;) &#123; if(node[q].flag == true) &#123; result = q; break; &#125; q = node[q].next; &#125; if(result != -1) &#123; printf("%05d",result); &#125; else &#123; cout&lt;&lt;result; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1059]]></title>
    <url>%2F2019%2F11%2F02%2FPAT-1059%2F</url>
    <content type="text"><![CDATA[1059 Prime Factors传送门 题目大意：就是分解一个质因数 思路：如果要分解一个质因数，那么最简单的思路就是从2开始相除，直到不能除尽为止，同时记录除每个质因数的次数，最后按题目的要求输出 所以要几个步骤：1.首先列出一个素数表2.从素数表里面依次相除，并记录每个可以相除质数的次数3.打印的时候要注意最后一个不能有*符号(所以我需要用一个num来记录有多少个不同的质数方便最后打印)4.用一个fac的结构体来记录质数和次数 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;//分解质因数的实现const int maxn = 10001;int prime[maxn],pNum = 0;bool p[maxn] = &#123;false&#125;;void setPrime()&#123; for(int i = 2;i &lt; maxn;i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; &#125; for(int j = 0;j &lt; pNum;j++) &#123; if(i * prime[j] &gt; maxn) break; p[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125;&#125;struct factor&#123; int x,cnt;//x记录质因数,cnt记录质因数的个数&#125;fac[10];int num = 0,n;//num为不同质因子的个数void decomposePrimeFactor(int n)&#123; int temp = 0,i = 0,sum = 0; while(n) &#123; while(n % prime[temp] == 0) &#123; fac[i].x = prime[temp]; fac[i].cnt++; n /= prime[temp]; if(n % prime[temp] != 0)&#123; i++; num++; break; &#125; &#125; temp++; if(n == 1) break; &#125;&#125;int main()&#123; setPrime(); int cmp = 0; cin&gt;&gt;n; if(n == 1) &#123; cout&lt;&lt;"1=1"; &#125; else &#123; decomposePrimeFactor(n); cout&lt;&lt;n&lt;&lt;'='; for(int i = 0;i &lt; 10;i++) &#123; if(fac[i].cnt == 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;'*'; &#125; &#125; else if(fac[i].cnt &gt; 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x&lt;&lt;'^'&lt;&lt;fac[i].cnt; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;'^'&lt;&lt;fac[i].cnt&lt;&lt;'*'; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191007]]></title>
    <url>%2F2019%2F10%2F07%2F20191007%2F</url>
    <content type="text"><![CDATA[上海之旅已经上了两年的大学了，还从来没有好好出去玩过一次，于是一个月前，我就和两个同学计划在国庆7天里面好好出去玩玩，如今已经旅游完回到宿舍，不觉感叹美好时光的短暂，也从这次旅游之中感触到自己的很多不足，也是希望借机会记录一下自己的生活吧，反正自己的blog想写啥就写啥咯，记录一点不一样的东西可以让我的心宁静下来吧。(其实就是想记录记录流水账，让自己记忆还未忘却的时候用文字和图片记录下来，我觉得这也是旅游的意义之一吧，而不是去过了什么收获体会都没有) 9月30日 &amp; 10月1日下午6点的车去魔都，4点后翘掉选修课回去洗了个澡穿了身新衣服就和同学坐地铁去火车站了，随便吃了点什么就上车了 这还是我人生中第一次体验绿皮火车吧，之前从来也只坐过高铁动车之类的，坐火车过夜倒是人生中的第一次，去之前其实心里也有点忐忑不安，因为说实话之前已经在知乎上看到有好多人说卧铺怎么怎么不好，同学也都跟我说里面空气不太好 不幸中的万幸可能就是我在订火车票的时候把我们三个都订在同一边的铺位上了吧，这样子还挺方便我们互相照顾的 进去之后果然，感觉里面的位置都好小好紧，人们都坐在过道旁边的座位上，吃着东西有说有笑，我和同学走了很久才找到了自己的铺位 “有个小桌子，有被子有枕头，我睡在下铺应该没什么大问题吧”，我内心这样想着于是，把东西放下后不久后火车便缓缓的开动了让我出乎意料的是平时在学校用的不怎么样的联通卡，在火车上的信号居然奇好无比(比我同学的移动简直好不完，经常找我开热点给他)闲着无聊，我于是在火车上就开始写作业，一直写了差不多3个小时的样子吧，到十点火车上熄灯了，同学也都从我床上上去休息了，我也差不多躺下来看会手机这一躺不知道，躺下去才知道火车是有多晃啊，当时我就感觉晚上睡觉不会顺利了(最后也没出乎我的意料)刷着手机过了凌晨，上完厕所去睡觉，躺下来蜷缩在被子里面，因为我有很严重的鼻炎的缘故，我每天睡觉只能侧着身子睡觉，但是火车晃的很严重让我侧着身子经常睡不好，于是就这样半睡半醒的样子持续到了4点多钟，迷迷糊糊的到了5点半，乘务人员就来叫醒我们准备下车了我去洗了个脸，用发泥弄了下自己的头，内心其实有点期待和不安吧，期待的是魔都能够给我带来什么样的惊喜，不安的是自己眼界不足，总感觉出去会丢人之类的想法。 嗯，总算是出站了，可是外面下着大雨让我的心里的不安达到了极点 没错，我当然知道要提前看天气，9月28日那天我就知道1号的时候会有台风天气，说实话，一直只待在内地的我确实还从来没有经历过台风天气，以前都是只能从电视上或者手机上的新闻了解到台风有多么多么厉害，好了，现在可算是“身临其境”了。 出了火车站就直接去地铁站感受下魔都地铁的便捷 令我惊讶的是来的时候地铁站里面居然没有很多人，可我看新闻明明魔都是国庆人们出游最多的地方了，“这台风是有多厉害喔，难道劝退了这么多人吗”由于订的民宿中午十二点之后才能入住，所以这之前我们要随便找个地方去转转 直奔云南路去找b站上那些大大们推荐的地方去随便吃点早餐吧到魔都早点最有名的就是生煎和锅贴了吧，于是在云南路上找了家店坐下来，外面居然就下起了暴雨了起来(原来这就是台风的威力吗) 等了几分钟点了两份锅贴和馄饨，不得不说，魔都本地的锅贴和我在学校吃的真的完全不一样，我觉得最大的不同点就是它里面的汁是真的足，吸完汁再吃一大口肉馅，那种感觉是真的不一样 吃完了早餐，由于离中午还有很久的时间我们就到人民广场附近随便转转，由于雨实在是太大了我们于是就找了家全家去避雨去了(魔都随处可见的便利店简直是不能再方便了) 等雨小之后我们于是继续在附近转，准备去附近的广场公园去看看 不看不知道，一看是真的把我美倒了“魔都这里的公园才能叫公园啊，有花有草有小溪有湖，里面还有一大群鸟儿，甚至还有橘子树”，其他地方的公园和这里一比简直是弱爆了。。。 继续走，到了十点钟也正好是阅兵的时候，我们也正好走到了上海市政府中心的位置(正好也是阅兵刚开始的时候吧)，我们也顺便一遍走一遍观看阅兵的直播。 不知不觉居然就走到了南京路步行街附近，但是第一天我们的计划里面并没有计划在这里好好玩，于是我们在美团里面找到了这附近评分最高的一家叫“南京大牌档”的地方去吃第一顿午餐了 不得不说这家餐厅里面的上海菜的确有它的特点，偏甜，偏小，里面的粥挺好喝的，还有类似的糕和小吃都能满足我们的味蕾，价格方面也不算离谱(没错，这顿饭也是这次旅游里面体验最好的一次了) 吃完饭，将近十二点了，于是我们便坐地铁到龙阳站附近的民宿去放东西(我背着一个电脑包来旅游实在是不太方便) 走了半天终于找到了订的民宿，经过一番折腾后终于是住了进去(没人，门上是智能开锁，只需要主人告诉密码就进去了) 民宿里面的环境还不错，三个人平均下来也只要一百多一个晚上，这在寸土寸金的上海简直就不要太便宜，而且旁边就是很方便的地铁站，住的地方是真的不错 我们休息了会天就黑了，准备出去恰个晚餐，我们仨打个伞就直接出去了，结果被台风天气虐到了，鞋子全湿裤子也几乎全被打湿了，一个伞在台风面前是在是不够看，我也是第一次见识到了台风的威力了。 虽然有点不爽，但是我们只能原路返回去避雨了，我们仨居然就直接在饿了么美团上面点外卖吃了(没错，出去玩还点外卖，我其实也是有点哭笑不得) 但也是迫于无奈吧，玩了玩电脑到过了凌晨，洗了个澡我们就直接睡觉了 第一天的旅途就这么结束了呢。 10月2日第二天，起来的不是很早，因为好像是晚上一两点才睡的觉我们晚上的精神不知道为什么都挺好的 嗯所以我们十点左右的时间才从家里出发 有个人要去见他亲戚一面于是和我们分开了 嗯虽然只有两个人，我们还是去了云南路去吃饭， 先去了这家阿叔熬奶茶去点了一杯血糯米奶茶，不过很失望，喝起来和普通奶茶店的奶茶好像没什么区别 又去附近的八宝炸猪排去买了个猪排，猪排十一块一个，虽说分量不是很多，但是加上那个汁确实好吃 又去云南路附近的汤包店点了两笼汤包以及一碗葱油面，点的时候还以为不够，点了才知道根本就吃不完。。。那个苏州汤包是真的好鲜啊。。。不蘸醋直接一口吃简直就是大大的满足，里面的汁水很足但是也不算太大，就算过了二十多天我还是记忆犹新 从云南路准备去世博园去的，但是途中居然就碰到了中共一大的会址。。。说巧也不巧，因为可以凭借身份证免费进去参观，于是我们便排队进去参观了 虽然是国庆但是可能是前一天的台风的影响吧，第二天中午还没看到很多人，于是我们便进去参观了 嗯…犹豫里面大多数的历史我都已经很清楚了，所以我们进去看了一圈就出来了，就随便放几张图好了 嗯，差不多就放这么多好了 出了一大会址，我们便坐地铁准备去世博园了 到了世博园，进去售票处，发现只要凭借身份证就能够免费的进去参观 于是我和他就领了票进去参观 额，由于里面其实也没什么好看的，那我也就不放图好了 进去参观将近一个小时之后就出去了 准备去梅赛德斯奔驰馆参观了 到了梅赛德斯奔驰馆，其实说实话有种不真实的感觉，因为平时在家里电脑手机上看到那么多在这里举行的比赛居然现在真真切切的在我身边，唯一有点遗憾的就是他不让游客进入比赛地点去参观了，属实有点遗憾。 梅赛德斯奔驰馆后面就是黄浦江，说实话，这里的景色是真的很棒啊，真的是很壮观的长江，里面还有好多游轮，但是在广阔的长江上就显得十分渺小 从梅赛德斯奔驰馆出来我们便准备去附近的世博公园去转转了世博公园是真的很大，地图上黄浦江一边的一大块都是世博公园，好像不骑自行车根本就不可能逛完，江边的公园景色真的很美啊！ 正在世博公园走的脚都快疼死的时候，突然另外一个同学打电话来说弄完了 我们于是便动身去前期约定好的animate店去集合了，A店在中国只有上海有一家店，虽然东西比较少但是对于我们这种宅来说去看看去打卡还是挺不错的 未完待续……….]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190926]]></title>
    <url>%2F2019%2F09%2F26%2F20190926%2F</url>
    <content type="text"><![CDATA[每天只会无能狂怒的废物&gt;发泄了下自己的情绪这种东西还是不要让别人看到好了 U2FsdGVkX18ozjEFPW24ghqnE/MSb6IaGOwzT/PpMkTjQQ1mSSsNHlZa7R8TnCZC7pm6GU9kfYJ4A+GDtKMi2RYJKlNJryanpv3fkRPjSscAeHkOlZs3ZBkMTVuFqP0b2T7sVcDkseRhdG7vtVppVkk0r8uU1s1XJ/X1BgP8AGlG24WytFmRuc3QcWog8oqIKrnunpU5VIhvW1ZqGddkXArbF51GI3uhbUFczWAi4sLyJ/LmqVMMdZdp8PZC2NoFkNFsucbhPKqBrR5h4R8OUa9ND7X9TXPcU4OrjQUXM14LgaoEsLZO1kq19GXsf0aBhHsroJQYRRcjlM1qIIoMML2P9x+v6/cSV84V/vu08a0T4s6osrnCv5lBoHhzauNjTGgC8YinrXUlIm1yDXHYsyZYtG21I2K3gzWGCY817ZKAOpfIyP2XJcQPPkXJUvIYTpDYiugCD/xg/+lmpHQTxDBTBKjQVECu9krDEP8ZHZxrMY/+BlYHpb3qw77L7/EhmN8OOtJ1+b6stNxjcgo+BtbIbTuHmQx7D7irsg5BtBpucBDBeRvCtKhb5G4EyOS6Ra/3aHMGyFiyz25KzPYCnLVo49b2oGqA9nRpIs9rXaTkquzGlw+k18KCirFOQ8hYBuTu0sZoz5jF5v5e2kHQ7+PmPsOO6Y0omkxpOQsnD1H28GPDOIAwzi/gacYpif1EoLdQh9TMnnuJrkgh+0WHQ96RdbPxdBWLiuXBvoTvJ+PSZ588n1L2YfNCacAz453pJjvZ+yD3CjwDg3/n4vct0tuPNYALNCaGCURafMurrT7NlFSbgbRb+BGH5zQ2m+wAaCON3gOP+T5SxMX9tNCclTE6d0GbNNR2aVyJTYWz4OZqE4Ra1tWrgPy0Xdn3hKkBxhh9kilMEJcdfANbbBMFeUWmC7qsAUmsb/IY91f5UYvLB3m/FNeN79DO+usGgzud3jsek6E7v2VnCmqFZkJdO+JFvHFV2DSvdthQr3nGKodmnJR87Qu30AVTAmwr0rSa5X5HFcJmXdfgVtbL1IhNhXcu2YL56b/2QqHbJSO4VlU7la2GSQg5ztmpT63yrHVjPWPLpWI9Fb3bLVvFIgrP0OCrEVBMkXkXu/na7jJGspjibZMHQCgXN3E1aiMrCWYqmj7kws4X5h2Q6IZ/4LWkjX2IevitaG6zuNQ0o6+LCuLc+5ryK/7gTd5eEBDQy59Of7EeVNI0VWWPuboYU9nBSEgJWwoAJ56pryw3V2xtLa+0hTuOnwmy/uTnyfbuTdNO0yoJL9BckApN+wkER+dtL/lCjOhHfeO848JR0ClMO/KSACx4UW0HBc5Dt2R8aHzp/umeqE2/k0CQjvcz0wVefqaA1WCgCD+0u323EQ1nYoR7OA/j+bs48zExobSPzgp+a9PG9DltvqjZ2Tf1EkNnAhwlB8mqaRYc3+Q6bakUMCgpCHfWWu/9P3tKVfeyoP1BtjjvY6UfN4I0wg8nNtIlVZ5BTAc+yOimnZyc48NaxyIUI4bi+cqW3GEpX4rExdKZcfaoxsUtSXEbQ7iCHPbczjfJNrphhxRfFJyRCl0gw5cxafWu1IhX4IqJ7oQkUX/26mb8ldXslmWBpP3ThBK9jx5qym96caD1mSF/Q27E3C6yjspfFT1R/5h1cgq5ELcUXUb8gSXV0qzNd8W8pua4iWdURzCjgtie1MCpcyDQTDQF8uOOutGs8eAPbgtQ/NfZZddVxXrLvH0EoWosI2VGJifwj2IlxVcflOGQycV/Gm2DciUJjCbdFe7ra3L2bRi+gwxB23Zm/zgL3k4W0kceFMnApkOdoeYvTvw/UF3KFPUNriaY3Ci1Ee+ZTzsalojE19YSTU7IJkfyY6UgWKkCwEo8vpL2I9X8i7mkpXT2CtQOdFcOVVBeV1sVawdvN3pY62vAfUCe6LfL4ZGBHGXXfHlo5sEZ/Un+bTjtiVNepT3uOyYG3vxlOMFoccWzzAdVlid6QFB3Bl6NohD6vYZp+vO/7Tf7EKOSKwbEaIxOhsXtltki6Es+o6ElNwZCADl1ZW/l4ednEVDYyzONRVILz+Eje+dbVaunILjudBYSS9BBl9MfzYnT77cFIqZ+f5Ij5/FFu92wuPQTdDaA0nnVjkxW0jgo14feb1VNydI7BrVgIjTC5oygLbTgwsBzgKtph8Epxo/9rX+/ueMLa1H/MbEnzVF9pXj8uYtrPM0a1R8dfM8SLJRKsIOw8KaaeIr0agshW6sZrIByEEjWPsIOxDA1u55S8h6HFHnJajYCiMh24T1eA4FoYORAsamyeODJNdI1+E22D94HExfZAGam3piFbmhCIKL1SS4dZRa7h51mweZG827opxEN1pU6hfZaNt+Mnp1KJFV43/8IHm2M4zBSSPVowbyTWRjGxWQHjfiVfoDFp4lYGXSwo4qq0wjGdJx1CUFW1YAMFgMxm9AsMeFpdotMnluVMa8YL5EuJklvCjCpSEPU9ChTN7flJjdX9NdwsX7ryzhf1mQ9fmD0+3obOSCwuDDVqLUY4dRb3qC7IDwWf03FawBF76ohGsABHzuDPN/wLq2N/NtaK8SchTOeuJZ7xgPeChJN4dmnJDo/Y/FI1m0fOlJ/kigRtA9mldfO3rXE36zzBICYYScl+EHl8/mw9WurJvMzB4psLrsw8uTwe1/VL3M6BChipBPaTwDhwCLaXwTs7G9YWhg5ZylmeWEvqisQ4zmLvwWCIiSMXUJ3zPyLojT0gQgUJuqg+R8HHpCbZR4OHx/BodqswZchNTCQQy/EF7h9PEk823e/DoroiVNs2DTy4d1JaQf+cNDH9yvUc2ppjzb9ujrnwLrZZd5RZKfy/sc7E9JrKkPlQv3LrSP1E7eahocBGD6P3xBvkR6YqLfU5No3K/RRb3pOvie6vM/af8lcHuXsB4r5ZJ6JpZL0GPmTbQDXm0uysATw5cqi7TS1jfWbGk8pw0uNHsBRBomm2cbu9pMgJtpV7qrZli5MZUmN8ktQe7dXpfWKxqiG3E9S4tum3ooBXnjY01+GPF1LhtlOhqEi0OPD//bkmC9I+xI4ZsrIDE+g5CcLAEFDxvRetPV119zt/de5Xc/NgI/47APAp83VWM3GPCB8nssGSWWmKKdYcRcRYKdbsoUHvVdHLlhYlT3GTH0iuU5i7IMfxifeublbmcCguQZWZgvx+sl+RAnr8jqTJwIW02NhdZRCh8VbIfjvzngaWcIFhKshe2vofBFJIDdrqCntPS5rzrDW4YwBd4DMhBl6hpat+mF/NR143xlV42/ZRGYu7REFZI5LJ/Ky/4RJHbL6uH/fdOhU4CXr8T+SLGsvoe7/NeUuxQqJPJY2k07EtjduqdS6O39F1LegHHqXvQAc3qsD3dQBBVMMWaByDBdKWY1cjMsjQFsGauIn1ho5jIbIFhNahrNiVwfeezrmojvW7w6tXaI/4OVphjSURXJQD76Yv07+xboGYa0+g/cwgglqovbr+77rBuWLyYdscUnCb3Vys2mhv81S60ZRq1GIJUHNKX7X6rcQkfOYgJ+/9WJzYgw5rSwcIdy/EeNoRsiJr/1gBWPtchGlA8EE72WQH1FjKQp2yW0qraOBYGFK18VA0HqCLUKHXKk+XKF8lKaYW6EZ0UGrE9e9p8nxNoEZ/ryiFyobXJG4oH1qx+6y7enGTtcckyowIS/pIuJOOoRCC5mC1QHEiEBgDKk3UwWZ0JZOmOefM+Vql/1pzMRqvqp2OvCKCldVAxBN6pUi1DXWvJ1/kgYbD9i1Fy7Z3434vi/sDsA9xgX84avDyxHovaC32/0ccuxHAqeq2jWXfnpeBmIrmWi+r8EY0tHwDqrR8BsS00YHSuPq9t6I5mmGRIXH8DMsLIsyhIc51zQey3q5183lup1V0fqvea4Q5jPTd3DGt2yr/dGJ764u/HS1UKX6H7b2gkZYUeFl9VJbi8c/hbfZMaOAqTrPnl5ckHt9AVO++klExO4QhdBjot45+39i6lJpKayK58wGJ8kWKRxY31KtfgthuKoCCT13]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-169]]></title>
    <url>%2F2019%2F09%2F14%2FLeetcode-169%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PAT-1003]]></title>
    <url>%2F2019%2F09%2F09%2FPAT-1003%2F</url>
    <content type="text"><![CDATA[1003 Emergency传送门 英文描述:As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:2 4 中文题意给出N个城市，M条无向边。每个城市都有一定数目的救援小组，所有边的边权已知。现在给出起点C1和终点C2，求从起点C1到终点C2的最短路径条数及最短路径上的救援小组数目之和。如果有多条最短路径，则输出数目之和最大的。 思路：把样例输入来举例子吧5 6 0 2分别代表5座城市(对应N)6条道路(对应M)0表示对应的起点是第0号城市(因为城市的编号是从0到N-1)这里我把0到4的五个城市分别从A到E来表示比较方便那么如图所示ABCDE五座城市,起点为A终点为C红色的数字表示每座城市的救援人员人数绿色的数字表示城市与城市之间的道路距离所以我们要求的是在从A到C道路距离最小的情况下,沿途城市一起的救援人数越多越好 所以我们定义一个rescueWorkers和val_distance来存放最后的结果并且令rescueWorkers = INT_MIN,val_distance = INT_MAX方便后面比较结果 定义一个邻接矩阵road[maxn][maxn],其中如果road[i][j]为0表示i和j之间没有道路,如果不为0则表示i和j之间有道路,且值即为图中绿色颜色的数字所代表的距离 再定义一个visit[maxn]来判断城市是够走过定义一个map&lt;int,int&gt;city来存放每个城市的救援人数,其中city[i]表示第i个城市的救援人数(map也可以用一个数组来代替,因为城市是从0到N-1的所以没有影响) 所以我的思路就是用dfs从起点开始来进行搜索,直到到达终点位置然后就继续回溯,直到全部搜索完于是有两种情况1.搜索到C2的时候,当前的distance比之前更新过的val_distance要小这个时候应该重新更新sum为1,因为这是只有一种最小的情况,并且更新val_distance2.搜索到C2的时候,当前的distance和之前更新过的val_distance相等,这时表示当前找到了另一条最短路径,则此时sum++,然后再判断people和rescueWorkers的大小,如果当前的people比rescueWorkers大则重新更新rescueWorkers 几点需要注意的地方:1.在输入邻接表的时候不仅要更新road[i][j],一定也要还更新road[j][i]！！！否则会造成错误2.dfs的思路就是从0开始进行遍历,所以用一个for循环从头开始进行遍历,当visit[i] == 0 &amp;&amp; road[nowVisit][i]不为0的时候进一步dfs3.dfs后一定要令visit[i] = 1,回溯的时候一定要令visit[i] = 04.dfs直接从最初的C1点开始搜索,dfs(C1,city[C1],0)表示从C1开始搜索,最初的人数为city[C1],距离为0开始 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;//P1003 Emergencyconst int maxn = 501;//邻接矩阵最大的数目int N,M,C1,C2,sum = 0;//N表示城市数量,M表示道路的条数,C1表示当前所在城市,C2表示要去的城市int rescueWorkers = INT_MIN;//rescueWorkers来存放最多的救援队人数int val_distance = INT_MAX;int road[maxn][maxn];int visit[maxn];//表示是否访问过map&lt;int,int&gt;city;//定义一个map来存放城市对应的救援队的数目void dfs(int nowVisit,int people,int distance)&#123; if(nowVisit == C2) &#123; if(distance &lt; val_distance) &#123; sum = 1; val_distance = distance; rescueWorkers = people; &#125; else if(distance == val_distance) &#123; sum++; rescueWorkers = max(rescueWorkers,people); &#125; return ; &#125; if(distance &gt; val_distance) return ;//如果现在的距离已经超过最短的距离直接返回 for(int i = 0;i &lt; N;i++) &#123; if(visit[i] == 0 &amp;&amp; road[nowVisit][i] != 0) &#123; visit[i] = 1; dfs(i,(people+city[i]),(distance+road[nowVisit][i])); visit[i] = 0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2; for(int i = 0;i &lt; N;i++) &#123; int temp; cin&gt;&gt;temp; city[i] = temp; &#125; for(int j = 0;j &lt; M;j++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; road[a][b] = c; road[b][a] = c; &#125; dfs(C1,city[C1],0); cout&lt;&lt;sum&lt;&lt;" "&lt;&lt;rescueWorkers; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1449]]></title>
    <url>%2F2019%2F09%2F05%2FluoguOJ-P1449%2F</url>
    <content type="text"><![CDATA[P1449 后缀表达式传送门 题目描述所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。 如：3*(5–2)+7对应的后缀表达式为：3．5．2．-*7．+@。’@’为表达式的结束符号。‘.’为操作数的结束符号。 输入格式输入：后缀表达式 输出格式输出：表达式的值 输入输出样例输入 #13.5.2.-*7.+@ 输出 #116 说明/提示字符串长度，1000内。 思路：从左到右扫描后缀表达式 如果是操作数就压入栈 如果是操作符就连续弹出两个操作数(且后弹出的是第一操作数,先弹出的是第一操作数)然后再进行对应操作符的操作最后再把新生成的操作数压入栈里面,直到后缀表达式扫描完毕那么此时栈只剩下的一个数就是最终的答案 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152stack&lt;int&gt; num;string str;int val = 0;int main()&#123; cin&gt;&gt;str; for(int i = 0;i &lt; str.size();i++) &#123; if(str[i] =='.') &#123; num.push(val); val = 0; continue; &#125; else if(str[i] &lt;= '9' &amp;&amp; str[i] &gt;='0') &#123; val *= 10; val += str[i] - '0' + 0; &#125; else if(str[i] != '@') &#123; int temp1,temp2,temp; temp2 = num.top(); num.pop(); temp1 = num.top(); num.pop(); if(str[i] == '+') &#123; temp = temp1 + temp2; &#125; else if(str[i] == '-') &#123; temp = temp1 - temp2; &#125; else if(str[i] == '*') &#123; temp = temp1 * temp2; &#125; else if(str[i] == '/') &#123; temp = temp1 / temp2; &#125; num.push(temp); &#125; else if(str[i] == '@') &#123; cout&lt;&lt;num.top(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1433]]></title>
    <url>%2F2019%2F09%2F03%2FluoguOJ-P1433%2F</url>
    <content type="text"><![CDATA[P1433 吃奶酪传送门 题目描述房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在(0,0)点处。 输入格式第一行一个数n (n&lt;=15) 接下来每行2个实数，表示第i块奶酪的坐标。 两点之间的距离公式=sqrt((x1-x2)(x1-x2)+(y1-y2)(y1-y2)) 输出格式一个数，表示要跑的最少距离，保留2位小数。 输入输出样例输入 #141 11 -1-1 1-1 -1 输出 #17.41 思路：double一个sum来统计每次dfs到底的时候比较最短距离，如果s比sum要小就更新sum 我觉得这里面最重要的就是用visit[maxn]数组来判断是否走过因为每次用now在dfs里面表示当前第几个点 因为要走过所有的点，所以从哪个点开始进行dfs是无所谓的，所以默认dfs(0,0,0.0)开始没问题 然后double Distance[maxn][maxn]来存放点与点之间的距离 Distance[i][j]表示第i个点和第j个点之间的距离 然后再dfs(i+1,j,s+Distance[now][j]) 这个的意思就是现在位于now点,然后再准备走向下一个点,也就是走向j对应的点 然后就先令visit[j] = 1表示j这个点即将要走到了 那么s就加上一个Distance[now][j],此时继续dfs 那么此时的now就等于j点,如果一直dfs,一直递归到条件不成立,那么就回溯,令visit[j] = 0 因为每一层dfs里面的for循环都是从1一直到n的,所以怎么无论dfs多少次都是会从1开始遍历 如果经过了就不考虑,如果没经过就继续dfs,直至每层dfs为止然后再更新最小的sum值 又因为输出的格式要求要保留两位小数,所以最后就printf(“%0.2f”,sum)得到最后的结果 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 16;int n;double sum = 10000.0;//sum来存放跑动的最少距离double Distance[maxn][maxn];//存放点与点之间的距离double x[maxn],y[maxn];//存放每个点的坐标int visit[maxn];void dfs(int i,int now,double s)//i表示已经走了几个点，now表示当前第几个点，s表示距离&#123; if(s &gt;= sum)//如果发现s已经大于当前最小的sum则直接返回 &#123; return ; &#125; if(i == n)//全部走完的时候 &#123; sum = min(sum,s); return ; &#125; for(int j = 1;j &lt;= n;j++) &#123; if(!visit[j]) &#123; visit[j] = 1;//把即将要走过的这个点设置为走过 dfs(i+1,j,s+Distance[now][j]); visit[j] = 0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; for(int i = 0;i &lt;= n;i++) &#123; for(int j = 0;j &lt;= n;j++) &#123; Distance[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dfs(0,0,0.0); printf("%0.2f",sum); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1403]]></title>
    <url>%2F2019%2F09%2F02%2FluoguOJ-P1403%2F</url>
    <content type="text"><![CDATA[P1403 [AHOI2005]约数研究传送门 题目描述：科学家们在Samuel星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机“Samuel II”的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用“Samuel II”进行数学研究。 小联最近在研究和约数有关的问题，他统计每个正数N的约数的个数，并以f(N)来表示。例如12的约数有1、2、3、4、6、12。因此f(12)=6。下表给出了一些f(N)的取值： f(n)表示n的约数个数，现在给出n，要求求出f(1)到f(n)的总和。 输入格式:输入一行，一个整数n 输出格式:输出一个整数，表示总和 输入输出样例输入 #13输出 #15 说明/提示【数据范围】 20%N&lt;=5000 100%N&lt;=1000000 思路： (数学方法)f(1)到f(n)的和，即为1到n之间因子的和那么1到n之间1的因子总共有n/1个2的因子总共有n/2个3的因子总共有n/3个…依此类推那么1到n之间因子的和即为f(i) = n / i;i从1到n的总和 代码如下：123456789101112int n;int result;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; result += n / i; &#125; cout&lt;&lt;result; return 0;&#125; (非数学方法)(用筛法) 定义一个数组num[maxn]，result = 0；从1到n,int i = 1,然后每隔1就累加一次num[i]++,表示从1到n每个数都拥有的1的个数,然后再从1到n,s加一次ai然后i++递增,同理,i = 2,每隔2就累加一次num[i]++,然后依次类推表示从2到n里面每个数如果含有2就会++一次,然后结束循环之后,s再加一次a[i]依此类推 代码如下：123456789101112int n,a[10000001],s;int main()&#123;cin&gt;&gt;n;for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; &#125;cout&lt;&lt;s;return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1118]]></title>
    <url>%2F2019%2F08%2F31%2FluoguOJ-P1118%2F</url>
    <content type="text"><![CDATA[P1118 [USACO06FEB]数字三角形传送门 题目描述有这么一个游戏： 写出一个1至N的排列ai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少1，直到只剩下一个数字位置。下面是一个例子： 3,1,2,4 4,3,6 7,9 16 最后得到16这样一个数字。 现在想要倒着玩这样一个游戏，如果知道N，知道最后得到的数字的大小sum，请你求出最初序列ai，为1至N的一个排列。若答案有多种可能，则输出字典序最小的那一个。1234567891011121314输入输出样例输入：4 16输出：3 1 2 4说明/提示对于40%的数据，n≤7；对于80%的数据，n≤10；对于100%的数据，n≤12,sum≤12345。 思路：假设n = 5,那么a b c d e依次对应a b c d e a+b b+c c+d d+e a+2b+c b+2c+d c+2d+e a+3b+3c+d b+3c+3d+e a+4b+6c+4d+e此时1到5对应的权值即为位数 1 2 3 4 5权值 1 4 6 4 1 假设n = 8,那么a b c d e f g h依次对应a b c d e f g h a+b b+c c+d d+e e+f f+g g+h a+2b+c b+2c+d c+2d+e d+2e+f e+2f+g f+2g+h a+3b+3c+d b+3c+3d+e c+3d+3e+f d+3e+3f+g e+3f+3g+h a+4b+6c+4d+e b+4c+6d+4e+f c+4d+6e+4f+g d+4e+6f+4g+h a+5b+10c+10d+5e+f b+5c+10d+10e+5f+g c+5d+10e+10f+5g+h a+6b+15c+20d+15e+6f+g b+6c+15d+20e+15f+6g+h a+7b+21c+35d+35e+21f+7g+h 此时1到8对应的权值为位数 1 2 3 4 5 6 7 8权值 1 7 21 35 35 21 7 1 所以这其实就是一个杨辉三角的一个模型那么构建一个杨辉三角的代码如下所示1234c[1][1]=1;//最左上角的数初始化为1for(int i=2;i&lt;=n;i++)//由于这里数组的记录是从1开始记的，所以不用担心越界 for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//每个数都等于它肩上两数之和 或者直接套用杨辉三角的通用公式来直接解出来,和上式一样C(n-1,m-1)=(n-1)!/[(m-1)!(n-m)!](其中!表示阶乘，n！=n(n-1)…21) 那么当n为几,sum的和就是n个数乘以杨辉三角第n行分别对应系数得到的结果 然后直接从1开始进行dfs,因为是从1开始储存的,所以得到的结果肯定也是字典序最小的 完整代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;int n,p;//输入必备int a[13];//输出必备int c[13][13];//杨辉三角必备bool b[13];//判重必备void dfs(int dep,int s)&#123; if(s&gt;p)//如果现在累加的数已经超过了给定的数，就返回 return; if(dep&gt;n)//如果已经搜完了n个数，就返回 &#123; if(s==p)//如果答案跟给定的数相等 &#123; cout&lt;&lt;a[1]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;" "&lt;&lt;a[i];//输出 exit(0);//终止程序 &#125; return;//如果没有输出答案，就返回 &#125; for(int i=1;i&lt;=n;i++) &#123; if(b[i]==false)//如果当前这个数没有用过 &#123; b[i]=true;//标记成用过 a[dep]=i;//保存第dep个取的数 dfs(dep+1,s+i*c[n][dep]); b[i]=false;//注意这里要将状态回归，不然TLE &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;p;//输入 c[1][1]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//生成杨辉三角 dfs(1,0);//开启深搜之旅 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190823]]></title>
    <url>%2F2019%2F08%2F23%2F20190823%2F</url>
    <content type="text"><![CDATA[想做一点有趣的事情好久都没写博客了Orz，这个习惯要开始慢慢重新恢复起来了。。嘛，最近开始接触了PR,AE之类的软件，突然感觉心血来潮，对做视频这方面感觉挺有意思的，现在越来越觉得游戏没多少意思了，虽然能够给我带来快乐，但是都只是短暂的，不可持续的，比每天刷一道题，去知乎好好写一篇回答，亦或者去好好做一个视频给自己带来的成就感确实低多了。。。 所以我现在所在的问题不是会不会用什么东西，而是要去自己深入了解其中的内涵，不然自己跟所谓的工具人又有什么区别(悲 果然不出我所料，回家带的几本书根本翻都没翻，就算看书我也是喜欢直接到电脑上去看。。。感觉自己对于电脑的感情还是不一般呢，可能自己一辈子也离开不了它了吧。。。 其实我一直都在问自己，到底喜欢什么，以后到底喜欢做什么事情，但是确实没有什么事情能够让自己一直能够很开心的去做下去，所以看那些大佬们每天能够做自己喜欢做的事情真的是羡慕的不行呢，果然跟C菌说的一样。。。兴趣就是最好的前进动力可惜我没有叻。。。 自己的惰性还是大于自己的干劲，这几天和家里的老人又聊了聊天感觉自己过的时候真的是太幸福了，像我爷爷奶奶到了我这个年纪就要去工厂干活或者去农田里面耕作，虽说现在时代是好了但是我在家也没有好好学习充实自己反而是每天浪费时间去做很多很多无意义的事情。。。每天中午睡觉也是。。经常就睡一下午，就感觉跟家里人所说的没有操心一样，心里没有一点事情就睡得安稳，就喜欢混时间，可能是不到最后一刻不到生死关头自己才会醒悟吗？可是每次都把希望寄托在明天我最后可能什么都得不到。。。 想了想19年已经8月底快9月了，这一年过的真的是太快太快了，就好像刚刚过年没多久自己立下的flag还历历在目但是现在来看根本没完成几个。。。我真的有点厌倦了。 可能是舒服的日子过得太久了吧，两年前还在奋斗高考的我的那股冲劲感觉完全都没有了，现在的我只是一个一事无成每天喜欢看手机玩电脑的废物，这也不会那也不会。。。明年就要考研了我还没开始系统的学习知识点，还有好多想做的事情没有去做。。我很难过，但是我不怪别人，这都是自己找的，但是我已经认识到了我自己的问题，新的学期大三虽然是满课，但是我觉得我每天可以过的很充实，一天一道题，一个星期写一篇回答，一个月制作一个视频，我觉得自己给自己找点事情做才会让自己每天都充实。 那么今天的日记就这样吧，以后写日记的频率会增加吧，我觉得真的挺充实的，还会更新算法相关的笔记，那么就这样吧Orz]]></content>
  </entry>
  <entry>
    <title><![CDATA[20190816]]></title>
    <url>%2F2019%2F08%2F16%2F20190816%2F</url>
    <content type="text"><![CDATA[一点点疑惑突然发现自己的博客居然有人在看，不禁觉得有点害羞，但是仔细想想既然分享了出去，那么肯定就是希望有人来看的，但是这种感觉就好像是自言自语被别人看到了一样(就感觉像个沙雕一样呜呜呜)可能我就是这样的人吧，有的时候会太在意别人的看法，在意别人看法的后果就是做什么事情都畏手畏脚，从而好多事情都不敢去做，就比如交朋友来说，觉得别人很厉害啊什么的就不敢去交流不敢去交往，我觉得这可能也是很多人的一个通病吧，所以好好的做好自己才是更应当做到的事情(天天都在摸鱼的屑留下来不思进取的眼泪) 但是我又不禁感到一丝惭愧，作为一名还没有任何知识水平的人，既没有自己擅长的领域可以分享给别人，也没有好好分析一个问题的能力，实在是让我惶恐不安，可能这就是所谓的键盘侠吧，打字计划满满的一堆，但是真正去做什么事情都会大打折扣。所以想要朋友是对的，但是莫名其妙的去强行和别人交流真的不可取，不同阶级，不同知识水平，自己都没有这个水平怎么跟别人聊得起来呢？所以现在我也想开了，提升自我修养才是更应该去做的事情，只有自己的知识水平上去了，只有自己变得足够优秀，才能有和别人成为朋友的价值。正如我之前所说，朋友之间是相互的，如果你不能给别人足够的帮助，那别人为什么要和你成为朋友呢，所以这其实是一个伪命题。这件事我不会再写很多了，说多了其实自己也挺烦的，一个人就一个人吧，一个人其实也挺好的，至少没人来烦我Orz。 乱七八糟又写了这么多，暑假也快要过完了，我觉得是时候要好好想一想一下自己未来的生活了xd 在b站上看到一个视频，学习思维和方法确实比知识重要太多了，以前觉得这个都不怎么重要，现在才知道原来自己是多么幼稚，简直就是浪费了自己当初多少的大好时光，所以说导致现在这个样子真不能怪别人，只能怪自己太短视了。 番茄工作法真的很适合我这种不自觉的人，平时干什么事情都会莫名其妙就看手机，刷知乎，上b站去了，还不如规定一段时间让自己专心致志的去做某件事情，能够让自己集中注意力，我觉得挺赞的。 我今天才发现自己平时真的是不爱思考，不喜欢思考事情，不管是好是坏都是一种无所谓的态度，可能在这个过程之中逐渐就丧失掉了自己的思考问题的能力，我觉得不能再拖下去了，是时候正视自己的缺点去改进了 所以以后会在blog更新一些我对时事的一些看法和一点意见吧。哦对了，好久都没有把刷过的题目好好做个总结，这也是今后需要做的事情，当初其实是想当一个技术blog来着的(但是真的没什么技术水平)，但是我会努力的！争取在合理的时间做合适的事情吧，还有十天不到的时间，就这样先试试看吧~]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190810]]></title>
    <url>%2F2019%2F08%2F10%2F20190810%2F</url>
    <content type="text"><![CDATA[一点感慨有一段时间没有更新过博客了吧，这段时间也确实发生了很多事情，这其中我也想了很多，思考了很多，我发现自己确实变了很多，长大了之后就感觉自己逐渐失去了自我？(maybe)，学会了如何去讨好他人？学会了怎么去妥协别人？反倒是自己不能够随心所欲的去干一些事情？我觉得到现在看来真的挺可笑的，有的时候自己确实想的太多思考的太多，反倒有的时候过于考虑别人从而让自己每天活在不快乐之中。嗯，所以我决定了，自己以后不管是谁都不能改变自己的初心了，我就是我，我想干什么就去干什么，真的没什么好顾忌的。 因为现在已经没有什么可以失去了。嗯，接下来就说说这几天发生的事情吧，算是都跟朋友有关吧，直到今天我才有时间来好好总结。 第一件事就是我和我现实中的好朋友吧，我和他算是老相识了吧，从小学就开始认识了，到现在为止算了算认识了也有十几年了吧，但是可能是我过于高估我们两个之间的关系了吧？长大以后，我的性格越来越内向，我从一个外向开放的人逐渐走向内向自闭的一个人，尤其是在高中这个阶段，嗯，高中的氛围很不好，很不好，很不好，以至于我不再想回忆起我的高中生活，但是我必须要去面对那段事实，就是我确实感觉很孤独，在那么紧张那么激烈的一段时间里面，没有人能够一起说话没有人可以让自己表达自己的感情，有的只是同学之间相互之间的嘲讽，没错就是嘲讽。你可能难以想象，怎么可能，高中同学难道不应该是相互鼓励相互尊重然后一起努力去考上一个好的大学吗？很可惜，对于我来说很不巧，刚好分到了一个班级里面都不是那么友善的人，简单的来说就是他们不是想跟你一起努力，反而是通过各种手段(就比如各种嘲讽)来影响你让你考试发挥不好，影响你的心态然后就能踩在你身上获得成就感，虽然已经两年了，但是我还是忘不了这段时期，现在已经不敢想象当时自己是怎么过来的。于是就在这个背景之下，我和那个人就因为认识了很多年的原因，所以就成为了表面上的好朋友吧，毕竟当时在班里我也和别人不熟，他也和我差不多，但是到今天为止我都没猜透他到底在想什么。你可能会说，这不是一件好事吗，认识了那么久，在一个班里刚好能互相取暖吧，但可能我不知道我做了什么事情让他心里不爽吧(可能)，一直跟我保持距离，但是我一直都算是把他当做最好的朋友来看待的。现在想想真的是可笑，别人可能根本把我不当什么吧，都怪我自作多情，大学里面还经常打电话过去，每次出去玩都是我主动找他，他一次也没有找过我，直到前几天各种理由来推脱我，我这时候才终于明白了。 朋友之间不应该是相互的吗？为什么只有我去关心别人？朋友不应该就是能够互相依靠的吗，说句不好听的话，怎么就成了我去舔别人了呢？现在想想真的可笑，我可能是为了寻求内心那一点点依靠，把别人看的太重了，导致成了现在这幅样子，但是如今我也想开了，已经没有什么好失去的了，这种朋友不要也罢，前几天一气之下就直接把他删了，既然不想跟我做朋友，既然不想跟我见面，那我们各走各的有缘再见吧。 第二件事就是知乎上一个朋友橘猫，我也不想说你的id你也注销过好几次了，不，按您的说法我们根本就算不上朋友，我也不想回忆您我也不想再说和您的故事，好聚好散，虽然你是个渣男和好多木桶饭也都交往过，请好好想想为什么最后都会成为这样，不要把责任都推到别人身上，你自己本身就有很大的问题，我现在也看开了不是同一个世界的人就没有必要天天聊这个聊那个的，思维都不一样，希望您早点出国成为人生赢家，走入社会再干上您最讨厌的工作吧，哦不，或者成为一个哲学家(当代马克思)也说不定？ 稀里糊涂说了这么多我也不想改了，反正就是记录自己最近的烦心事，以后会随着自己的本性去做事情了，不会再去顾忌这个顾忌那个 因为自己已经没有什么好失去的了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190727]]></title>
    <url>%2F2019%2F07%2F27%2F20190727%2F</url>
    <content type="text"><![CDATA[记录一下昨天晚上的一些心事从25号回家到现在也有两天了，发现回家也并没有想象中的那么兴奋嘛，第一天家里人见到我都说我瘦了好多好多Orz，还怀疑我有没有在学校好好吃饭(其实在学校根本就没吃过早餐，因为没有好吃的早餐哼唧)，看着自己那么胖那么粗的一根腿说实话我觉得我自己胖的要爆炸了这个腿根本不可能让别人有社保的欲望啊(逃但是家里人好像可能已经察觉到了什么了？诶多，下学期还是要坚持运动吧，争取能再瘦个10斤？(flag先立起来再说) 然后再就是昨天晚上发生的事情让我难受了一个晚上吧Orz嗯，昨天晚上的事情确实有点让我伤心，本来这个月初就跟原来最好的朋友说好要一起出去的，当初也答应了我要一起出去，结果昨天发消息却是不情不愿，也不想跟我说话我是真的真的特别伤心，因为本来原来高中的时候跟同学处的就不是很好，到现在也没几个能联系的人，唯一一个在我眼里看来算是最好的朋友的人可能不把我放在心上吧。每次放假都是我主动给他打电话，每次什么活动都是我主动去拉别人，现在想想真的是有点自作多情了，说实话我对他可能是有感情的吧，毕竟同学了十几年了，从小学一直到高中，可是别人却把我不当回事，我是真的真的很心痛，可能本来就不是一路人吧，我现在也想开了今天中午又跟另外一个朋友聊了半天，说句笑话，我真的算是条舔狗吧？把别人当回事，还义无反顾的去舔，我现在真的无所谓了，以后爱见不见，有缘再见吧真的是，你不情愿我也无所谓，厚着个脸皮天天叫你真的没意思ok？但是伤心是真的伤心，现实里面真的就没有那种真正意义上能够关心我的朋友了吗，为什么会这样子呢…我也不知道为什么从小长到大性格越来越内向，越来越不喜欢跟别人交流但是却又想和更多的人交流沟通。。。 真的是很矛盾呢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190724]]></title>
    <url>%2F2019%2F07%2F24%2F20190724%2F</url>
    <content type="text"><![CDATA[回家前的一点感悟终于，摸了这么多天我还是选择回家好了(其实是因为没钱的缘故了xd)，又要一个人踏上回家的旅程了，回家一次就是相差大半年，仔细算算还有几个大半年能够这样呢(就是没多少假期意思desu)，想想没几年就是个社畜了(悲，还没有可爱的大姐姐来找我呜呜呜，这辈子算是难了噗，不说多的了，希望今天能有一个好梦吧！ 时间真的是过得非常非常快，从2号考完到现在已经整整过了22天了，也就是将近一个月了，暑假已经走到了一半了，说来惭愧，这二十多天真的是没有做什么事情，其实留校和在家真的没有什么区别，反而每天要自己花时间来安排自己的吃喝，反而效率更低了(笑) 真的是不知道为什么，当初那种努力的感觉就是找不回来了，学习完再快乐本来应该是一件很棒的事情，但是在电脑上就是抑制不住自己，但是仔细想想我现在本来是一个很自觉的人啊，为什么会这样子呢。 想了想，可能还是没吃过苦头吧，也就是所谓的在危机没有真正到达眼前之前，人总会给自己找各种各样的借口来为自己的懈怠推脱，所以现在格外的意识到了人性，”说到底还不就是一条懒狗”，完美总结了这22天的宿舍生活。 于是我决定明天就回家好了，宿舍还有个室友经常打扰我，在家里应该不会有人打扰我了，而且也不用操心自己的吃喝，挺好的，这次回家我准备就带两本书回去，还有两本关于经济学方面的书准备看完，现在我的知识水平还是太欠缺了，根本不能到知乎上去做像模像样的回答(同时也没有勇气和大佬们交流)所以虽然玩了知乎有几年了，但是认识的朋友却并不多(悲)，希望能好好改善一下当前的处境呢。 这个暑假最大的收获可能就是认识了一位志同道合的朋友吧(或者说是未来的研友也不为过)，虽然他就住在我楼下但是感觉认识更多的人自己的信息面会广很多啊，这个朋友为我提供了很多资料，我挺感谢他的，毕竟都是失败专业的人嘛，互相帮助互相交流我觉得挺好的，早点认识到自己的失败所在，及时的改正我觉得才是一个正常人应有的判断和抉择。 暑假还打算出去旅游来着，但是好像约的人好多都有事，如果能顺利出行的话会继续到博客上更新的hhh说不定还会拍vlog？(从而成为一名up主？)，说实话我一直都很想做点视频去做一名up主，看到老番茄激励的视频就感觉很兴奋，但是兴奋了一会之后往往又会平静下来，可能这就是我吧。 总之我想摆脱当前这样的生活，一天到晚打游戏的生活虽然快乐但是却并不能给我带来收获，在并不知道自己真正喜欢什么的时候只有努力学更多的知识才能让自己处于不败之地吧(可能) 其实说实话什么时候能真正摆脱人的惰性，我觉得干什么事都能够成功的，摸鱼一时爽，一直摸鱼一直爽，可是时间不等人喔，今年我已经20岁了，已经不再是一个小孩子了，是时候该为自己的未来做打算了，毕竟，不仅是为了自己，也是为了那份执着的信念罢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1168]]></title>
    <url>%2F2019%2F07%2F10%2FluoguOJ-P1168%2F</url>
    <content type="text"><![CDATA[P1168 中位数传送门 这题主要的思路 1.因为这题的数据很大,常规思路就是我每隔两个就sort一下,然后再找出中位数 显然这样做重复的次数会很多,一定会TLE,所以需要转换思路* 2.所以应该从输入的时候一开始就进行插入操作,输入1个插入1个,然后以插入的方式直接有序的插入进去 然后插入3个之后则第2个即是前三个的中位数,然后依次类推。* 3.然后考虑插入操作应该怎么插入,很容易就能想到用二分查找的方式查找到X附近的位置然后进行插入 因为是进行的插入操作所以应该用upper_bound()(或者lower_bound())进行二分查找,然后再进行插入* 自己遇到的坑: 我以为要输入完之后再全部进行输出,但是其实可以一边输入一边进行插入操作 从而降低了时间复杂度。 代码如下：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;//P1168 中位数int N;//N表示整个序列的长度vector&lt;int&gt; val;//定义一个数来存放int main()&#123; cin&gt;&gt;N; for(int i = 1,x;i &lt;= N;i++)//直接用一个变量x就可以代替数组 &#123; cin&gt;&gt;x; //val.insert(val.begin()+(upper_bound(val.begin(),val.end(),x)- val.begin()),x); val.insert(lower_bound(val.begin(),val.end(),x),x);//上式等价的写法,val.begin()被抵消了 if(i % 2 == 1) cout&lt;&lt;val[(i-1)/2]&lt;&lt;endl;//因为存入vector中下标是从0开始的,所以要用i-1,(i-1)/2即是排序好的奇数个数中的中位数 &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1325]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1325%2F</url>
    <content type="text"><![CDATA[P1325 雷达安装传送门 题目描述1234567描述：假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围d。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。数据使用笛卡尔坐标系，定义海岸线为x轴。在x轴上方为海洋，下方为陆地。样例1如图所示 ！样例12345678输入输出格式输入格式：第一行包括2个整数n和d，n是岛屿数目，d是雷达扫描范围。接下来n行为岛屿坐标。输出格式：一个整数表示最少需要的雷达数目，若不可能覆盖所有岛屿，输出“-1”。 12345678输入输出样例输入样例#1： 3 21 2-3 12 1输出样例#1： 2 这题我的思路过程 这题遇到的坑 1.雷达的范围,以及坐标值最好都要用double来确定精度,否则int和double混用来进行计算的时候往往会出现问题* 2.这题的思路刚开始有问题,刚开始我是把所有岛屿的横坐标作参照进行排序,但其实这样会漏掉很多种情况,虽然也是基于贪心的思想, 但是这样子会把横坐标小但是纵坐标很高的情况排到左边,于是就会产生误差* 正确的思路应该是:因为已经知道每个岛屿的坐标和雷达的范围,所以以每个岛屿为圆心以雷达的半径作圆交于X轴都能够得到两个坐标 此时这两个坐标即是雷达所在位置的两个极值,此时按一般的思路从左往右从小到大进行排序, 把所有确定雷达的右坐标从小到大进行排序,首先确定第一个雷达的位置为确定第一个岛屿的右坐标,num++, 然后以这个右坐标为基准,因为贪心的思想,我在两个极值(a,b)之间虽然我放在a或者ab之间的某点都能够覆盖这个岛屿, 但是我如果把这个雷达放在最右边的b点的时候能够覆盖更多的岛屿,所以我放在最右边的b点, 判断这个b点是否大于第二个点最左边的a点,如果可以的话说明这个雷达能够覆盖第二个点,说明就不需要再新加雷达了 然后依次类推,如果这第一个的b点小于某一个点最左边的a点,说明覆盖不到,所以需要新加雷达站,num++ 所以再以这个点的b点为基准来进行判断,然后依次类推,就可以算出雷达站最少的数目了。‘* 3.第三个坑就是雷达站怎么也覆盖不到的情况,即岛屿的纵坐标y恒大于雷达的范围d,那么不管怎么样 都覆盖不到该岛屿,即返回-1 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;//P1325 雷达安装const int maxn = 1010;int num = 0;//存放雷达数int N;//N表示岛屿的数目double d;//d表示雷达的范围struct Node&#123; double x,y;//x,y分别代表岛屿的横坐标和纵坐标&#125;;Node radar[maxn];//定义一个结构体数组来存放岛屿的横纵坐标Node coordinate[maxn];//定义一个结构体数组来存放确定半径之后每个岛屿左右雷达的坐标值double cmp(Node a,Node b)//待会sort的时候以每个岛屿确定的最右边的雷达坐标来从小到大进行排序&#123; return a.y &lt; b.y;&#125;double rightradar(Node a)//已经确定最右边的岛屿,算最右边雷达的X坐标&#123; return a.x + pow((d*d-a.y*a.y),0.5);&#125;double leftradar(Node a)//已经确定最右边的岛屿,算最左边雷达的X坐标&#123; return a.x - pow((d*d-a.y*a.y),0.5);&#125;bool val(Node x)//判断岛屿是否超出了雷达站的范围&#123; if(x.y &gt; d) &#123; return false; &#125; return true;&#125;int main()&#123; //输入数据 cin&gt;&gt;N&gt;&gt;d; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;radar[i].x&gt;&gt;radar[i].y; &#125; for(int i = 0;i &lt; N;i++) &#123; if(!val(radar[i])) &#123; cout&lt;&lt;-1; return 0; &#125; &#125; for(int i = 0;i &lt; N;i++)//计算每个岛屿的左右雷达坐标的极值,并存放到结构体数组中 &#123; coordinate[i].x = leftradar(radar[i]); coordinate[i].y = rightradar(radar[i]); &#125; sort(coordinate,coordinate+N,cmp);//以每个雷达站的右坐标为标准从左往右进行排序 double temp = coordinate[0].y;//先计算第一个雷达站 num = 1; for(int i = 1;i &lt; N;i++)//然后根据第一个雷达站的坐标为基础来进行进一步的计算 &#123; if(temp &gt;= coordinate[i].x) &#123; continue; &#125; else &#123; temp = coordinate[i].y; num++; &#125; &#125; cout&lt;&lt;num;//输出结果 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1182]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1182%2F</url>
    <content type="text"><![CDATA[P1182 数列分段Section II传送门 题目描述1234567891011121314151617181920212223242526272829303132333435对于给定的一个长度为N的正整数数列A-i，现要将其分成M(M≤N)段，并要求每段连续，且每段和的最大值最小。关于最大值最小：例如一数列4 2 4 5 1要分成33段将其如下分段：[4 2][4 5][1]第一段和为6，第2段和为9，第3段和为1，和最大值为9。将其如下分段：[4][2 4][5 1]第一段和为4，第2段和为6，第3段和为6，和最大值为6。并且无论如何分段，最大值不会小于6。所以可以得到要将数列4 2 4 5 1要分成3段，每段和的最大值最小为6。输入输出格式输入格式：第1行包含两个正整数N,M。第2行包含N个空格隔开的非负整数Ai,含义如题目所述。输出格式：一个正整数,即每段和最大值最小为多少。-------------------------------------------------------输入输出样例输入样例#1： 5 34 2 4 5 1输出样例#1： 6 这题我的思路: 这题遇到的坑 1.cmp初始化应为1,或者最后应加1,因为M表示的是分成多少段,而我却搞成了有多少个分隔,导致运行错误* 2.temp初始化为0,之后若temp + num[i] &gt; x,直接令temp = num[i]再进行下一轮循环,而不是令temp = num[i+1] 比如 4 2 4 5 1,如果temp = 4,x = 4,4 + 2 &gt; 4,则此时应有一个分隔即4 | 2 4 5 1,此时再令temp = 2开始寻找下一个分隔,而不是令temp = 4(2之后的4)再进行寻找* 3.如果当cmp &gt; M之后就可以结束循环判断为false,不必令cmp正好 == M,因为如果cmp &lt; M, 也满足条件的话那么只需在已经分好的中间再多加几个分隔符就行了,所以只需判断错误的情况 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;//P1182 数列分段`Section II`const int maxn = 100010;long N,M;//N表示有多少个正整数,M表示要分多少段long num[maxn];//存放数字的数组long long sum = 0;//求和以便进行二分查找long result;//最后的结果bool judge(long x)&#123; long temp = 0; long cmp = 1; for(int i = 0;i &lt; N;i++) &#123; if(num[i] &gt; x) return false; if(temp + num[i] &gt; x) &#123; temp = num[i]; cmp++; &#125; else &#123; temp += num[i]; &#125; if(cmp &gt; M) return false; &#125; return true;&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M;//输入 long l = LONG_MAX; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;num[i]; sum += num[i]; l = min(l,num[i]);//选取num[i]的最小值作为边界 &#125; long r = sum;//选取所有和来作为右边界 while(l &lt; r)//当l == r时才终结循环 &#123; long mid = (l + r) &gt;&gt; 1; if(judge(mid))//判断mid是否符合条件,如果符合就继续往左缩小边界 &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout&lt;&lt;l; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190706]]></title>
    <url>%2F2019%2F07%2F06%2F20190706%2F</url>
    <content type="text"><![CDATA[迟迟到来的总结以及这个暑假的展望嗯，没错，正式放假了四天之后我才记起来要写这个学期的总结和下个学期的展望了先说点题外话吧，自从这个学期搭建了博客以来我感觉还是挺不错的，能够在小地方记录记录自己的生活，写写近些天自己的烦心事，同时记录自己刷过的题目，我觉得挺好的！虽然近一个月都没怎么写了，但是我觉得我还是应该坚持下去，因为经常写博客真的很快乐，虽然确实好多都是些流水账或者重复的内容，但是能够记录自己的生活让我感觉每天生活都是有意义的，不管是学习还是做其他的事情，这样做的正反馈确实挺多的，所以，还需要坚持才行呢，以后我也需要看更多的书来提升自己的知识水平了~而不是天天打游戏~，嗯那就先写这么多好了总的来说这个学期没有做什么事情，可以说是完全浪费了一个学期，因为这个学期本来很宽松的时间并没有被我好好利用，我觉得这是一个很大的教训吧，有的时候过于轻松的环境反而会让人懈怠啊，可能这是老生常谈的话题了但是我还是不得不时刻提醒自己应该去注意这方面的东西，因为人是健忘的，有的时候不到最后一刻可能就没有行动的动力，嗯就像我基友这学期一样吧，上课和考试周都很轻松，这学期反倒挂了两门专业课，我觉得挺不可思议的，虽然确实，这专业课确实傻逼，但是就算不喜欢这门课想及格还是挺容易的 反正失去的时间已经挽回不了，所以我要做的就是怎么把未来的时间去规划好，嗯从放假开始也浪了五天了，是时候该收心来开始计划下这个暑假的学习了 这个暑假我打算主要的目标还是把数据结构学好，下周开始为期一个星期的集训就是很好的机会了，早晨讲课下午训练，感觉这是自己的一个很好的机会去见识下真正竞赛的水平是什么样的。训练结束完之后，还有半个月的时间1.重新复习高数，每天坚持刷五道题，重新开始学习概率论相关内容2.数据结构继续学习，每天坚持完成一道算法题(最好是洛谷上照着训练来一步一步刷题)3.开始学习计算机组成原理的相关知识(到时候买课本回来进行系统的学习和整理笔记)4.C++继续学习面向对象的部分，从八月份开始给自己找一个小项目去写5.观看相关网课，找到合适的网课进行学习(mooc Coursera上找到相关资料)6.每天的学习时间： 早晨：8:00 – 11:30 下午：14:15 – 17:15 晚上：18：00 – 20:00(做每日一题) 20:30之后为娱乐时间，坚持劳逸结合的方法，在学习的时候提升自己的学习效率，不分心多思考，多动手打代码，多和朋友交流，争取自己过一个充实的暑假！嗯，毕竟之前也浪费了那么多的时间了。 最后就是时间的安排了，计划大概八月初去旅游然后回家待一个星期左右的时间然后再回到学校进行半个月的学习，除去集训的时间外，大概有一个月的时间来给自己提升，这次切不可再浪费来之不易的暑假了，我也不给自己安排过多的任务，这个暑假如果能按照这个计划切实落实好的话我觉得我下个学期会很有底气地去做事情了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190616]]></title>
    <url>%2F2019%2F06%2F16%2F20190616%2F</url>
    <content type="text"><![CDATA[迟到好久来的日记摸了好久啊，可能有半个月了？从放松的时光一跃进入考试周，简直就像是在做梦一样，因为根本就没反应过来因为在我的印象里面这学期实在是过的太快了，从2月份开学一直到现在6月份三个多月的时间就这么被我过去了，感觉毫无意义，因为我发现我自己学习缺乏一个系统的过程，每天去leetcode或者洛谷刷题反而让自己没有多大的提高其实仔细想想也不会很奇怪，缺乏系统有效的体系单纯去刷题的提高是很有限的，所以我觉得暑假应该调整好自己的方向刚才又在看陈平教授的眉山论剑，觉得说的真的是太对了第一就是要关心天下大事，关心社会问题在这个时代要有自己的思考第二就是对于未来自己的专业，不是赶着时髦去选专业，而是选适合自己或者自己喜欢做的事情才是最正确的第三就是个人的进步，说来惭愧，我不止一两次在我日记里面写到了，本来大学刚开始就准备要好好学计算机，结果到现在两年了实在是说不上有多少进步，虽然说确实有很多客观的原因影响自己的学习但是人总不能给自己找借口吧，人就是这样子，不喜欢努力，想着天天躺在床上去就能够进步就能够成为大佬，怎么可能呢哈哈哈哈，看着知乎上那些初高中的小弟弟小妹妹们都比自己实力强，不禁心里想问自己心里难道就不会有压迫感吗，我仔细想了想可能也是因为自己周围的环境所造成的，宿舍的人确实过的太舒服了我感觉自己被他们所同化了，其次就是我自己所说的那句话，自己没有经历过的事情，是不会体会到那种感觉的，就是虽然看到知乎上面有那么多的天坑专业的硕士，博士有那么惨痛的经历，可是自己没有亲身体验过，所以没有那种危机感，但是确实，好的话就要听进去，方向比努力更重要，所以我在这里决定，暑假不能够再浪费了，正好在学校也认识了一个志同道合的朋友，虽然之前学校也认识一个沙雕网友还是我把它劝退了，但是在我看来他并没有那么坚定的决心去劝退去脱坑，对于天坑专业还有种幻想，还觉得自己有很多条后路，所以我不太想跟他一起，所以暑假和新朋友去一起参加培训，一起讨论题目甚至还可以一起去考pat，一起明年去考蓝桥杯，我觉得这是很好的事情，自己也确实需要去主动认识一些人了，毕竟你不主动谁来认识你，谁来和你交朋友呢，因为专业的缘故也没参加大学的社团感觉挺遗憾的，所以自己要亲手去弥补这个遗憾才行呢，在网上认识更多的大佬，同时自己也需要更加努力去提升自己的实力才能够配的上跟别人交朋友的资格呢 其次就是这次618自己也买了几本书，我发现自己对经济，近代史方面确实还挺感兴趣的，所以之后为了提升自己的人文素养也要去看这方面相关的知识，到知乎上面多浏览，和知乎上的大佬们多讨论，要形成自己的看法，形成自己的观点，到b站上面多看看陈平教授这样的视频去提升自己的素养，而不是整天去打游戏，最后一学期下来甚至整个大学下来都没有什么收获，嗯但也不是说不去打游戏，偶尔打打游戏还是可以的，但是要掌握一个度才行，每天要完成任务比如完成一道算法题，刷了leetcode或者学了一个算法才能够自己打游戏，否则就不行，所以在7月2号考完之后所以应该进入考研的模式了，同时每天也要坚持对英语和数学的学习才行，嗯虽然自己的技能栏还是空空如也，但是我相信只要有信念什么时候都不算晚。 说到底道理谁不知道呢，关键就是大学里面实在是没有自己喜欢做的事情，只有赶着这个时代的潮流了，想起看过吴军博士写过的《浪潮之巅》，确实心潮澎湃，生活在这个变革的时代，不去顺应潮流去做点什么事情，难道不会感到遗憾么，所以坚定自己的决心去当一名geek不也是挺酷的事吗，但其实对自己来说，可能不逼一逼自己就根本就没有危机感和压力感，所以暑假和朋友要好好讨论讨论自己未来的道路了。 嗯，下个星期就是复习周了所以当前的主要目标就是要应付完这个学期才行，起码及格才行吧，但是能考高一点就高一点，就算自己以后不从事化学这方面的事情，绩点高一点对自己也是无害的。所以加油吧，最后的半个月的时间，需要自己去好好的专注到专业课的方面了，在最后这几天好好努力一把吧，在自习室要提升自己学习的效率了，等考完了再来写日记好好规划下自己吧！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-033]]></title>
    <url>%2F2019%2F06%2F09%2FLeetcode-033%2F</url>
    <content type="text"><![CDATA[33. 搜索旋转排序数组题目描述传送门123456789101112131415161718假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路:数组在某个点进行了旋转，那么原来的数组就不是有序的了，所以我们需要遍历数组来找到那个分界点那么问题来了，怎么才能找到那个分界点呢？ 因为题目要求算法的时间复杂度为 O(log n) 级别,所以我们就不能遍历数组来找到那个分界点 而是应该用二分查找的方式来找到那个分界点才能满足时间复杂度的要求 那么怎么用二分查找来获取那个分界点呢？ 答案就是比较low,mid,high三个点的值的大小比较,如果mid &gt; low,说明low到mid之间是有序的所以令low = mid + 1,否则low到mid之间是无序的，令high = mid 最终知道low == high的时候就找到了分界点，然后再比较分界点之间与target的大小然后再分别到两个区间进行二分查找，可以满足要求 代码如下:1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; //System.out.println(left); int split_t = left; left = 0; right = nums.length - 1; if (nums[split_t] &lt;= target &amp;&amp; target &lt;= nums[right]) left = split_t; else right = split_t; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190528]]></title>
    <url>%2F2019%2F05%2F28%2F20190528%2F</url>
    <content type="text"><![CDATA[两周年回顾嗯这个打算这个星期写完吧，好好总结和反思一下自己，希望未来能够以此引以为戒。 今天还是开了两周年的班会，不知不觉已经两年了，我也从一个新生成为了一个老学长油条了呢青春，就是在不知不觉中慢慢流逝的呢今天的班会上说了些莫名其妙的话，其实根本都不是我内心里面的真实想法，嘛，毕竟这种东西只能对亲密的人说呢 好吧，那现在我好好总结下我这两年的生活吧17年高考完毕之后，填志愿，那时自己也是真的挺傻的，填志愿都不知道去找几个对应专业的学长学姐问问具体的情况，自己在知乎上就随便搜了几个热门的专业确实是想去学计算机和电气相关的专业，可以填六个志愿，最后一个不知道填什么就随便填了化学，于是乎，命运就这样跟我开了个巨大的玩笑，让我的生活发生了巨大的转折 没错呢，分数不够计算机和电气的专业，于是进了化学系，当时的我确实已经产生了后悔的感觉了，但是这种感觉并不强烈，嗯因为自己没有那种强烈的危机感，自己根本就不知道未来的人生计划到底怎么样，于是像个傻子一样没有目的一样的生活，但是自己给自己定的目标就是要远离化学的坑，说来惭愧，过了两年了自己的编程水平并没有什么明显的提升，但是我并不后悔因为后悔也没用了 大一两个学期都是满满的课，每天上课指纹签到，每天晚上都有晚自习，怎么说呢那段时间还是挺让人怀念的吧，如果对于一个好好学习的学生的话确实挺充实的，有我喜欢的微积分的课和vb的课可以上，别的科目虽然不怎么喜欢但是当时自己没有什么别的想法，还是挺充实的吧，说实话那段时间确实还在经常抱怨什么的，因为确实很累，但是回过头来现在这样懒散的生活反而导致自己没有了原来的动力了。仔细回想了下大一真的没有做什么事情，最大的遗憾可能就是错过了计算机协会吧，其实我内心是想进入一个社团去体验一下大学生活的，但是很可惜，当时自己没什么技能也没什么实力所以也没有进入。(其实内心是炒鸡后悔的，错过了认识一大群可爱的人的机会)第二个遗憾的事情可能就是没有好好努力学习知识了吧，把自己的绩点搞上去达到专业的前15%就可以申请转专业了，因为当时自己也不知道转专业的条件和限制，等到了大二去问导员才知道只能大一上学期才能转专业，然而到了大二下学期才知道学校又稍微放宽了大一的转专业的限制，不需要成绩达到前15%就可以申请(所以又错过了一次又一次的机会) 不知道为什么呢，人生就是这样的戏剧性，一次又一次的错过，一直有一件事想搞明白，造成这样的原因到底是因为运气呢还是命中注定呢，不管是大学，高中，甚至是初中，可以改变我命运或者说是人生道路的明明有好几个，但是都被我完美的错过或者说没抓住机会，我真应该好好反思下自己为什么会一而再再而三的犯同样的错误了。 第三个可能做得唯一一件有意义的事情就是去考了计算机二级的证书吧，说来也搞笑，当初自己大一上就报了计算机二级考试，还报了两门，一门C语言和一门office，结果自己复习了好多天，考office还遇到的是原题，结果最后考出来两门都没有过，当时真的是，自己去查成绩真的是想死的心都有了，因为还是自己叫另外一个同学去报考的，他也报了两门，结果别人两门都过了，自己两门都没有过，这种巨大的落差真的是让自己感觉好难受，是的，人生本来就是一直在和别人进行比较的时光，我本来心态也一直不好，当时真的是想去跳楼之类的，但是现在想起来这算什么呢，人生的挫折多了去了，可能就是因为要经历过很多很多事情才能锻炼出自己强大的内心吧。嗯，然后下半年又去报了一门C语言，还是自己一个人去的，万幸，这次终于过了，虽然没能拿到优秀，但是良好也挺不错了，总之这次过了之后自己的内心才能有所释怀，毕竟是大学的第一个证书啊，然后我自己下定决心，趁着大学剩下的时间要把能考的证书全部考了(flag无疑) 第四个不好的事情可能就是大一下的无机化学了吧，这个给我的印象挺深的，无机的一次期中考试，考完之后我在全班是倒数第二，这个成绩真的是震惊到我了，可以说是第一次不完全意义上的挂科了吧，然而让我想到我室友的挂科的惨状，下个学期莫名其妙多了一门课要去学，还有补考，那真的是炒鸡痛苦啊，然后我下定决定好好学，万幸最后居然过了，这次给我的警告让我知道了大学决不能挂科啊，不然带来的后果简直就是太痛苦了。 emmmmm好像没了呢，大一好像就这些给自己深刻印象的事情了。 大一的暑假，可真的是太混了，在暑假打了两个月的游戏，说好要学习也没怎么学(间接导致了我现在的现状)想出去旅游也找不到人可以一起出去玩，那时候真的是孤独和寂寞啊，现实中也找不到人可以一起玩，网上也没多少人可以说话，我也不知道当时我是怎么过来的。 然后就进入了大二吧，大二刚进来的时候就进行了所谓的实训，快乐了半个月吧，去博物馆参观和去化工厂参观，说实话其实就是一个走流程的东西，根本就学不到什么东西，去参观化工厂给自己的感受就是又苦又累的生活，我自己下定决心以后要远离这种生活呢。然后大二的课也是好多好多除了好多实验就是好多无意义的课了，当然还有我最讨厌的大物了说起来我也不知道为什么按理来说数学好的人物理不会差到哪里去，但是我偏偏是相反的那一个了，数学还行吧，但是物理真的是巨差无比，哈哈哈我好像不喜欢那种抽象出数学模型的东西。可能我做的最明智的一个决定就是去参加数学竞赛了吧，说巧不巧，其实我之前也不知道这个消息的，还是我一个朋友告诉了我想跟我一起参加比赛之后才有这个想法要去参加一下比赛，嗯买了一本那个黄书去学，每天晚上去学那个知识，真的是炒鸡痛苦，因为我真的是很不喜欢证明题，然后就准备了几个星期去参加初赛，说实话我到现在都不知道是怎么跟我算的成绩，我明明感觉我初赛考的稀烂。。。。然后就告诉我过了，然后要我去参加复赛不过那次经历真的让我超喜欢啊，出去代表打比赛什么的，真的是好有成就感，什么东西都能找学校去报销，和一个同学在酒店住了一晚上hhh那天晚上真的是好美妙啊，好像晚上八点就复习不下去了，从第一天晚上的八点睡到第二天的七点，足足睡了十二个小时，这可能是我这辈子睡的最久的一次了，然而第二天复赛的题目真的好难啊，我好多题都看不懂，最后还是草草的虽然写了然后就交卷了，然后再和别人一起回学校。嗯最后出结果我居然还是考了个省一，真的是在我的意料之外啊，虽然不那么完美，但是对于误打误撞就获奖的我还算挺幸福的了，从此我也知道要好好学习只有自己的实力不断的提升才能自信的去面对任何困难(还有一个惊喜就是前几天突然告诉我省一原来还有奖金hhhh，意外之中的收获吧，但是不知道多久才能打到我的卡上qaq) 之后印象深刻的事情可能就是元旦晚会了吧，不知道为什么呢我就是想参加表演呢，因为感觉自己大学确实没参加过什么精彩的事情呢，于是就和几个室友和同学一起去表演了一个话剧，啊，每天晚上上完晚自习都去练习，动作什么的都要练好练到位，现在想想真的是挺辛苦呢，其实是挺浪费时间的。到了上台的那一天真的是，说实话因为其他人的节目都挺精彩反而我们的节目不那么精彩了，所以没能在同学的记忆里面留下深刻的印象，说实话我挺灰心的，因为付出小于回报，自己辛辛苦苦练了几个星期的节目还不如别人一个女装的印象深刻xd，但是总之还算是很美好的一个回忆了。 然后就是这个学期，大二下学期，可能是最舒服的一个学期了，课也没多少，我也经常逃课去自习，自己可以利用的时间真的是多多了，但是很可惜啊，从三月份到五月份，整整三个月的时间我的水平还是没什么长进，还是停留在数据结构这上面很久了(说到这个真的是对自己好气好气，有的时候不逼一逼自己根本就不行)但是这个学期说实话我并不觉得轻松，因为有三门跟物理相关的专业课要去考试，今天已经2号了，24号就要考第一门了，留给我的时间已经不多了，我决定就算要复习每天也要坚持学习算法，这个绝对不能断，自己给自己买的专栏要看，要实现的算法要坚持自己去实现一遍才行，再加上昨天到的xm3耳机，不能再找借口去放松什么的了，争取重新到达高三那时候的水平，不能再安逸下去了。对了还有15号的6级考试，这个也要认真的去准备，争取一次过，不能让明年考研的时候还被这个困扰。 好了，星期二就开始想写的这个东西我今天终于摸完了，说实话这两年其实不那么精彩，我在大学认识的人也太少了，可以获得的信息也太少了，以后要主动去认识更多更有趣的人才行呢，改变别人不如改变自己，主动去认识别人主动和别人交朋友才能充实自己嘛，虽然有时候会遇到尴尬，但是自己不主动就不会有故事呢！在网上也是这样，争取到知乎上认识更多的小可爱(划掉)qaq哼唧嗯，总结篇就写这么多吧，过几天再写关于未来具体的计划和要达成的目标吧。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1141]]></title>
    <url>%2F2019%2F05%2F24%2FluoguOJ-P1141-dfs%2F</url>
    <content type="text"><![CDATA[P1141 01迷宫传送门题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式：第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来mm行，每行22个用空格分隔的正整数i,j对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式：m行，对于每个询问输出相应答案。 输入输出样例：1234567891011121314151617181920212223242526272829303132输入样例#1： 2 201101 12 2输出样例#1： 44--------------------------------------------------输入样例#2： 8 410010011011001001001001101011011100010000001101100101000000000101 28 66 24 3输出样例#2： 2519125 思路：定义一个数组val来存放迷宫，定义一个数组cmp来判断是否走过1.这道题一眼看上去就是一个深搜，把01用二维数组存下下来，搜索每一个格子然后判断合理情况，如果遇到不相同的格子就记录然后每遇到一个点就重新memset一下cmp重新开始噼里啪啦一顿dfs交上去，TLE了三个点只有70分 2.这样做问题出在哪里呢？我把测试数据看了一下，发现很恶心，n和m分别取到了1000和100000，那显然，memset是很耗时间的于是我想到把cmp数组的标记改为layer，代表所搜索的格子所在的不同联通块。这样，每一次去数新一个格子所能联通的块数就只要更新layer，节省了很大一块时间(这样就不用每次memset一次cmp数组我觉得这样的做法很巧妙)成功过掉了第二个点也就是n=1000, m=10000的点 3.但是还有两个点TLE，说明还要需要改进的地方需要我去思考苦苦思索，是与否有其他优化方法，果然，有一条很明显的但是一早就被我忽略了： 同一个联通块所在的格子，能到达的格子数都是相同的。这样一看，怎么记忆化就已经很明显了，我们已经用cmp数组标记过了当前搜索的格子所在的联通块，用layer表示，那么我们只要再开一个record数组，将已经遍历过的联通块对应的格子数记录下来，那么搜索到相应联通块里的其它格子时，就不用再搜索了，这是一步很大的优化，最终我提交了修改过的代码，100分ac 自己遇到的坑：第一个坑: OJ上要求的是直接输入一串数而不是一个数字一个数字输入的我觉得这个挺坑的，我就懒得换了，直接char一个数组去接受，然后再int一个全局数组去修改对应的值，这样做其实挺傻的，还有可以改进的地方~(但是我懒啊)~第二个坑: OJ要求的输出是输入数据之后全部输出，所以就还要再定义一个sum数组去存放数据，最后再全部输出。 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int maxm = 100010;int num = 0;int layer = 1;int record[maxm];char sum[maxn][maxn];int val[maxn][maxn];//定义一个二维数组才存放n*n的迷宫int cmp[maxn][maxn];int n,m;//n表示n*n迷宫,m表示询问的点的个数//方向数组int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; cmp[x][y] = layer; record[layer] = ++num; for(int i = 0;i &lt; 4;i++) &#123; int a = x + dx[i],b = y + dy[i]; if(val[a][b]==val[x][y]) continue; if(cmp[a][b] == layer) continue; if(a &gt; 0&amp;&amp;a &lt;= n&amp;&amp;b &gt;0&amp;&amp;b &lt;= n) &#123; cmp[a][b] = layer; dfs(a,b); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;sum[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; (sum[i][j] == '1')&amp;&amp;(val[i][j] = 1); &#125; &#125; int sum[maxm]; for(int i = 0;i &lt; m;i++) &#123; num = 0; int temp1,temp2; scanf("%d %d",&amp;temp1,&amp;temp2); if(record[cmp[temp1][temp2]] == 0)&#123;//如果record里面temp1和temp2对应的cmp的值为0的话就进行dfs，并记录到record中 dfs(temp1,temp2); sum[i] = record[cmp[temp1][temp2]]; &#125; else//遇到相同的联通块直接输出对应的record &#123; sum[i] = record[cmp[temp1][temp2]]; &#125; layer++; &#125; for(int i = 0;i &lt; m;i++) &#123; cout&lt;&lt;sum[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-022]]></title>
    <url>%2F2019%2F05%2F24%2FLeetcode-022%2F</url>
    <content type="text"><![CDATA[22.括号生成难度:medium123456789101112题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路：应用递归的思路来解决这道题只有当左括号大于右括号的时候才进行递归但其实递归的实质就是栈的实现 代码如下:123456789101112131415161718192021class Solution &#123;public:void val_generateParenthesis(int left,int right,string str,int n,vector&lt;string&gt;&amp; val)&#123; if(left &gt; n || right &gt; n) return ; if(left == n &amp;&amp; right == n) val.push_back(str); if(left &gt;= right)//只有左括号的数目大于右括号再进行递归 &#123; val_generateParenthesis(left+1,right,str+'(',n,val); val_generateParenthesis(left,right+1,str+')',n,val); &#125;&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; val; val_generateParenthesis(0,0,"",n,val); return val; &#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190523]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[半个月来摸出来一点东西吧上回写日记还是5月12号，一晃眼就已经23号了啊这个五月我过得还是比较充实的，基本上实现了基本预定的目标不管是学习上还是其他方面，但是现在面临的问题也更多了诶多，6月15号的六级考试过了之后，23号就要开始期末考试了今天正好整整一个月的时间吧，不说之前重复的话了，没意思，好好努力吧，争取让充实的五月不忘初心吧 今天晚上又发生了不好的事情呢，我和好朋友又吵架了呢，像个hape一样那么大声在街上吵架。。。简直就像是失了智一样，我发现我有的时候就喜欢这样。。。喜欢跟别人较真，喜欢跟别人死磕，每次都是因为一些小事吵起来真的挺无语的，吵架的时候非要分个对错才行吗？有的时候想想就能明白的道理，自己却不去想不去思考，那再有用的大道理又有什么用呢？ 所以啊抛弃这种幼稚的思想吧，努力去成长为一个大人吧！ 这其中也发生了好多好多事情，我也想借这个机会聊聊我自己的看法，比如中美贸易战以及Trump制裁华为这几件事，让我觉得世界并不太平，Trump的目的可能是和以前的日本一样逼迫中国签订类似广场协议的条约所以去年中兴被制裁，领导人直接就去谈判了，今年华为更加严重反倒没去，说明我们是准备和美国打而不是准备去谈判妥协问题。但是我觉得这个时代自己不能太缺乏知识了，还是要去多了解历史经济相关的知识才行。最近看b站上陈平教授的&lt;&lt;眉山论剑&gt;&gt;，我觉得陈平老师的知识很精辟也很到位，对当前一些热点问题的分析我觉得有自己独特的看法，而且也敢说话，没有架子我决定去买本陈平教授的&lt;&lt;代谢增长论&gt;&gt;，多看一点历史案例和西方的一些兴衰史真的是很有意思啊，丰富自己的知识和阅历，我还从来没有主动迫切的想买一本书的时候啊。。。。其实增加自己的知识水平比打游戏更有意思，我决定大学还有两年要利用好时间去学习更多相关的知识，争取能够早日达到能够在知乎上分析问题得出自己观点的水平吧！ 可能是一个最好的五月，也可能是一个最坏的五月x，具体怎么样全看你自己了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1443]]></title>
    <url>%2F2019%2F05%2F23%2FluoguOJ-P1443-bfs%2F</url>
    <content type="text"><![CDATA[P1443 马的遍历题目描述有一个n*m的棋盘(1&lt; n,m &lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步 输入输出格式输入格式：一行四个数据，棋盘的大小和马的坐标 输出格式：一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1） 1234567891011121314151617181920#输入输出样例输入样例#1： 3 3 1 1输出样例#1： 0 3 2 3 -1 1 2 1 4输入样例#2：6 9 1 1输出样例#2：0 3 2 3 2 3 4 5 4 3 4 1 2 3 4 3 4 5 2 1 4 3 2 3 4 5 4 3 2 3 2 3 4 3 4 5 2 3 2 3 4 3 4 5 4 3 4 3 4 3 4 5 4 5 思考:这题就是一道很典型的bfs的题目根据题目给的首节点，来存入队列里面定义方向数组来模拟马走的八个方向然后把首节点存入队列，然后取出首节点，依次遍历八个方向，然后如果可以就Map2 = Map1 +1这样的话根据这个递推公式可以推出所有可以走的点最后还记得定义一个path数组来判断是否走过就行了 这道题目里面的坑:题目要左对齐宽五格所以要printf(“%-5d”,Map[i][j]) 代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;//P1443 马的遍历int n,m;//定义const int maxn = 410;//定义方向数组来定义马走的八个方向int dx[8] = &#123;1,2,2,1,-2,-1,-2,-1&#125;;int dy[8] = &#123;2,1,-1,-2,1,2,-1,-2&#125;;int Map[maxn][maxn];//定义一个数组记录棋盘上的int path[maxn][maxn];//定义一个路径来判断是否走过当前路径struct Node&#123;//定义一个结构体才存放棋盘坐标的值 int x,y;&#125;;queue&lt;Node&gt; val;//定义一个来存放结点void bfs(Node s)//传入结点&#123; val.push(s); Map[s.x][s.y] = 0;//定义开始为0，其余的结点都是依照这个点而来的 path[s.x][s.y] = 1;//记录路径为走过 while(!val.empty())//如果队列里面不为空则继续循环 &#123; Node temp = val.front(); val.pop(); for(int i = 0;i &lt; 8;i++)//八个方向来进行探测 &#123; Node cmp;//定义一个中间变量来存放数据 cmp.x = temp.x + dx[i]; cmp.y = temp.y + dy[i]; if(path[cmp.x][cmp.y] != 0||cmp.x&lt;1||cmp.x&gt;n||cmp.y&lt;1||cmp.y&gt;m) continue; path[cmp.x][cmp.y] = 1;//记录为走过 Map[cmp.x][cmp.y] = Map[temp.x][temp.y] + 1; val.push(cmp); &#125; &#125;&#125;int main()&#123; memset(Map,-1,sizeof(Map));//定义Map上所有结点为-1，如果这个值不会改变则说明这个点根本走不到 Node s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s.x&gt;&gt;s.y; bfs(s); for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; printf("%-5d",Map[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1162]]></title>
    <url>%2F2019%2F05%2F20%2FluoguOJ-P1162-dfs%2F</url>
    <content type="text"><![CDATA[P1162 填涂颜色123456789101112131415题目描述由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字11构成，围圈时只走上下左右44个方向。现要求把闭合圈内的所有空间都填写成22.例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：0 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1-----------0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 输入输出格式输入格式：每组测试数据第一行一个整数n(1&lt;=n&lt;=30)接下来n行，由0和1组成的n×n的方阵。 方阵内只有一个闭合圈，圈内至少有一个0。 输出格式：已经填好数字2的完整方阵。 输入输出样例12345678910111213141516输入样例#1： 60 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1输出样例#1： 0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 说明: 1&lt;=n&lt;=30 思路:定义一个a数组来接受方阵，然后定义一个b数组，在a数组的外围套一层边界，也就是套一层0，这样做的目的是为了让dfs边界的时候能够把闭合圈以外的部分都能够标记(也就是染色) 然后定义方向数组，从(0,0)开始往四个方向依次寻找两个边界中间的部分然后标记，然后b数组对应没染色的地方就是a数组方阵闭合圈里面要找的 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 40;//定义最大的边界int a[maxn][maxn];//用来接收方阵的数组int b[maxn][maxn];//把方阵外面套一层边界,便于dfs寻找边界int N;//N表示N * N的方阵//方向数组,依次为右下左上int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; //当dfs寻找值碰到外边界和内边界时返回上一层 if(x &lt; 0|| x &gt; N+1||y &lt; 0||y &gt; N+1||b[x][y] != 0) &#123; return ; &#125; //如果没碰到边界,继续搜索,令两个边界中间的值为2,并沿着四个方向继续搜索 else &#123; b[x][y] = 1; for(int i = 0;i &lt; 4;i++) &#123; dfs((x + dx[i]),(y + dy[i])); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N; //输入方阵 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(a[i][j] == 1) b[i][j] = 2; &#125; &#125; dfs(0,0);//对加过边界的b数组进行搜索 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(b[i][j] == 0) &#123; a[i][j] = 2; &#125; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-019]]></title>
    <url>%2F2019%2F05%2F15%2FLeetcode-019%2F</url>
    <content type="text"><![CDATA[19. 删除链表的倒数第N个节点难度：medium1234567891011题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。 我自己的思路:(两次遍历链表的想法)先定义一个num遍历链表记录结点的总数，然后定义一个cmp = 0，当再次遍历到num - n -1时就表明这个时候的结点是在要删除结点的前一个结点，然后再进行删除操作 这题遇到的坑：不知道leetcode到底有没有头结点，结果最后发现没有头结点，head对应的就是第一个结点，最后定义了一个newhead做头结点来进行操作，如果 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* newhead = new ListNode(0); newhead-&gt;next = head; int num = 0,cmp = 0; ListNode *temp1,*temp2; temp1 = newhead; temp2 = newhead; while(temp1 != NULL)//统计链表的结点数 &#123; temp1 = temp1-&gt;next; num++; &#125; while(cmp != num - n -1 )//定位到要删除结点的前一个结点 &#123; temp2 = temp2-&gt;next; cmp++; &#125; ListNode * flag = new ListNode(0); flag = temp2-&gt;next; temp2-&gt;next = flag-&gt;next; return newhead-&gt;next; &#125;&#125;; 官方的题解思路： ###方法一：两次遍历算法 ###思路 我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。 ###算法 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。 Java代码如下:123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next;&#125; ##复杂度分析 时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。 ###方法二：一次遍历算法 ###算法 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 Java代码如下:1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next;&#125; ###复杂度分析 时间复杂度：O(L)，该算法对含有 L个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-018]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-018%2F</url>
    <content type="text"><![CDATA[18.四数之和难度: medium1234567891011121314151617题目描述:给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路:回顾一下三数之和的思路:三数之和的主要思路在于双指针的遍历先把数组从小到大排序，然后再从nums[k]开始从左往右进行遍历因为a + b + c = target此时只要 b + c = target - a相等的话就算找到了然后就是相当于定义两个双指针分别对应 b 和 cint i = k+1int j = nums.length() - 1然后 i , j从k的右边到数组的边界，从两头分别开始进行遍历如果nums[i] + nums[j] &lt; (target -nums[k]) 那么就说明i还需要更大一点才能相等,i++如果nums[i] + nums[j] &gt; (target -nums[k]) 那么就说明j还需要更小一点才能相等,j–最后nums[i] + nums[j] == (target -nums[k]) 的时候记录数据这个时候进行去重的操作，因为第一次相等之后，如果i,j,k后面还有重复的数字的话那么就会有重复的结果那么如果遇到符合条件的重复数组就i++,j–,k++去重 四数之和==&gt;三数之和==&gt;两数之和跟三数之和类似，多了层循环遍历数组，同时也需要注意数组的去重操作1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); for(int k=0;k&lt;nums.size();k++)&#123; int i = k + 1; int j = nums.size() - 1; while(i &lt; j)&#123; int value = nums[i] + nums[j]; if(value &gt; (0-nums[k]))&#123; j--; &#125;else if(value &lt; 0-nums[k])&#123; i++; &#125;else&#123; vector&lt;int&gt; list; list.push_back(nums[k]); list.push_back(nums[i]); list.push_back(nums[j]); res.push_back(list); while(i&lt;j &amp;&amp; nums[i] == nums[i+1])&#123; i++; &#125; while(i&lt;j &amp;&amp; nums[j] == nums[j-1])&#123; j--; &#125; i++; j--; &#125; &#125; while(k&lt;nums.size()-1 &amp;&amp; nums[k] == nums[k+1])&#123; k++; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190512]]></title>
    <url>%2F2019%2F05%2F12%2F20190512%2F</url>
    <content type="text"><![CDATA[一点点小总结吧迟到了两天才有时间写个总结，我也真是懒啊hhh忙碌复习一周的感觉简直就是要了我的命，从零开始学习令我厌恶的化学真的是让我作呕可是我又能有什么办法呢(笑)，为了不挂科，也只能用心的去学了呢，每天一有空就去自习室简直就是让人窒息啊，就感觉提前进入了复习周一样难受啊，不过以后每个周末都要好好努力复习了呢 总之总之，期中考试终于over了，接下来是新の五月的生活啊虽然已经过了一半了，但是也要好好的充实才行呢 这几天又发生了几件让我不开心的事情呢，果然不是每个人都是善意的呢，有的人不喜欢被主动勾搭，有的人不喜欢和我说话，真的是好遗憾呢 诶多诶多，这每天记流水账一样的日记简直就是让我想吐啊233333，果然每天还是应该乱写点想写的东西才好吗 啰里啰嗦了半天还是决定以后如果有意义的事情再来写日记吧233333那么就这样吧今天，希望以后能继续写更多有意义的东西呢]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190509]]></title>
    <url>%2F2019%2F05%2F09%2F20190509%2F</url>
    <content type="text"><![CDATA[令人绝望的星期四嗯，一个星期唯一没课的一天，硬是自己把自己搞自闭了，早晨7点本来只想趴着休息会，结果睡着睡着就睡到九点半了，唔，然后一个上午相当于啥都没干，中午又睡了个觉磨磨蹭蹭到三点钟才起床去自习室，然后到自习室混了7个多小时到十点左右再回来 结构真的是好难啊，好多东西我都搞不懂，还有一天多的时间去学，还有物化这块硬骨头要啃，呜，这个星期过了我就好好做人，游戏都删掉的我要过一个不一样的五月！ by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190508]]></title>
    <url>%2F2019%2F05%2F08%2F20190508%2F</url>
    <content type="text"><![CDATA[星期三的烦恼嗷今天真的是忙碌的一天嗷，从早到晚满课嗷，今天凌晨四点钟突然惊醒然后睡不着，到床上折腾了半天估计有半个小时吧才睡着，诶诶多结果一醒来结果利物浦居然把巴萨逆转了！！！哇塞，创造历史的一场比赛啊，还没有球队能够在客场0比3的情况下，主场逆转翻盘！真的是荡气回肠的一场比赛，说实话我其实挺喜欢利物浦的，尤其是渣叔克洛普，我超喜欢的！真心希望利物浦能赢得欧冠啊，去年的遗憾今年不能再重蹈覆辙了。 早晨日常逃课，但是早晨学习的效率是真的低啊，又困又要学习，真的是好难熬啊嗷嗷，期中考试的一周真的是难受难受难受难受的要死了，一个星期要学完前面几个月的知识我真是个天才哈哈哈哈哈哈嗝才怪，希望这星期能应付完期中考试吧，再准备其他比赛。 晚上真的是没心思学习了，晚上看汉堡王做活动没忍住买了四五十的外卖呜呜呜，我真的是败家玩意嗷，还口口声声说减肥呜，估计又要胖回去了，嗯嗯这一定是最后一次，嗯最后一次啦，以后为了减肥可不能再这样了5555555 最后就是不能理解为什么要晚上停电维修，唔，明明早晨宿舍都没人它不去检修，非要晚上还没睡觉的时候就停电检修，搞不懂电力部门在想什么 那么今天就这样吧，晚安啦，希望明天没课的一天我能复习完物化和结构的大部分。 by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190507]]></title>
    <url>%2F2019%2F05%2F07%2F20190507%2F</url>
    <content type="text"><![CDATA[今日份的记事今天真的是不一样的一天呢 早晨日常去上体育课，本来以为要体测做引体向上，结果那个老师是个明白人233333，我本来一个也做不了的qaq结果挂上面抖了抖就给我算满分了hhhhh，然后测完中途就溜回去洗了个澡就休息了，嗯挺不错的。 中午倒是发生了一些事情让我有点害怕，中午日常吃饱饭，但是一站起来就感觉胃特别不舒服，还好我室友给了我胃药缓解多了，但是以后必须得格外注意了，不能吃的太饱233333 下午好不容易起来去自习室，但是感觉还是效率不是太高，好在今天把物化第二章复习完了，接下来就是明天继续复习第三章和去写期中考试卷子了，嗯感觉这个星期如果熬过去感觉这次的考试是可以挺过去的。 晚上倒是发生了很多愉快的事情，和同一类人聊天是真的愉快，说什么话都能很快就明白根本不用多费口舌，别人说什么东西也能很快就能懂意思，不仅仅是一起讨论问题还是去探讨一些别的话题，我们在一起聊天是真的很开心很开心！希望以后多和这样的好朋友在一起为未来的前途努力吧！说实话真的是很烦为什么没分配到一个宿舍里面啊真的是，我现在越来越讨厌我的室友了，真的不是一类人，只会天天打游戏，应付考试应付别人，关键是还喜欢影响别人，等着瞧吧，再过两年我们走着瞧咯。 这个星期复习完专业课后要重新开始学习算法，英语和数学，嗯一个也不能拉下，尤其是已经把游戏全部都卸载掉了，嗯五月初自己说过的话千万不能再忘了，已经失去太多的东西了好像已经没有再可以失去的了，一起学习的朋友晚上熬夜到三点中还在做leetcode，感觉自己跟别人比起来真的是太舒服了，要找回原来的那种状态，要去让每一天都充实起来才行！加油吧，每天都不忘初心方得始终。 by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190506]]></title>
    <url>%2F2019%2F05%2F06%2F20190506%2F</url>
    <content type="text"><![CDATA[预习第一天的感受不开心的第一天嗷，不过早晨做实验是真的混啊2333333，本来以为今天要做很久的实验，看了那么一大堆步骤，结果老师都不让我们去做，给了个粗品要我们直接去提纯，简直太快乐了啊哈哈。 昨天Trump的一条推特导致今天A股暴跌真的是闻所未闻，都快跌6%了，简直就是股灾啊，看别人评论说的，别人美国总统一句话就能让你一无所有，很真实，股市的风险确实是太大了，我觉得我在大学这个阶段一定要慎之又慎才行，我搞这个心态又不好23333，所以要锻炼自己在金融方面的知识才行呢，做一个知识全面的人才行呢。 下午就不怎么快乐了，今天开始复习物化了，但是真的是好烦啊，本来就不喜欢物理相关的知识，但是这学期两门专业课都涉及物理，简直让我绝望5555555，还以为就算不怎么好好学考试考好点能拿奖学金呢，可惜这学期估计科科及格都难咯 下午在自习室从4点一直搞到9点半，除去要去上课签到花了点时间，差不多有将近五个小时的时间都可以学习，但是效率是真的低，在自习室整个人都快自闭了，太安静的环境也不适合去学习，脑阔里面非要听点电音或者轻音乐才能去集中自己的注意力，但是有的时候听多了反而又容易走神23333，真的是很难抉择呢，但是好在是已经开头了，我有信心去准备这次的期中考试，这个星期好好努力吧，争取达到能应付考试的水平就行了，然后下个星期再开始准备学习算法，天天运动，嗯，这学期不能再像之前那样了 这可是你自己说要过一个不一样的五月啊，成年人就应该信守自己所作出的承诺。 嘛，今天就写这么多吧，每天写日记写博客真的是让自己很喜欢这种生活，为什么不早点开始坚持记录自己每天的生活呢？嘻嘻]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190505]]></title>
    <url>%2F2019%2F05%2F05%2F20190505%2F</url>
    <content type="text"><![CDATA[今日份的不知所云嗯，五一假期后的第一天上学，感觉还行吧，感觉自己的状态有所回升呢，但是感觉还是要加把劲呢，还有一个星期从零开始准备期中考试啊，真的是最不舒服的一个星期要来了呢 今天真的是莫名其妙的惊喜呢，空间里面突然有个大佬加我，真的是猜不透呢，不是一个世界的人原来想接触我这样的普通人吗？感觉别人的思想真的是不一样呢，想去顶级名校，想去拯救整个社会，想去改造别人的思想，想去像儒家一样去兼济天下，唉，可惜呢，只有生存无忧才会去想这些事呢，继承家产，到大城市的地方有几套房，我如果有这么好的家室就好了啊，有钱可以买自己想买的东西，也没有学业，事业上面的压力就好了，可是啊，这只能存在于幻想之中呢，现实就是我出身一个十八线小城市，没车没房，家里也没钱，唯一值得庆幸的就是父母都挺开明的，知道自己没什么知识，敢于让我自己去做决定，自己去做决定自己未来的人生道路，我觉得这也是不幸中的万幸了吧！ 还有一件事就是我今天才知道我的一个室友前几天刚脱单，这几天又找到了新的女友，怎么说呢，别人大学都谈了三次了我还一次都没有，怎么说呢，从小到大我可能对感情都没有概念吧，被老师把恋爱这个选项在脑海中删除了(其实也有小学到高中越来越丑越来越胖的原因)，但是谁不渴望爱情呢，不说那么奢侈的东西吧，我其实渴望被关心，渴望和别人每天聊天，渴望和别人分享自己的快乐和烦恼，谁喜欢孤独呢，孤独都不是被逼的吗？如果遇到合适的人和志同道合的人，谁又想一个人呢。 诶多，不知不觉又写了这么多，我也不知道自己天天在说什么，但是感觉日常写日记真的让自己感觉很棒，我会继续坚持下去的，记录自己生活的点点滴滴，这样的感觉真的很棒，等我觉得哪天我的东西可以分享给别人的话就会给你们看的，毕竟日记也不是不可以分享给别人的东西，我也希望有人来看我每天生活的点点滴滴，希望以后能遇到更多更棒的朋友！ by Azure]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-002]]></title>
    <url>%2F2019%2F05%2F04%2FLeetcode-002%2F</url>
    <content type="text"><![CDATA[2. 两数相加难度 : medium题目描述:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。12345示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析：两个非空的链表表示两个非负的整数，既然是按照逆序的方式来储存，那么就应该对两个链表分别从头开始遍历进行加和操作 用x,y来分别取出两个数对应的数位,用carry来记录是否需要进位先令carry = 0,再计算sum = x + y + carry;如果 sum &gt;= 10,则令carry = 1再让 sum % 10来组成新的数的每一位如果其中一个链表有数可以取出,而另一个链表的下一位为NULL则令为NULL的那一条链表对应的x或者y为0即可 然后最后结束的时候如果carry还为 1,说明最后还多出来一位,则应该再额外多进1。 自己在这题中遇到的问题:Leetcode给的构造函数(struct跟class一样啊，我真的是有点傻了)既然它给的有构造函数ListNode(int x) : val(x), next(NULL) {}则初始化对象的时候一定要调用,那么定义新的结点的时候就一定需要一个初始值(比如0),否则会报错。 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p1,*p2,*p3; ListNode *l3 = new ListNode(0); p1 = l1; p2 = l2; p3 = l3; int carry = 0; while(p1 != NULL || p2 != NULL) &#123; //如果对应的数位为NULL,则直接令其为0 int x = (p1 != NULL) ? p1-&gt;val : 0; int y = (p2 != NULL) ? p2-&gt;val : 0; int sum = x + y + carry; (sum / 10)? (carry = 1): (carry = 0); ListNode *s = new ListNode(0);//定义一个新的结点来存放结果,一定要初始化才行 s-&gt;val = sum % 10; p3-&gt;next = s; p3 = s; (p1 != NULL) &amp;&amp; (p1 = p1-&gt;next);//代替if的语句 (p2 != NULL) &amp;&amp; (p2 = p2-&gt;next); &#125; if(carry)//如果最后carry还为1,则说明还需进一位 &#123; ListNode *s = new ListNode(0); s-&gt;val = 1; p3-&gt;next = s; p3 = s; p3-&gt;next = NULL; &#125; l3 = l3-&gt;next; return l3; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新の开始？]]></title>
    <url>%2F2019%2F05%2F04%2F20190504%2F</url>
    <content type="text"><![CDATA[新の开始胡乱写一些自己都看不懂的话重新再来，从头开始真的是令人怀念的话语啊,上一次说这个话是高考前一百多天的时候,结果说完也没有多么努力去改变自己的命运,结果自己到了今天这个地步,如今,实在是没有什么可以再失去的东西了 青春？梦想？努力？奋斗？再为自己的年轻付出巨大的代价之后才会后悔,可是又能有什么用呢？一次又一次的悔恨,一次又一次的失败，我实在是厌倦这样的生活了,不知道两年前的自己怎么也想不到今天会到这种地步吧，不仅什么也不会，而且也缺少朋友，缺少能天天和我一起说话的人 孤独？谁又喜欢孤独呢，谁希望自己被逼成这样呢，孤独的人也渴望和朋友一起聊天，一起分享每天的欢乐，一起诉说每天的烦恼，这是我梦想中的生活啊。 然而，每天简直就是有无穷无尽的烦恼，不仅是学业上还是生活中。经过了两年的时间，自己还是啥都不会，虽然早就下定了转行的决心，但是相比跟我年龄一样的科班的人，差距还是巨大，只有每天付出比他们更多的努力才能让自己变得更强生活上，每天被室友吵得心烦，天天只会打游戏，混日子，每个星期还要去实验室跟老师搬砖还浑然不知未来的处境如何，真的是感觉可悲，真不知道再过两年他们会有什么感受。 想起了高中班主任跟我说的话，眼界决定境界，态度决定高度，这句话我现在细想起来还真的是太对了，但可惜我两样都没有论眼界，从小城市出身的我真的是眼界太低，见识也太低了，居然稀里糊涂的报了化学这个天坑专业，高中还以为化学挺有意思的，谁知道大学完全是两个完全相反的学科，跳进了坑真的是感觉自己蠢到极点。论态度，我明知道每天自己该干嘛，却还是天天摸鱼，喜欢看b站，喜欢逛知乎，喜欢玩游戏，反正每天除了学习真的是一堆事都能做，但是只要学习就容易犯困，提不起劲，这个学期把没用的课都翘了好好学算法，学相关一堆知识可以学，但是我还是喜欢浪费时间，整天摸鱼，然后从2月份一直到现在，我真的忍受不了了，必须做出一点改变来才行了，不然就算再给两年的时间给自己也是白费。 已经20岁了，不再是一个小孩子了，是时候该为自己的未来，为自己的前途好好考虑一下了，人不是为自己而活，你还要付出很多很多东西才行，不说那么远，就说为了将来自己幸福的生活现在也应该要好好行动了。嗯，今天把游戏全都卸载了，时间是宝贵的，再也经不起我这样浪费了，两个月的时间，我想重新调整自己的状态，该去自习室去自习室，该休息休息，以后每天十一点上床睡觉，决不熬夜，只有晚上睡好了早晨才有精神去学习，去做其他事情。这个月，再也不能跟自己开玩笑了。总结下最近应该准备的东西吧1.英语六级，每天背10-15个单词2.物理化学，结构化学复习，先把期中考试撑过了再说吧。3.每天一篇算法题目(期中考试前可酌情减少)4.订阅的专栏每天阅读两到三篇文章，有问题多跟小伙伴去讨论5.知乎上多跟别人互动交流，诶多自己不主动怎么会有更多的朋友呢emmmm，如果可以每个星期摸出一篇高质量的回答吧！争取把点赞数和关注数都上去吧，多跟别人到想法下面去互动吧！6.Linux入门吧，再不入门说不过去了。7.继续算法的学习，这个每天不能丢。8.运动也不能停，但是可视情况减少相应的跑步次数来去学习。 嗯，就写这么多吧，现在好像也总算养成了写博客写日记的习惯了，希望再过一年两年的自己再回过头来看不会后悔吧！加油啊]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五一假期的一点感想]]></title>
    <url>%2F2019%2F05%2F02%2F20190502%2F</url>
    <content type="text"><![CDATA[五一假期的一点感想阿拉阿拉，这个学期最舒服的一个月快要走到尽头了呢，从四月份的清明假一直到现在的劳动节假期，整整一个月的时间，每天逃课每天玩手机，每天想干嘛就干嘛，现在再让我回想起去年天天满课的时光，我都不知道我是怎么度过来的emmmmm 这个月主要有两个烦人的事情，第一个就是期中考试吧，虽说已经知道结构期中考试可能不算成绩吧，但是这也不是我逃避它的借口，嗯要花时间去重新学起来，还有一个就是物化了，物化期中考试老师都很认真，所以我也要去认真的去准备它，起码不能挂科吧，额，所以最近要开始找回上学期的那种状态咯诶多我想想啊，从5号到10号这六天时间要复习预习准备考试，怎么想都够呛，额，为了准备它我还额外到网上买了学习指导和习题解答，这尼玛还不及格那就真的是自己的问题了，好好加油吧。 还有一个烦的就是体测了，虽说上个星期刚测完一千米，但是下个星期还要去测引体向上，我我我没臂力真的一个也做不来啊qaq，诶多，期末还要考颠球什么的，要是体育也挂科了那多丢人qaq 嗯，嗯因为长假的缘故我又到学校外面订了两个晚上的酒店准备放松下自我，准备去试试新买的小裙子什么的，诶多说实话我还从来都没试过呢xd，嗯我喜欢安静的环境，想和别人打游戏语音也不会吵到别人，也不会有傻逼室友来吵我烦我，所以说对于我来说，我适合独居生活而不是群居！ 哼唧，如果以后能跟喜欢的人一起合居就好了qaq，嘛，既然已经知道自己放假不可能好好学习了，那还不如玩的爽一点呢，诶多，就写这么多吧，以后估计要经常写日记了hhh]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-206]]></title>
    <url>%2F2019%2F04%2F29%2FLeetcode-206%2F</url>
    <content type="text"><![CDATA[206. 反转链表难度:easy反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 自己的解法：思路:至少需要三个结点p1,p2,p3来完成链表的逆序首先从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点、第三个节点。实现链表逆序的完整步骤如下：1.以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。2.三个临时节点引用p1，p2，p3分别向后移动一格位置。3.重复第1步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。4.重复第2步的工作，三个临时节点引用p1，p2，p3分别向后移动一格位置。5.继续像这样子迭代下去，一直到p2是空为止。6.最后，把head节点的next指向空，成为逆序链表的尾节点。并且把p1赋值给head，让p1所在的节点成为逆序链表的头节点。 实现代码如下:方法1：迭代1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) &#123; return head;//当头结点为空，或者它的下一个结点为空的话，返回head &#125; ListNode *p1,*p2,*p3;//声明三个中间变量来交换 p1 = head; p2 = head-&gt;next; p3 = NULL; while(p2 != NULL) &#123; p3 = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p3; &#125; head-&gt;next = NULL; head = p1; return head; &#125; &#125;; 方法2: 递归递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø 若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。 n1 → … → nk-1 → nk → nk+1 ← … ← nm 我们希望 nk+1 的下一个节点指向 nk。 所以，nk.next.next = nk; 要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。 实现代码如下:1234567public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p;&#125; 复杂度分析 时间复杂度：O(n)。假设n是列表的长度，那么时间复杂度为O(n)。 空间复杂度：O(n)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到n层。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九周小结]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第九周小结不知不觉，一个星期又过去了，好像还是老样子，还是那么喜欢摸鱼，还是那么喜欢混，可能是上几个学期的努力过头了吧，这个学期实在是太轻松了，人就是这样，有的时候没有外部的压力可能就不逼自己，道理谁都懂，可谁都喜欢去犯懒，谁都喜欢去打游戏，看剧之类的，学习的过程是枯燥的，在这个漫长的过程中学习所能得到的正反馈太少了，所以本来从17年高考结束开始就决定学编程，到现在19年快两年了感觉根本没什么长进，我自己都觉得自己是个傻逼。 方向不对，再多努力也是白费，前几天看扬叔写的小说真的是触目惊心，王奋斗不努力吗？并不是他不努力，只是他一步又一步的犯错，本来人试错的成本就已经很高了，更何况还一而再再而三的试错？ 没错，王奋斗的经历确实有点夸张，但正是因为这种夸张作者才想要深切的告诉我们，天坑专业不是一般人能读的啊，不管是学术界还是工业界，不管是去当导师廉价的劳动力还是去化工厂做危险的工作，我觉得都是不可接受的，所以更加坚定了我脱坑搞CS的决心 可怜我那几个室友，现在天天去实验室搬砖像个傻子一样，一点觉悟都没有，等过几年再看看他们是什么处境吧 顺手记录下这个星期所发生的大事吧星期一没上物化课，在宿舍摸了一整天，勉强完成了当天的任务 星期二上了体育课，把假条也给了老师看了，重新去踢了足球比赛但是是真的累啊，不知道为什么每天晚上运动了那么久，结果去比赛还是累的要死。但是下个星期二要测一千米啊啊啊啊，说实话挺烦的。 星期三上午去自习的效率还行，可能这是唯一让我感到满意的一天了吧，晚上去公园茂玩了一晚上，也挺开心的吧，虽然公园茂那里的小吃并不让我特别感兴趣 星期四一天没课，下午我又没去自习，本来是早就要跟基友一起去自习的，但是却都不互相监督，真的是无语呢，所以啊挺想找个跟我一样的人一起去考研一起去学习，甚至能一起恋爱呢(~大雾~) 星期五这一天可真的太无语了，早晨睡了一早晨不说，下午第一次准备去逃马原课，第一次去逃老师就点名，还是基友和我室友一起帮忙说我请假了才搞定的这事，现在想想就心有余悸，如果当时我一开始就冲过去就好了，真的是不幸中的万幸了晚上去找到了我五一订的酒店的位置，看起来还不错吧，物超所值，差不多是花了上回出去住一晚上的价钱住了两个晚上，期待出去住呢还去丹尼斯购物了一波，说实话有点小失望吧，其实大超市也没什么东西好买的，就买了两盒饼干和一点小零食，唯一让我开心的就是里面有卖仲景香菇酱的吧，以后可以不用到网上买了嘻嘻，然后又去公园茂转了一圈，转了半天都不知道吃什么，最后结果去吃了渔粉，说实话不是很好吃，而且也不值这个价55555555，最后是出去花了一百多真的是败家啊，以后要开始省钱了呢星期六一天啥也没做，又浪了一整天，晚上还花了40点了汉堡王的外卖，而且因为天气的原因这一个星期都没跑步，我真的是太草了今天星期天，上午摸过去，下去去自习室吧，晚上签个到去跑步然后就结束这一个星期吧 诶多这个星期买了小裙子订了酒店还有各种乱七八糟的居然花了1k了，这么抠门的我居然能花这么多，其实是心痛死了啊啊啊啊啊啊啊啊，如果不是上个月发现了闲鱼上可以赚点小钱现在我岂不是更穷5555555555555，而且最近闲鱼上买东西的越来越少了，我应该要想点办法去卖更多的东西了，诶多争取以后一个月起码有2K才行？ 所以继续明确一下下个星期的目标和每天的任务吧，不多也不少，但是每天要坚持完成，没完成就给自己惩罚！每天的任务:1.开始准备6级考试，每天十五个英语单词，期中考试过后每天还要两篇阅读理解2.张宇1000题每天五题3.洛谷OJ or Leetcode 每天一题4.程序员小灰 or 极客时间 每天一章5.微信小程序(这个比赛我将信将疑了，因为感觉学JavaScript和那个好费劲，但毕竟是我提出的计划，嘛有时间就去看看吧)6.王道数据结构开始看，题目也开始做吧7.准备期中考试，物化重点复习，结构次重点复习。(五一看看能不能复习一哈子，然后5.11之前复习完) 好了，总结和感悟就这么多吧，以后争取至少每个星期写篇日记吧，还要把刷过的每一道题都放到博客上来，嗯，过几天再把评论区和其他东西完善一下，如果可以的话再搞个域名就更好了，那么Azure加油吧！你现在不是一个人在战斗呢。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷Oj-P1101]]></title>
    <url>%2F2019%2F04%2F24%2FluoguOj-P1101%2F</url>
    <content type="text"><![CDATA[洛谷OJ-P1101P1101 单词方阵题目描述给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：12345678910输入： 8 输出： qyizhong *yizhong gydthkjy gy****** nwidghji n*i***** orbzsfgz o**z**** hhgrhwth h***h*** zzzzzozo z****o** iwdfrgng i*****n* yyyygggg y******g 输入输出格式输入格式：第一行输入一个数n。(7≤n≤100)。 第二行开始输入n×n的字母矩阵。 输出格式：突出显示单词的n×n矩阵。 思路：1.用两个数组来表示八个方向const int dx_shift[10] = {1,1,0,-1,-1,-1,0,1};const int dy_shift[10] = {0,-1,-1,-1,0,1,1,1};2.在搜索到y之后沿着一个方向搜索izhong，直至不跳出边界为止，搜索完毕如果符合条件记录到另外一个数组中3.j是步长，这里的j正好对应了yizhong 的第j位 所以正好可以对应起来dx = x + j dx_shift[i];dy = y + j dy_shift[i]; 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//P1101 单词方阵int n;//n * n的矩阵//方向数组表示八个方向const int dx_shift[10] = &#123;1,1,0,-1,-1,-1,0,1&#125;;const int dy_shift[10] = &#123;0,-1,-1,-1,0,1,1,1&#125;;int dx,dy;const int maxn = 110;const string cmp = "yizhong";char Map[maxn][maxn],result[maxn][maxn];void dfs(int x,int y)//x,y表示当前点的坐标&#123; for(int i = 0;i &lt; 8;i++)//枚举八个方向 &#123; int flag = 1; for(int j = 1;j &lt;= 6;j++)//对同一方向连续探索6次,直至全部符合izhong为止 &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; if(dx &lt; 1 || dx &gt; n || dy &lt; 1 || dy &gt; n)//若越界直接跳出循环,换一种方向继续尝试 &#123; flag = 0; break; &#125; if(Map[dx][dy] != cmp[j])//如果探索的第j位不符合也跳出循环进行下一次搜索 &#123; flag = 0; break; &#125; &#125; if(flag == 0) &#123; continue; &#125; else//符合条件记录到数组中 &#123; result[x][y] = 'y'; for(int j = 1;j &lt;= 6;j++) &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; result[dx][dy] = Map[dx][dy]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;Map[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; result[i][j] = '*'; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; if(Map[i][j] == 'y')//如果搜索到y就进行搜索 &#123; dfs(i,j); &#125; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cout&lt;&lt;result[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八周小结]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一下这个星期发生的事情和心得吧星期二上午的体育课运气也太差了，从来都不点名的老师居然这次点名了555555555，害得我要去p一张请假条才行，星期三的早晨的效率挺高的，虽然逃了课。。。可是导员去查了前几个班的签到情况==，这尼玛谁顶得住啊，以后逃课要小心了、、、、今天看扬叔发的想法感觉好有道理 “学生上课的时候不听讲会被认为是违反课堂纪律，我如果觉得上课说话，那属于影响别人上课，但是我上课睡觉，看手机，只要我不发出声，那就不算违反课堂纪律”“你可以说是对老师的不尊重，但是学生是没得选的，如果双方都有平等的选择地位，我不喜欢我可以走，可以不来上课，但是我现在必须要来上课，你就不能以不尊重为理由批评我上课不听讲”“事实上，许多学生开始自己看公开课，看优质教材，用脚投票”是啊，因为劝退的原因我上课不能听讲，老师还经常要点我发言来误会我，有的时候想想也真的很气，不过他说的话真的深感认同 我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？这个星期又很好的摸了一个星期呢，反正每个星期天的豪言壮志，最后都会被自己的懒惰所无情的击败呢 可能是这学期的课过得实在是太轻松了吧，导致自己好像找不会上学期的那种状态了，甚至可以说在学编程方面连寒假的状态都不如了。 可是呢，人可能就是这样的一种动物啊，总喜欢为自己找借口，遇到什么事情都喜欢自我安慰，真的是太脆弱了呢，既然选择了这条艰苦的道路，那么就应该不后悔不放弃嘛，再苦再累又能如何呢？那些厉害的大佬可能这一辈子都追不上了，但是这就是自己可以不继续每天学习的理由吗？ 所以啊，已经过去了8个星期了，差不多两个月了，还有三个月，诶多，中间还要准备期中期末考试，啊真的是烦人，这学期的课我一点底都没有，跟物理相关的课程我就是白痴一个啊啊啊啊啊，反正再怎么样混了两年了，再混可能都毕不了业考不上研了，真是羡慕那些好好学习上课努力认真听讲，晚上回去天天打游戏，考试好好考就能搞个好绩点，然后保研爽一年什么的 哈哈哈哈哈，既然没有了这个选项那就不要天天幻想这啊那了，每天做好自己才是最重要的，所以啊，一定要坚持下去啊Azure，你不是为了你自己而活啊 下个星期的任务吧：1.每天一道算法题(leetcode / 洛谷OJ)2.这个星期一定要学会dfs和bfs算法！！！！！再拖我是狗3.继续学习JavaScript，完成微信小程序的比赛4.每天看一章程序员小灰关于算法的文章，不懂的一定要自己打出来才行！！！5.自己手打代码！自己手打代码！自己手打代码！重要的事情说三遍！6.王道数据结构继续阅读7.张宇数学1000题每天写至少5题！！！8.不要再说什么时间多了，要做的事情一堆呢！9.预习物理化学的内容，把期中考试先过了再说]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>记录自己的心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫评《ようこそ実力至上主義の教室へ》]]></title>
    <url>%2F2019%2F04%2F14%2F20190414%2F</url>
    <content type="text"><![CDATA[很遗憾前年7月的番昨天才被我偶然所发现，然后花了一天不到的时间就补完了，动画里面看到堀北就想起了雪乃，看到路哥就想起了大老师，然而看下来才知道这部番跟春物完全不同，春物是以校园恋爱为主题描述一群正常高中生的生活，而实教是以校园为背景展开一场斗智斗勇的作品，前者偏重于青春的描写，后者偏重于对人性的刻画 大老师和路哥(二老师)也是表面看上去差不多但其实完全不同的两个人，路哥心黑大老师心白。 路哥：我不是，我没有大老师：我也不是谦虚，这锅我背了。 大老师花式自爆收获后宫，而路哥则是个性冷淡，这也不难理解，动画最后一集本以为路哥会在铃音最虚弱的时候闪亮登场，击败坏人，获得美人芳心，迎娶白富美自此走上人生巅峰。然而路哥却开启王之蔑视，他把除了他之外所有人都当成了他赢得胜利的棋子，他根本不相信任何人，动画也随之戛然而止，还有很多东西都没讲清楚，过了两年也没出第二季也让人感觉深感遗憾。这也不难理解，因为从小说喵了个咪只有男主没有女主，动画还是强行魔改小说把铃音当做女主来写，之后几卷就没有铃音的戏份了，所以第二季很难做出来(脑瘫作者就不能跟这个作品好好写个女主吗) 之所以很喜欢这部番，感觉它把学校同学关系的那种真实感描写了出来，你所能看到的只是一个人的表面，很多人其实都是表里不一的，更不用说那些伪善的人了，每个人都喜欢隐藏自己的真实的一面，表里如一的堀北和人格分裂的桔梗就形成了鲜明的对比，路哥也是，表面上一副面瘫脸人畜无害的模样，实际上他把每个人都当做棋子，只要最终赢得胜利的人是他就行了。 引用逼乎上的评价，“有实力者不滥用实力，无实力者也能生存的反实力至上主义教室”嗯我觉得也是对这番最贴切的描述了 同时顺便期待下今年春物的第三季吧，嗯，希望能遇到更多这样有意思的动画。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>漫评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份不再摸鱼]]></title>
    <url>%2F2019%2F04%2F07%2Fdailylife%2F</url>
    <content type="text"><![CDATA[4月份再摸鱼我是狗懒真的是一种病，更可况还是懒癌晚期的我(划掉)，我的博客好像一个月前就弄好了吧，结果现在才想起来要写第一篇日志hhh无药可救了喵。 哼唧，重新看了看自己上个月立下的一个个flag，再摸鱼可能都毕不了业了呢，所以啊，azure从下个星期开始就要好好努力咯，虽然在学校没什么可以一起交流的人，室友也只会天天打游戏，像个傻子一样学化学，放假了还要跟导师免费搬砖，沦为廉价的劳动力还一副理所当然的样子，哼唧，我可不能变成这样呢，答应过别人不做一个普通人(真的是很奇怪的要求呢) 所以我再这么摸鱼下去就是混吃等死了，认识很多大佬每天都那么努力，再看看自己真的是，无话可说，有的时候不逼到最后一刻自己就不会醒悟的 既然选择了劝退这一道路就应该每天都一直努力嘛，其实可以做的事情真的是挺多的，但有的时候要学的东西太多了自己反而麻木了，诚然，在学习的道路上给自己的正反馈的确不多，但是这也不是自己能够为了逃避而找到了合理的借口x，所以我跟我基友一起商量不能再这么下去了，以后要计划好每天，每周以及每个月应该做到的计划，做到与没做到都要有奖励和惩罚才行。 每次自己做完的题解会发布到自己博客上，不管怎么样自己打出来的东西有一个记录也是极好的 下一周的计划:1.每天一道leetcode或者洛谷的题目(周三除外)(不能丢掉算法这方面的内容啊)2.这个星期学会dp算法和dfs&amp;bfs算法(dp摸了这么久了结果还没弄完我也是醉了)3.学习JavaScript相关知识，为微信小程序比赛做准备！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
</search>
