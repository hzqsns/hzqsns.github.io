<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode235-LowestCommonAncestorOfaBinarySearchTree-LCA]]></title>
    <url>%2F2020%2F09%2F27%2FLeetCode235-LowestCommonAncestorOfaBinarySearchTree-LCA%2F</url>
    <content type="text"><![CDATA[LeetCode486.二叉树的最近公共祖先-倍增法求LCA 55，周末有时间会写写题解离今年考试的时间不到三个月了呢。 题目 分析倍增法求LCA的大概思路 做法：先预处理两个数组depth[i]表示i在树中的深度，dength[1] = 1.f[i][j] ,表示i这个节点向上跳2^j的祖宗节点编号。可以通过递推算出后面的值。123fa[i][0] = 父节点;for(int k = 1; k &lt;= logn(下取整); k ++)fa[i][k] = fa[fa[i][k - 1]][k - 1]; 可以用dfs或者bfs遍历即可 ，为了防止爆栈一般用bfs.注意要设置哨兵方便运算。假如一些点往上2^k跳出了树，那么直接设置f[i][k] = 0;即可。 查找a，b的最近公共祖先步骤：1）假设a的深度比b大，反之交换即可。利用二进制拼凑的思想找到小于等于depth[b]的a所能跳到的最小值，然后a = f[a][k],直到两者相等为止。1234for(int k = logn(下取整); k &gt;= 0; k --) //哨兵的好处假如跳出去了，那么depth[a][k] = 0 &lt; depth[b] if(depth[fa[a][k]] &gt;= depth[b] ) a = fa[a][k]; 结束之后如果a = b 那么两者已经在同一点上了，返回a或者b即可。否则的话让两者继续往上跳，一直调到他们的最近公共祖先的下一层。因为如果调到同一层的话我们不知道这个点是不是ab的最近公共祖先1234567for(int k = log(n)下取整; k &gt;= 0; k --) // 哨兵的好处2假如两个点都跳出去，那么f[a][k] = f[b][k] = 0 ，就不会执行。 if(fa[a][k] != fa[b][k]) &#123; a = fa[a][k]; b = fa[b][k]; &#125; 最终答案就是f[a][0] 或者f[b][0]; 注意点 注意代码中depth[0] = 0这个哨兵的两个好处 我们最后是跳到共同祖先的下一个结点上，因为我们一直是倍增的再跳，很容易跳出最低的公共祖先，所以我们最后当fa[a][k] != fa[b][k]的时候a和b才分别跳到fa[a][k]和fa[b][k]上，最后这两个点一定不相等而且在祖先结点的下一层上 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: //因为leetcode不方便所以我把每个结点转化为以1开始的序号了 unordered_map&lt;TreeNode*,int&gt; change; unordered_map&lt;int,TreeNode*&gt; restore; static const int N = 40010; int depth[N],fa[N][16]; int k = 1; void invert(TreeNode* root)//转换 &#123; change[root] = k; restore[k] = root; k++; &#125; void bfs(TreeNode* root)//BFS初始化每个结点的深度顺便求出每个结点的祖先结点 &#123; depth[0] = 0; invert(root); depth[change[root]] = 1; queue&lt;TreeNode*&gt; t; t.push(root); while(t.size()) &#123; auto q = t.front(); t.pop(); int a = change[q]; if(q-&gt;left != nullptr) &#123; invert(q-&gt;left); int b = change[q-&gt;left]; depth[b] = depth[a] + 1;//儿子结点深度 = 父节点 + 1 fa[b][0] = a;//从b这个结点跳 2^0步就是自己的父节点 for(int k = 1;k &lt;= 15;k++) &#123; fa[b][k] = fa[fa[b][k-1]][k-1];//b结点跳2^k步 = b先跳到2^(k-1)到c结点，再从c结点跳2^(k-1)到祖先结点 &#125; t.push(q-&gt;left); &#125; if(q-&gt;right != nullptr) &#123; invert(q-&gt;right); int b = change[q-&gt;right]; depth[b] = depth[a] + 1;//儿子结点深度 = 父节点 + 1 fa[b][0] = a;//从b这个结点跳 2^0步就是自己的父节点 for(int k = 1;k &lt;= 15;k++) &#123; fa[b][k] = fa[fa[b][k-1]][k-1];//b结点跳2^k步 = b先跳到2^(k-1)到c结点，再从c结点跳2^(k-1)到祖先结点 &#125; t.push(q-&gt;right); &#125; &#125; &#125; int lca(TreeNode* a,TreeNode* b) &#123; int c = change[a],d = change[b]; if(depth[c] &lt; depth[d]) swap(c,d);//如果结点a在b的上面的话就交换 for(int k = 15;k &gt;= 0;k--) &#123; if(depth[fa[c][k]] &gt;= depth[d])//如果a这个点跳过2^k步后还是在b的下面或者同一层的话就跳 c = fa[c][k]; &#125; if(c == d) return c; //如果c和d 不相等的话，这个时候就说明a和b在同一层，然后此时应该两个点同时往上倍增的跳 for(int k = 15;k &gt;= 0;k--) &#123; if(fa[c][k] != fa[d][k])//如果同时跳2^k步还不相等的话继续跳 &#123; //cout&lt;&lt;fa[c][k]&lt;&lt;"--------------"&lt;&lt;endl; c = fa[c][k],d = fa[d][k]; &#125; &#125; // cout&lt;&lt;fa[c][0]&lt;&lt;"+++++"; //因为怕跳出最近的公共祖先，所以我们设定这两个点应该跳到祖先结点的下一层 return fa[c][0]; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; bfs(root); return restore[lca(p,q)]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode486-PredictTheWinner-dp]]></title>
    <url>%2F2020%2F09%2F01%2FLeetCode486-PredictTheWinner-dp%2F</url>
    <content type="text"><![CDATA[LeetCode486. 预测赢家-动态规划 54,偶尔有时间写写题解www 题目及提示 分析 这道题如果用暴力去求解的话，每一次数都会面临选或者不选的问题那么时间复杂度会达到O(2^n),题目中n最大为20，显然暴力会导致超时 这个时候就需要想到动态规划的思路了个人理解动态规划主要是那个dp数组的定义比较重要，而这个完全是要经过长时间做题的积累才能想到的 定义dp[i][j]表示示当数组剩下的部分为下标i到下标j时，当前玩家与另一个玩家的分数之差的最大值这里指的注意的是当前玩家并不是先手玩家或者后手玩家而是有可能为先手有可能为后手 关键点关键在于给出了dp数组的定义，如果去写出转移的方程根据题意可以知道对于下标i到j的数组中当前玩家可以选择nums[i]也可能选择nums[j]，那么我们怎么去选择呢？ 如果当前玩家拿nums[i]这个数，那么下一个玩家就只能从[i+1,j]这个范围去拿数而且下一个玩家比当前选了nums[i]这个数的玩家，根据定义多f[i+1][j]的分值那么当前玩家比下一个玩家多的分数就是nums[i] - f[i+1][j]同理，如果当前玩家拿nums[j]，那么下一个玩家就只能从[i+1,j]这个范围去拿数那么当前玩家比下一个玩家多的分数就是nums[j] - f[i][j-1]于是f[i][j] = f[i][j] = max(nums[i] - f[i+1][j],nums[j] - f[i][j-1]); 最后运用区间dp的思路从len = 2从小到大去枚举即可 注意点 因为当i == j的时候，只有一个可选，则当前玩家比下一个玩家一定多nums[i]个分值也可以理解为只剩下一个数之后，这个时候该当前玩家拿数，拿完nums[i]之后，另外一个玩家就拿不了了，就一定多nums[i]的数 因为当前玩家一定是先手的，所以看f[1,n]如果大于等于0的话表示从1到n当前玩家比下一个玩家拿的数要大，于是一定获胜 本题还有一个值得思考的点，就是如果数组长度为偶数的话，那么先手一定获胜因为数组有偶数个数的话，那么先手和后手都会拿相同的数，那么这个时候相当于把一组数分成两组相同数量的数了由于数组长度为偶数，玩家为偶数，则一方所拿的数都在偶数下标阵营，另一方都在奇数下标阵营。奇数下标阵营的数一定和偶数下标阵营的数大小不同或者相等两个阵营能拿的分数是确定的，故先手玩家可以从两个阵营中选择较大那个阵营从而使自己一定必胜。 代码如下123456789101112131415161718192021222324252627class Solution &#123;public: bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n % 2 == 0) return true; vector&lt;vector&lt;int&gt;&gt;f(n+1,vector&lt;int&gt;(n+1,0));//f[i][j]表示在下标i到j这个范围内，当前玩家比下一个玩家多的分值 //因为当i == j的时候，只有一个可选，则当前玩家比下一个玩家一定多nums[i]个分值 //可以理解为只剩下一个数之后，这个时候该当前玩家拿数，拿完nums[i]之后，另外一个玩家就拿不了了，就一定多nums[i] for(int i = 1;i &lt;= n;i++) f[i][i] = nums[i-1]; for(int len = 2;len &lt;= n;len++) &#123; for(int i = 1;i + len - 1 &lt;= n;i++) &#123; int j = i + len - 1; //如果当前玩家拿nums[i]这个数，那么下一个玩家就只能从[i+1,j]这个范围去拿数 //而且下一个玩家比当前选了nums[i]这个数的玩家多f[i+1][j]的分值 //那么当前玩家比下一个玩家多的分数就是nums[i] - f[i+1][j] //同理，如果当前玩家拿nums[j]，那么下一个玩家就只能从[i+1,j]这个范围去拿数 //那么当前玩家比下一个玩家多的分数就是nums[j] - f[i][j-1] f[i][j] = max(nums[i-1] - f[i+1][j],nums[j-1] - f[i][j-1]); &#125; &#125; //因为当前玩家一定是先手的，所以看f[1,n]如果大于0的话表示从1到n当前玩家比下一个玩家拿的数要大，于是获胜 return f[1][n] &gt;= 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200819]]></title>
    <url>%2F2020%2F08%2F19%2F20200819%2F</url>
    <content type="text"><![CDATA[再美好的时光终究也会就结束的那一天 & 写给四个月后的自己人类，不过只是喜欢不断的重复而且没有记性的生物罢了。终于，我是说终于，这场梦境终究要迎来它的结局了，是啊，想做梦一样今年不仅仅是发生了那么多的事情感觉像做梦一样，而且前几个月我自己做的事情也都像做梦一样，醒来的时候已经记不太清一样吧，几个月前的事我的记忆也很模糊了可能这就是人们口中常说的不操心的那种人吧 但其实说实话，我真的不觉得我是那种没心没肺的人，但是我的确很喜欢无厘头的去做一些事情，而且不喜欢重复，总想一次就把它做好。但其实真的能一次性做好的人，我觉得可能不存在于世界上吧，本身很多知识和记忆就是要通过不断大量的重复以及练习才能巩固的，既然大家都是普通人，你为什么就不喜欢多看几遍呢？ 我也觉得我有一个很大的毛病，就是喜欢假装努力。没错，就是每天给自己写一大堆计划，然后假惺惺的完成，自我感动你到底是想感动谁呢？所以现在想想真的是觉得好笑呢，到最后不懂的还是不懂，就这样完完全全的混过去了，以后要杜绝的就是这种现象，整天待到自习室或者图书馆还真以为自己学了个啥似的，所以，以后千万千万不要自我感动，这样子没有意义。 人们总是喜欢为自己找各种各样的借口，总之如果有什么事没做好或者说做错了，人们一定想到的就是开脱自己，自己永远是无罪的，自己永远是超脱凡尘的那种，只是因为一点点的外部因素就导致了失败，导致了放弃。我也是这样子的，在家里抱怨家里没有学习的氛围，但实际上呢，每天熬夜熬到那么晚，早晨起不来，然后中午午觉睡一两个小时，然后又匆匆忙忙的学了点，到了晚上以为自己白天真的很努力了然后摸鱼，每天都是这样子然后循环往复，最后就这么过了八个月。 说实话，现在回想起来真的很心痛，但是，再怎么心痛也都已经过去了，我现在要做好的就是把当下这剩下的四个月把握好，不管是什么原因，我想，自己也该为自己的前途拼搏一把了，就像当初高考最后只剩一百天我才急匆匆的醒悟，然后每天晚上学到两三点钟，但是最后还是没能如愿留下了巨大的遗憾。而三年后的今天，仿佛这种过程将会再一次的上演，所以我现在需要做的就是，避免类似三年前的重蹈覆辙]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>再美好的时光终究也会结束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200815]]></title>
    <url>%2F2020%2F08%2F15%2F20200815%2F</url>
    <content type="text"><![CDATA[有一点感慨。一点点小小的感慨。 本来，只是跟以前的同学老朋友聚聚的一天，但可能今天不太一样，因为平时我都只跟朋友B出来吃吃饭什么的，然后能够聊聊最近发生的一些烦心事，聊聊未来的规划和打算什么的。 但是可能这次不太一样，这次我跟B还专门把朋友C叫了过来一起吃饭 我跟C也是一年没见面了，上回在一起吃饭还是在去年的暑假，真的是时光荏苒呢。 我不禁感到了一丝的伤感，不仅仅是伤感时间过的如此之快，同时也是有点伤感自己的碌碌无为。 跟B和C开心的去吃火锅了，仿佛又回到了高中的快乐的时光一样。我们聊了很多，也感慨了很多，不过让我有点意外的就是C跟我提到了我另外一个曾经的朋友D的情况 没错，这个D就是和我从小学一直同学到高中，然后最后去年因为各种原因被我删掉的那个人；说实话，我跟他并没有什么仇恨，也没有什么恩怨，也许以前我曾经跟他吵过架，但是后来我们俩又都互相写信给对方又和好了，没错，我主动给他写的很长一封信，然后他也回给我很长的一段话。我当时也确实挺感动的，真的，那张纸现在还好好的保存在我的钱包里面躺着，我一直都没扔掉，虽然过了这么多年我还从来没有真正的再看过，可能他心里早就忘了这么一件事了吧，但是对于我这种重感情的人是不可能会忘记的，对，不管是当初美好的回忆还是不好的回忆，只要是给我留下深刻印象的东西，我都不大可能会忘。 但令我吃惊的是C跟我说，D准备今年去考西电了，我觉得有点不可思议，因为D跟我说的时候他说他准备去上交甚至是出国去挪威那边去读书的(D是学船舶与海洋工程的)没错，在我心里，D虽然一直是个很心机的人，但是我觉得他当初只去了哈尔滨工程大学会一直耿耿于怀的，谁知道现在的目标降低了这么多。 因为我对这位曾经的”好朋友”有着很深的执念，嘛一般人应该也能懂的，反正我不停的去追问C关于D的任何事，希望能知道他现在的真实的现状。 “D其实就是个铁渣男” “啊？”，我当时听到C这么说觉得真的有点不可思议，因为我虽然知道D这个人上过大学曾经交过女朋友，但是也不至于渣男的地步吧。 “不骗你，其实他当初高中的时候就已经跟我们班的妹子好上了” 我整个人都傻了，因为当初高中的时候完全看不出来他谈过恋爱，因为我们当时基本上都天天生活在一起，天天一起上课下课都走在一起，完全看不出来有过这样的感情经历。 “所以啊，你怎么知道D当时展现给你的是他的哪一面呢？” 我释然了，从当初小学到高中在一起的感情深厚，再到现在的不再有任何联系，我好像明白了点什么。可能他这样的人，也只需要一段时间的朋友吧，当初的感情深厚，可能也只是我稍微有点利用价值吧。 我还是很难受，可能看到这里的你也会懂的吧，你对一个人坦诚相待，什么事情都跟他倾诉，把他当成知心朋友来对待，而他却始终只拿出自己表面的一面来展示给你。 说实话打字到这里，我真的有点难受了，真的，我的电脑上还放着周杰伦的《退后》，不知道是不是巧合，反正让我现在不知道是什么心情 嗯，我忍不住把钱包的那张纸拿出来看了。 三年前的四月份给我写的纸条，现在虽然已经微微的泛黄，但勉强还是能看得清里面大概的内容。 原来当初我们的感情也能这么的深厚啊，三年的时间其实我都忘得差不多了，但我还是能记得当初我和BCD还有一群人晚自习十点后走在马路上一起聊天一起开玩笑的时光，已经我过生日的那天我们一起吃饭一起去看电影，现在回想起来是多么开心啊。 “别太过于回想着过去了吧，容易让你沉浸在那种伤感之中，反而不利于你以后的发展”，C可能也察觉到了我感情的变化，好心的跟我说道。 没错啊，再也回不到过去了，与其在这件事上过度的伤感，不如多去接触接触外面的世界，多去交交新的朋友吧。毕竟事实已经这样了 C还给我看了D的微博，没错，D的微博三年前被C不小心关注到了，所以他现在能一直看到D微博的情况，于是C把D的微博内容给我看了看，里面全是那种跟女朋友秀恩爱的那种微博，而且几年下来好像确实有不少，”渣男”的名号好像也被这样的事实所实锤了，而且里面的内容和他在我们面前展示的那个”他”确实差别太大了。 嗯，是的，人是会变的嘛，当初的美好永远都只是当初的美好而已，长时间的美好往往是可遇而不可求的，何必为一个人而念念不忘呢？写到这里，看着他曾经给我写的纸条，想着他现在的样子，我不禁泪目，但也更坚定了我自己的决心。 去认识更多的人，提升自己的能力，交到更多真正的朋友 调整好自己的心态，毕竟，这才是真正的社会的样子。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>突然就想写点什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200814]]></title>
    <url>%2F2020%2F08%2F14%2F20200814%2F</url>
    <content type="text"><![CDATA[刻骨铭心的一个晚上可能长这么大，才终于开始渐渐的明白什么叫做人生吧。 我可能再也忘不了今天这个晚上。 原本以为，这是一个平静的一天，虽然学校已经告知了我们20号开学了的通知，我难免会有点感到伤感，但内心似乎跟以往并没有多大的变化 又能有什么变化呢，八个月的时间都仿佛改变不了我的习性，今天晚上发生的一件事却真真切切的让我感受到了真的不再是一个小孩子了。 晚上八点，我本来跟往常一样在洗澡，洗澡洗到一半突然听到楼下爷爷在大声的叫我，我本来还不太情愿的，因为正常人洗澡的时候突然有人找你，你肯定也很不爽吧。 我起初还没太在意，甚至还大声的问楼下爷爷有啥事，然后他根本没回答我紧接着又大声的喊我的名字要我快点下来，这个时候我才意识到可能是奶奶出事了。 我赶紧把身上随便擦了擦就穿个内裤跑下楼了。 我一边下楼一边打我爸的电话，这边出什么事我一般都是会习惯先跟我爸说的 果然跟我想的是最糟糕的情况，我的奶奶勉强的坐在板凳上，驼着背，然后我爷爷用手用力的上下在奶奶的背上滑动 我说，“奶奶这是怎么了？身体很不舒服吗？” “你奶奶差一口气人就没了！” 我当时听到整个人都懵了，怎么会这样子？我整个人真的就直接愣住了，正好接通了我爸的电话，我就赶紧把情况跟他说了甚至把爷爷说的差口气就没了的情形告诉他，他甚至要我直接去打120，但是我犹豫了一下没打，现在回想其实挺愧疚的，万一奶奶后来真出个什么事，我没有及时的拨打120，这是我能用什么东西可以换来的呢？ 跟我爸打完电话，爷爷叫我继续跟其他的家里的亲戚打电话，先跟离家里住的最近的二伯打，然后再和还在外面玩的大伯打电话，最后以至于家里的人几乎没多久就全来了。 说实话现在回想起来我感觉挺温暖的，家里有家里人互相支持是多么棒的一件事啊，我哥哥甚至听到我给他打电话说的那么严重，直接闯红灯开车回来想着快点把奶奶送去医院，说真的，我真的感觉好温暖好温暖，家里人一有人出什么事大家都来帮忙。 但同时我也感觉真的很愧疚，因为出什么事除了叫人我不知道怎么帮忙，因为一些基本的急救知识我都不知道，当初学的时候感觉不是很在意，现在真正的遇到发生事了才手足无措，我真的觉得是有点悲哀的一件事，但谢天谢地的事就是，奶奶最后没事，不然我可能会愧疚一辈子吧。 家里人陆陆续续的赶来了，甚至我妈妈把我家那边当过医生的我的姨伯和姨妈也叫来了，我是真的觉得很暖心，好在最后没啥大事，奶奶最后整个人也精神了起来。唉，但我还是好担心啊，留在那边会给他们造成负担，不在那边又担心就他们两个老人家出了什么事没人知道。 终于慢慢缓过劲来了，我哥哥还半开玩笑的对奶奶说到，“您这可不能就这么去了，您这还没看到我结婚，您家最小的那个（指的我）还没工作赚钱给您享福呢”我奶奶听到也是脸上笑了出来，老人家嘛，其实心里上都巴不得自己早点去了，但是他们还是希望能在有生之年看到自己的孙子们都能有所出息的。 所以那个时候，我真的感受到了一份沉甸甸的责任，什么叫做responsibility，你不是为了你自己而活着的，你还有你的父母，你还有你的爷爷奶奶，你还有你的很多亲戚，所以你不能过的太自私，你不能为了自己的快乐将别人抛之脑后。 所以我更加惭愧了。惭愧的是自己大学这几年的碌碌无为，惭愧的是自己今年在家八个月还什么都没干，果然什么事情都要拖到最后才会被你重视起来吗？可能我就是这样一个性格的人吧，不断的反思，但是又不断的重复错误，所以我觉得了解自己是个什么样的人也是一件挺重要的一件事，知道自己的极限，知道自己喜欢干什么不喜欢干什么要分好主次挺重要的，同时我觉得，敢于迈出自己的舒适区也是必要的，就像数学你不能每天只刷自己会写的题，那样对你永远也没有提升。 写了这么多，今天真的很多感慨，明天还要去和老朋友们聚一聚聊聊天，感觉整天把自己憋在家里好像真的挺自闭的，不过马上也要去学校了，虽然已经知道再也回不去从前那样的日子了，但我还是希望能够在学校重新找回自己当初那种拼搏的精神，不管是在宿舍还是在自习室，我希望能够找回当初三年前的那个我，虽然三年前的我拼搏过了，但是考场上败在了心态上，我希望这一次，不再重蹈覆辙把。加油！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>难忘的一个晚上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200712]]></title>
    <url>%2F2020%2F07%2F12%2F20200712%2F</url>
    <content type="text"><![CDATA[对不起，我对你真的生气了，我也是有脾气的人请你不要再让我失望了]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode139-WordBreak-dp]]></title>
    <url>%2F2020%2F06%2F25%2FLeetCode139-WordBreak-dp%2F</url>
    <content type="text"><![CDATA[LeetCode139.单词拆分-遇事不决动态规划XD53期末告一段落，接下来重心会转移一点到pat上leetcode每日一题会坚持刷 题目及输入输出 分析 这题可以用动态规划的思想去做(一开始我也没想到)f[i]表示字符串从1到i的位置是否可以由字典wordDict里面的字符串组成那么我们可以枚举1到i-1的位置，设j枚举i-1到1如果f[j] == true &amp;&amp; check(s.substr(j,i-j))即j之前的字符串已经匹配，且从j到i的字符串也在字典中返回true此时f[i] = true; 注意点 f[0]要初始化为true，因为我们这个方法是把f[i]从1到i的字符串分成两段去判断，左边是否匹配，右面是否在字典中但是一开始从最左边开始枚举的时候没有左边，此时就要把f[0]设置成true，因为在最左边的时候只需要看右边是否在字典中即可 j从后往前去枚举比较好，因为j如果从前开始枚举的话，那么从头开始枚举，比如很长的一串字符串applepenapple，j从小到大枚举pplepenapple，plepenapple，lepenapple…直到枚举到apple才能返回true，从后往前枚举的话显然枚举不了几次就枚举到了，个人理解是因为前面的字符串大多都已经匹配了，dp的思路就是前面的字符串符合+后面的字符串在字典中即可么，那么肯定是从后往前枚举字符串快 代码如下12345678910111213141516171819202122232425class Solution &#123;public: bool check(string s,unordered_set&lt;string&gt;&amp; t) &#123; return t.count(s); &#125; bool wordBreak(string s, vector&lt;string&gt;&amp; w) &#123; unordered_set&lt;string&gt; t(w.begin(),w.end()); vector&lt;bool&gt;f(s.size()+1,0); f[0] = true; for(int i = 1;i &lt;= s.size();i++) &#123; for(int j = i-1;j &gt;= 0;j--) &#123; if(f[j] &amp; check(s.substr(j,i-j),t)) &#123; f[i] = true; break; &#125; &#125; &#125; return f[s.size()]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5188-KthAncestorOfaTreeNode-LCAmultiplication]]></title>
    <url>%2F2020%2F06%2F14%2FLeetCode5188-KthAncestorOfaTreeNode-LCAmultiplication%2F</url>
    <content type="text"><![CDATA[LeetCode5188. 树节点的第 K 个祖先 - LCA倍增 52时隔半个月继续更新，以后可能会更新技术相关的东西了。但每周的周赛会继续坚持更新 题目 输入输出 分析 我们可以设一个函数f(i,k),表示i的第2^k个父节点是谁 比如要求v的第m个父节点是谁m的二进制表示为1100101那么我们可以拆成2的次幂相加，即2^0+2^1+2^4+2^5v—-(走2^0步)—&gt;v1=f(v,0)—-(走2^1步)—&gt;v2=f(v1,1)—-(走2^4步)—&gt;v3=f(v2,4)—-(走2^5步)—&gt;v4=f(v3,5)最后v4即是我们要找的父节点因为我们是用二进制来优化的，所以询问一次最大的次数就是logm 我们的问题就来到怎么处理f(i,k)数组了f[i,0] = p[i]即i这个点往上走1步就是i的父节点p[i]f[i,1] = f[f(i,0),0]相当于i的第2^1个父节点就是i的第2^0个父节点再走2^0步的父节点同理f[i,2] = f[f(i,1),1]相当于i的第2^2个父节点就是i的第2^1个父节点再走2^1步的父节点依次类推f[i,k] = f[f(i,k-1),k-1]相当于先走到2^k-1的位置，然后再走2^k-1步走到对应的父节点 需要注意的是，我们在预处理f[i,k]的时候，要求第i个点的所有状态的话，我们需要将i的所有祖先结点都处理出来这样我们可以用BFS来一层一层的进行求解 时间复杂度预处理的时间复杂度 = 状态的数量*每个状态计算的时间每个状态计算时间复杂度为O(1)那么状态的数量，有n个数，每次查询的时间复杂度为logn预处理时间复杂度为nlognn最大为50000，log50000 &lt; 16那么时间复杂度差不多就是16n 注意点 用邻接表去存储树 f数组要初始化为-1，防止状态从不合法的状态转移过来 要f[i][j-1] != -1的时候，f[i][j] = f[f[i][j-1]][j-1]; 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class TreeAncestor &#123;public: vector&lt;vector&lt;int&gt;&gt; f,g; TreeAncestor(int n, vector&lt;int&gt;&amp; p) &#123; f = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(16,-1)); g = vector&lt;vector&lt;int&gt;&gt;(n); int root = 0; for(int i = 0;i &lt; n;i++) &#123; if(p[i] == -1) root = i; else &#123; g[p[i]].push_back(i); &#125; &#125; queue&lt;int&gt; q; q.push(root); while(q.size()) &#123; auto t = q.front(); q.pop(); for(auto i : g[t]) &#123; f[i][0] = t; for(int j = 1;j &lt; 16;j++) &#123; if(f[i][j-1] != -1) f[i][j] = f[f[i][j-1]][j-1]; &#125; q.push(i); &#125; &#125; &#125; int getKthAncestor(int node, int k) &#123; int x = node; for(int i = 0;i &lt; 16;i++) &#123; if(k &gt;&gt; i &amp; 1) &#123; x = f[x][i]; if(x == -1) return x; &#125; &#125; return x; &#125;&#125;;/** * Your TreeAncestor object will be instantiated and called as such: * TreeAncestor* obj = new TreeAncestor(n, parent); * int param_1 = obj-&gt;getKthAncestor(node,k); */]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1458-MaxDotProductOfTwoSubsequences-dp]]></title>
    <url>%2F2020%2F05%2F26%2FLeetCode1458-MaxDotProductOfTwoSubsequences-dp%2F</url>
    <content type="text"><![CDATA[1458. 两个子序列的最大点积 - 类似最长公共子序列 207加油哇，你可不能这么轻易的就认输了。51 题目 输入输出 分析这题跟最长公共子序列几乎完全一样最长公共子序列从不同的序列中选出相同的子序列的最大长度的方案这题就是从不同序列中对应元素选出点积之和最大的方案 闫氏dp分析法集合：f[i][j]表示只考虑从A[1到i] B[1到j]的所有选择子序列的方案的集合 属性：最大值 这里选Ai不选Bj，和f[i][j-1]这个不太相同 因为根据我们的定义f[i][j-1]表示的是从A中的1到i中选，从B中的1到j-1中选得到的点积的最大值的集合 那么显然从A中的1到i中选可以不包含Ai，这里就跟我们选Ai不选Bj不太一样但是从A中的1到i中选，从B中的1到j-1中选也一定是包含选Ai不选Bj的情况的，因为我们求的是最大值，所以也就无所谓了 这个f[i][j-1]虽然范围更大可能和别的集合有交集，但是并不妨碍我们求最大值 同理，f[i-1][j-1]这个区间被包含在了f[i][j-1]和f[i-1][j]之中，所以这种情况也可以舍去 注意点 因为这题求的是点积的最大值，因此初始化的时候我们不能默认f[i][j]全为0，而是应该把f[i][j]先初始化为负无穷然后把f[i][0]和f[0][j]的所有状态设置成为0，f[i][0]表示第2列一个都没选为0，f[0][j]表示第1列一个都没选为0(注意这里i和j要包含0，因为f[0][0]表示一个都不选的情况对应的值为0)如果极端情况，一列全是正数一列全是负数，那么可能一个都不选，所以我们需要处理这种情况因为如果选的话一定是f[i-1][j-1] + nums1[i-1]*nums2[j-1]这种情况所以我们可以提前预处理t = f[i-1][j-1] + nums1[i-1]*nums2[j-1];然后让res = max(res,t)最后res就是得到的最后的结果了，表示所有的第四种情况取一个最大值这样子，就算一列全是正数一列全是负数，我们也能得到负数的情况中最大的那种情况(即两列各选两个数使得负数负的最小)因为第四种情况一定是包含A[i]和B[j]的，所以最后的结果也是从最后一种情况而来 因为所有的方案都是从f[i-1][j-1] + nums1[i-1]*nums2[j-1]这个操作里面来的，表示选A[i-1]和B[i-1]因为每次都是选A[i-1]和B[i-1]，所以每次选出来的两列的长度都是同时+1，所以就保证了长度一定是相同的 代码如下12345678910111213141516171819202122232425class Solution &#123;public: int f[510][510]; int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n1 = nums1.size(),n2 = nums2.size(); memset(f,-0x3f,sizeof f); for(int i = 0;i &lt;= n1;i++) f[i][0] = 0; for(int i = 0;i &lt;= n2;i++) f[0][i] = 0; int res = INT_MIN; for(int i = 1;i &lt;= n1;i++) &#123; for(int j = 1;j &lt;= n2;j++) &#123; f[i][j] = max(f[i-1][j],f[i][j-1]); int t = f[i-1][j-1] + nums1[i-1]*nums2[j-1]; res = max(res,t); f[i][j] = max(f[i][j],t); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1371-NOR-PrefixSum]]></title>
    <url>%2F2020%2F05%2F21%2FLeetCode1371-NOR-PrefixSum%2F</url>
    <content type="text"><![CDATA[LeetCode1371. 每个元音包含偶数次的最长子字符串50,正好一百多天写了五十几篇博客，属实懒狗没错了(逃 题目 分析 引入 前缀和：将双变量转为单变量[i,j] 区间确定出一个子串，题目条件：[i, j] 内出现的元音均为偶数变量有 2 个，如果找齐所有区间需要两层循环我们可不可以转为单变量？所有事情在一次遍历中完成其实这类“子串”、“子数组”问题，可以利用【前缀和相减】转化为：[0, j] 的元音次数 -− [0, i - 1]对应的元音次数 == 偶数求 [0,x] 的元音次数，变量就只有 1 个了 求出每个元音次数的差值有必要吗？ 我们只关心差值是不是偶数，不关心偶数等于几奇数 - 奇数 = 偶数；偶数 - 偶数 = 偶数；一个偶数一个奇数之差一定是奇数因此条件等价于：[0, j] 出现的元音次数的奇偶，相同于，[0, i - 1] 对应的元音次数的奇偶特别注意出现 0 次（没有出现），也是出现了偶次~ 非奇即偶，奇偶是相对的状态两个相反、相对的状态，可以抽象为 0 和 1 —— 用 0 代表偶数，1 代表奇数[0,x]的 u o i e a 各自出现的奇偶次数，都用 0/1 表示，组成一个 5 位二进制数。譬如，00001，代表其中 u o i e 都出现偶次（包括0），a 出现奇次管这叫 [0,x]区间的 state ，它包含 [0,x] 中 5 个元音出现次数的奇偶信息题目再次等价转化条件等价转化为：[0, j]的 state 和 [0, i - 1]的 state 相同，即两个二进制数相等！题目转化为：在所有满足该条件的 i、j组合中，找出 j - i最大的两个 前缀区间 相距越远，代表形成的 子串越长 呀~~遍历字符串，不断求出 [0, x]的 state ，看看 哪些 state 是相同的，并找出位置 离得最远 的 怎么求前缀区间的 state假设 [0,2]的 state 是 00110 ，代表出现 e 和 i 奇数次，假如下一字符是 i，则 [0,3]区间出现的 i 次数变为偶数， state 为 00010遇到 ii ，从 00110 变到 00010 ，第三位从 1 翻转为 0，其他位不变使特定的位翻转 正是 异或 的作用，第三位翻转，就是异或了 00100异或 相当于 不带进位的二进制加法，所以有 00110 ^ 00100 = 00010元音字母 u o i e a ，分别对应了：10000、01000、00100 ……所以，当前前缀区间的 state 等于 前一个求出 state 异或 当前字符对应的二进制数。好比累乘、累加，只是这是 累异或预置 -1 的情况，使通式普遍适用[i,j] 的 u o i e a 出现偶次 &lt;=&gt; [0, j]的 state 相同于 [0, i - 1] 的 statei 显然可以为 0 ，则 i-1 为 -1 ，特别地，我们让 [0,-1] 的 state 是 00000 ，表示在字符串 -1 的位置，所有元音都出现 0 次（偶数）为了让边界情况也能套用通式，即 i= 0 时，[0,j]的元音都出现 偶次 &lt;=&gt; [0, j] 的 state 等于 00000，通式成立！ 前缀区间的 state 怎么存可以选择存到 数组 里，数组的索引和字符位置一一对应也可以用 哈希Map，存键值对key： state 值value：对应在字符串中的位置我们选择 Map ，将逐个求出的 [0, x]的 state 存入 Map为了书写方便，转成十进制，00110 就存 6 ，是等价的寻找满足条件的 state遍历过程中，边存 state ，要边在 Map 中查找：看看有没有 之前存过的，与当前 state 相同的 state如果有，则可能不止一个，要根据 value 值，求出它离当前位置的距离，找出有着最长距离的那个，就是我们想要的最大子串长度 主要思路准备工作准备一个哈希表unordered_map，key存放state，键值存放对应的下标如果当前的state不在哈希表里面，就存放到哈希表里面如果当前的state已经在哈希表里面了，那么此时的下标i减去对应相同状态的mp[state]中存放的下标，就是一个符合条件的字符串于是我们每次从0开始从头开始枚举到n，从符合条件的字符串中找到的最大的长度就是我们需要的结果 注意点初始的时候要把mp[0] = -1，意味着初始化的时候为-1，如果接下来的i是从下标为0开始的，如果i一直都不是元音字符的话那么从第一个字符下标0开始，res = 0 - (-1) = 1，如果第二个字符也不是元音字符的话，res = 1 - (-1) = 2然后依次类推… 代码如下12345678910111213141516171819202122232425class Solution &#123;public: int findTheLongestSubstring(string s) &#123; int res = 0; unordered_map&lt;int,int&gt; mp; mp[0] = -1; int state = 0; for(int i = 0;i &lt; s.size();i++) &#123; switch(s[i])&#123; case 'a': state ^= 1; break; case 'e': state ^= 2; break; case 'i': state ^= 4; break; case 'o': state ^= 8; break; case 'u': state ^= 16; break; default: break; &#125; if(!mp.count(state)) mp[state] = i; int distance = i - mp[state]; res = max(distance,res); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>NOR</category>
        <category>PrefixSum</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing1593-IntegerFactorization-dp-SpecificPlan]]></title>
    <url>%2F2020%2F05%2F10%2FAcWing1593-IntegerFactorization-dp-SpecificPlan%2F</url>
    <content type="text"><![CDATA[AcWing1593. 整数分解 - 二维费用的完全背包求具体方案49 题目 输入输出 分析这道题目大致的题意就是给你一个数n，看能不能划分成k个p进制数的和即划分成n = a1 ^ p + a2 ^ p + … + ak ^ p 这题用暴搜在AcWing上会超时但是经过昨晚y总的讲解我原来豁然开朗，原来这道题可以转化为一个二维费用的完全背包问题求具体方案问题这波啊,这波是我没想到的 于是我顺便来整理下大致的思路吧大致的思路就是把n这个数看成背包的容积N因为n最多不超过400，然而p进制最少为2所以物品的价值最大可以取到20(因为20^2 = 400) 时间复杂度20*400*400 = 3200000 &lt; 10^7所以可以用dp来进行求解 每个物品i的体积为i^p,重量为1，价值为i 所以这道题目就被转化成从前i个物品中取，体积恰好为j，重量恰好为k的取法的方案的最大价值所以根据闫氏dp分析法我们可以很容易的得到状态转移的方程f[i][j][k] = max(f[i-1][j][k],f[i][j - v[i]][k - w[i]] + value[i]); 注意点 因为我们要使划分的数恰好分成几个数的和，所以我们就不能像原来那样的背包问题一样设置成体积最多为j和重量最多为k的取法的方案定义为体积和重量分别恰好为j和k的时候，我们只用对f[i][j][k]中的值全部memset为负无穷即可只定义f[0][0][0] = 0即可这样也很好理解，因为根据定义出发体积恰好为j，重量恰好为k的时候当i = 0即一件物品都不取的时候，这个时候只有j = k = 0的时候是合法的状态即一件不取的时候价值为0，f[0][0][0] = 0你如果一件都没取，j和k肯定只能为0，j和k如果不为0，只可能是你取了物品但是你没取物品，说明这个状态是不合法的，所以我们就要全部设置为负无穷不让后面状态转移从这些不合法的状态转移过来 因为题目要求我们输出各因子之和最大的一种解法所以我们就可以把每件物品的价值定义成各个数本身即第i个物品的价值为i，这样，我们最后dp得到的最大值就是各因子之和最大的方案 求具体的方案因为题目也要求是选择因子序列最大的方案所以我们在最后求得最大的价值的时候，我们从最后一个状态转移回去，看能转移到那些状态对应的数，就可以保证我们最后得到的序列的字典序最大因为我们是从前往后枚举的，我们最后从后往前枚举能够转移的状态，本身就是从尽可能大的数来开始枚举的，所以最后这样的状态转移可以保证我们得到的序列是字典序最大的其次就是我们在求具体的方案的时候，应该用while循环来进行判断状态是否能转移，因为是完全背包，物品的数量是无限的，一个物品可能会被取到多次 什么时候是不存在方案的？当f[t][n][k]是小于0的时候，说明我们想要得到的状态是从负无穷即不合法的状态转移过来的，这个时候我们就可以确定是没有解决方案的，直接输出impossible即可 确定物品的个数我们可以预先从1开始处理出物品的体积、重量、价值第i个物品的体积为i^p,重量为1，价值为i且当i^p &gt; n的时候就可以结束循环了，这样子我们就可以确定最多有几个可能取到的物品了 因为PAT的蛋疼的输出，我们需要先定义一个is_first的布尔变量来对第一个进行特别的输出 如果对完全背包问题不太熟悉的话可以看看 3. 完全背包问题如果对背包问题求具体方案不太熟悉的话可以看看 12. 背包问题求具体方案如果对二维费用的背包问题不太熟悉的话可以看看 8. 二维费用的背包问题 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;/*背包容量为N，重量不超过k每个物品i从1到20中选，每个物品i对应的体积为i^p，重量为1，价值为i设f[i][j][k]为从前i个物品中选，体积恰好为j重量恰好为k的最大价值的方案f[21][410][410]*/const int N = 22,M = 410;int f[N][M][M];int n,k,p;int v[N],w[N],value[N];//v[i]和w[i]分别对应第i个物品的体积和重量int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;p; memset(f,-0x3f,sizeof f); f[0][0][0] = 0; int t = 0; //自己手动计算出物品对应的体积、重量、价值 for(int i = 1;i &lt;= 20;i++) &#123; if(pow(i,p) &gt; n) break; v[i] = pow(i,p); w[i] = 1; value[i] = i; t++; &#125; int i,j,m; for(i = 1;i &lt;= t;i++) for(j = 0;j &lt;= n;j++) for(m = 0;m &lt;= k;m++) &#123; f[i][j][m] = f[i-1][j][m]; //跟完全背包一样的推导公式，只不过多了一维 if(j - v[i] &gt;= 0 &amp;&amp; m - w[i] &gt;= 0)f[i][j][m] = max(f[i][j][m],f[i][j - v[i]][m - w[i]] + value[i]); &#125; int flag = 0; bool is_first = true; if(f[t][n][k] &lt; 0) puts("Impossible");//如果状态小于0，说明状态不合法，即没有能够成立的方案 else &#123; for(i = t,j = n,m = k;i &amp;&amp; j &amp;&amp; m;i--) &#123; //如果状态能够转移过来，那么就输出 while(f[i][j][m] == f[i][j - v[i]][m - w[i]] + value[i]) &#123; if(is_first) &#123; cout&lt;&lt;n&lt;&lt;" = "&lt;&lt;i&lt;&lt;"^"&lt;&lt;p; is_first = false; &#125; else &#123; cout&lt;&lt;" + "&lt;&lt;i&lt;&lt;"^"&lt;&lt;p; &#125; j -=v[i],m-=w[i]; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>PAT</category>
        <category>dp</category>
        <category>SpecificPlan</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT-1624-SubwayMap-dijkstra]]></title>
    <url>%2F2020%2F05%2F09%2FPAT-1624-SubwayMap-dijkstra%2F</url>
    <content type="text"><![CDATA[一个复杂模型的堆优化版本的dijkstra - PAT1624. 地铁地图48 题目 输入输出 示例 分析因为最多有100条路线，每条路线最多有100站所以总共最多就有10000个点如果我们只根据每条线路的相邻两个站来建图的话那么我们在从A、B两条路线的中间站走到A路线的一个站点的时候，我们就不知道它到底是从另一条路线B路线过来的还是就从A路线过来的所以，我们就可以让一条线路上的所有点都两两互相连一条边，这样我们在最短路判断的时候就能知道它到底是从本身的路线过来的还是从其他路线换乘过来的 如图所示，每条线路都两两建立一条边，然后一条边上100个点，互相就会有(100*99约等于)10000条边，然后又有100条线路所以最多会连接1000000(10^6)条边 每条边的距离就是这个站点与下一个站点相邻的最小距离然后题目要求找到换乘次数最少的线路，可以转换成从起点到达终点找到经过边的条数最少的问题因为很显然的道理，我们只有到达中间两条路线交错的地方A去换乘，这个时候就只会形成1条边，而你如果到A之前多次上车下车会形成多条边，这样没有意义 所以换乘次数最少，就被我们转化成为从起点到终点经过的边数最少的路线了 分析时间复杂度，我们把换乘次数最少转化为边数最少之后一共有10000(10^4)个点，1000000(10^6)条边，所以用朴素版的dijkstra会超时这个时候我们就要转化成堆优化版本的dijkstra，这题的时间复杂度限制在0.4s 时间复杂度会降低到mlogn 注意点 我们在一条路线站与站之间建立边的时候要注意如果线路不是环线的话,即stops[0] != stops[m-1]的话那么对于点j和点k的话，stops[j]与stops[k]的距离就是abs(j-k)如果线路是环路的话，即stops[0] == stops[m-1]的话那么我们从stops[j]到stop[k]的距离就要选环上最短的连接距离了即从j到k，abs(j-k)与j到m-1，再从0到k，即(m-1-j) + (k - 0) = m-1-j+k看j-k和m-1-j+k谁小我们就设置stops[j]和stops[k]之间的距离为谁然后我们就可以dijkstra从起点到终点找到最小的距离了，以及最少的边数(即最少的换乘次数) 如果到i的距离可以从到j的距离加上j到i的距离更新的话我们这个时候就记录dist[i] = dist[j] + w[i]pre[i] = jcnt[j] = cnt[i] + 1 如果到i经过的最小边数可以从到j经过的最小边数再加上j到i的边数(即换乘的次数)更新的话，那么这个时候也要更新即pre[i] = jcnt[j] = cnt[i] + 1 如果可以到i的距离可以从到j加上从j到i的距离更新的话，那么这个时候也要记录这个时候更新i是从j的那条线路上更新而来的，而且最后的结果一定是从一个站点换乘到另一个站点即line[i] = “Take Line#” + to_string(line[j])—-get_string(j)—-&gt;get_string(i); 最后记录end到start的路线，然后同时记录是从哪些站点过来的，然后这些站点会记录是从哪条线路的哪条站点过来，然后最后存到一个path数组再输出就好了 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 10010, M = 1000010;#define x first#define y secondtypedef pair&lt;int,int&gt; PII;int n,m;int h[N],e[M],w[M],line[M],ne[M],idx;//记录从h[idx]到e[idx],且距离为w[idx],所在线路为line[idx]上bool st[N];//判断该点是否已经走过int cnt[N];//记录要换乘的站点数int dist[N];//记录最短距离int pre[N];//记录每个结点的前面一个结点是谁string info[N];//记录每个点是从哪个结点搭过来的int stops[N];string get_string(int a)//如果a没有4位的话就加前置0补齐4位&#123; string res = to_string(a); while(res.size() &lt; 4) res = '0' + res; return res;&#125; void add(int a,int b,int c,int id)//建图，一条线路上的各个点之间都要建边，而且要确定这个站是在哪条路线上&#123; e[idx] = b; w[idx] = c; line[idx] = id; ne[idx] = h[a]; h[a] = idx++;&#125;void dijkstra(int start,int end)&#123; memset(dist,0x3f,sizeof dist);//找到从起点到终点最小的距离 memset(cnt,0x3f,sizeof cnt);//找到最少的边即最少的换乘次数 memset(st,0,sizeof st); priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; heap.push(&#123;0,start&#125;); dist[start] = cnt[start] = 0; while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.y; if(ver == end) break; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; ~i ; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; dist[ver] + w[i]) &#123; dist[j] = dist[ver] + w[i]; cnt[j] = cnt[ver] + 1; pre[j] = ver; info[j] = "Take Line#" + to_string(line[i]) + " from "+get_string(ver)+" to " +get_string(j)+"."; heap.push(&#123;dist[j],j&#125;); &#125; else if(dist[j] == dist[ver] + w[i]) &#123; if(cnt[j] &gt; cnt[ver] + 1) &#123; pre[j] = ver; cnt[j] = cnt[ver] + 1; info[j] = "Take Line#" + to_string(line[i]) + " from "+get_string(ver)+" to " +get_string(j)+"."; &#125; &#125; &#125; &#125; vector&lt;string&gt;path; for(int i = end;i != start;i = pre[i]) &#123; path.push_back(info[i]); &#125; cout&lt;&lt;dist[end]&lt;&lt;endl; for(int i = path.size()-1;i &gt;= 0;i--) &#123; cout&lt;&lt;path[i]&lt;&lt;endl; &#125;&#125;int main()&#123; memset(h,-1,sizeof h); cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; int m; cin&gt;&gt;m; for(int j = 0;j &lt; m;j++) cin&gt;&gt;stops[j]; for(int j = 0;j &lt; m;j++) for(int k = 0;k &lt; j;k++) &#123; int len; if(stops[0] != stops[m-1]) len = j - k; else len = min(j-k,m - 1 - j + k); add(stops[j],stops[k],len,i),add(stops[k],stops[j],len,i); &#125; &#125; cin&gt;&gt;m; while(m--) &#123; int start,end; cin&gt;&gt;start&gt;&gt;end; dijkstra(start,end); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>dijkstra</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode45-JumpGameII-DPandGreed]]></title>
    <url>%2F2020%2F05%2F04%2FLeetCode45-JumpGameII-DPandGreed%2F</url>
    <content type="text"><![CDATA[一道简单的dp加上贪心思想的题目 - LeetCode45.跳跃游戏II47 题目 分析动态规划这道题可以用动态规划的思路去求解 闫氏dp分析法 对应的dp代码就是123456789101112131415161718192021class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt;f(n+1); for(int i = 1;i &lt; n;i++) &#123; int t = INT_MAX; for(int j = 0;j &lt; i;j++) &#123; if(j + nums[j] &gt;= i) &#123; t = min(t,f[j]+1); &#125; &#125; f[i] = t; &#125; return f[n-1]; &#125;&#125;;但是很显然，这样dp最坏的情况下时间复杂度会达到O(n^2)会超时 这个时候我们就需要思考应该怎么样改进我们的代码了 贪心 + 动态规划通过枚举单纯的动态规划我们可以知道，f[N]数组里面是单调递增的大概就是0,1,1,2,2,2,….所以f[i]是一个单调递增的数组又从动态规划的状态转移方程可知f[i] = f[j] + 1我们要枚举i之前的能跳到i的所有j，然后每次找到一个符合条件的j之后就f[i] = f[j]+1因为初始的时候f[j]都为0，所以不管找到多少个j，都只会使得f[i]在0的基础上加1 找到第一个能跳到i的j的时候更新了一次f[i]，之后无论再找到多少个j都只能使得f[i] = 0+1 = 1也就是说除了第一个点之外，后面找到的点都是进行的重复的操作 所以我们只用找到第一个能跳到i的点j，然后用j去更新i的状态即f[i] = f[j] + 1 动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了 因为找到第一个点和遍历所有的点都只遍历了一次，所以时间复杂度会降到O(n) 对应的代码1234567891011121314class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt;f(n+1); for(int i = 1,last = 0;i &lt; n;i++) &#123; while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++;//找到能跳到i的第一个点 f[i] = f[last] + 1;直接更新f[i] &#125; return f[n-1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dp</category>
        <category>greed</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题-五月份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing292-ArtilleryPosition-StateCompressionDP]]></title>
    <url>%2F2020%2F05%2F04%2FAcWing292-ArtilleryPosition-StateCompressionDP%2F</url>
    <content type="text"><![CDATA[稍微复杂一点的状态压缩dp - AcWing292.炮兵阵地 46 题目 输入输出 分析这题其实是上道题玉米田的进阶 区别在于这题的限制范围从1行扩大到了2行，所以我们dp的状态应该多加一维即f[i][j][k]表示所有摆完前i行且第i-1行状态为j，第i行状态为k摆放方案的最大值 假设第i-1行状态为a，第i行状态为b，第i-2行状态为c 那么我们假设想确定第i行是什么状态，那么我们就要用第i-1行和第i-2行的状态加上第i行能摆放的所有方案确定第i行的状态 即f[i][a][b] = max(f[i][a][b],f[i-1][c][a] + cnt[b]);这里的cnt[b]表示第i行对应的状态里面有多少个1(即对应二进制中1的个数) 从而可以求出摆放完第i行方案的最大值是多少 需要注意的几个问题 因为这题摆放完一个炮兵之后那么它上下左右长度为2形状为一个十字的地方都不能摆放炮兵 所以我们需要预处理状态，把不冲突的状态枚举出来所以我们需要预先处理摆放在同一行不冲突的状态先枚举出来存到state里面 这里冲突的判断条件就是二进制状态state判断条件(state &gt;&gt; i) &amp; 1 &amp;&amp; ((state &gt;&gt; i+1 &amp; 1) || (state &gt;&gt; i+2 &amp; 1))如果为1的话说明冲突了不能作为合法的状态否则为合法的状态存到state里面 这题里面有山地的存在，山地是不能摆放炮兵的我们可以把山地定义为1，平原定义为0 然后把第i行的初始状态的二进制表示转化为十进制表示存到数组g[i]中如果我要枚举的那一行的状态为a的话 如果g[i] &amp; a &gt; 0表示我想要到第i行摆放的炮兵会摆放到山地上，所以导致了冲突 我们会分别枚举第i-2行、第i-1行、第i行的状态(这些状态都是从之前挑选的合法状态state中枚举) 这三行的炮兵也不能互相攻击到，意味着三行的状态，两两都不能在同一列上(因为我们之前枚举的合法状态避免了行与行之间的冲突所以不用再次考虑) 假设第i-1行状态为a，第i行状态为b，第i-2行状态为c 那么对应的判断条件(a &amp; b) || (a &amp; c) || (b &amp; c)也不能为真 这题需要我们用滚动数组去求解 为什么要用滚动数组?分析时间复杂度，因为f[i][j][k]表示所有摆完前i行且第i-1行状态为j，第i行状态为k摆放方案的最大值那么i最大为100，j和k最大为1 &lt;&lt; 10即1024，1024*1024*100 / 1024 / 1024 = 100MB但是题目只给了64MB，所以我们需要缩小第1维的大小去做 所以我们只用对第1维&amp;1即可，即f[n &amp; 1][a][b]对应的状态转移方程中改成f[i &amp; 1][a][b] = max(f[i &amp; 1][a][b],f[i-1 &amp; 1][c][a] + cnt[b]);因为这样i &amp; 1一定和(i - 1)&amp; 1不会相同，所以f的三维可以定义为f[2][M][M]第一维对应的第1行一定是从第0行转移过来，第0行一定是从第1行转移过来 最后枚举倒数两行的状态res += f[n &amp; 1][i][j]，i和j都是合法状态state里面的状态，如果存在值说明能转移过来得到对应的值，如果不能转移过来值为0不影响结果 当然你也可以选择y总那样的写法，枚举到n+2行，最后f[n+2 &amp; 1][0][0]就是对应的最终值 枚举第i-2行、第i-1行、第i行的顺序可以互换，只要状态定义的顺序和状态计算的顺序对应即可 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 110,M = 1 &lt;&lt; 10;int n,m;int f[2][M][M];//f[i][j][k]表示所有已摆完第i行，且第i-1行状态为j，第i行状态为k的最大值int cnt[M];//记录每个状态中炮兵的数目(也就是1的数目)int g[N];//记录每一行的山地情况vector&lt;int&gt;state;//记录每个合法的状态bool check(int state)//判断合法的状态，相邻两格之间不能有两个1&#123; for(int i = 0;i &lt; m;i++) &#123; if((state &gt;&gt; i) &amp; 1 &amp;&amp; ( (state &gt;&gt; i+1 &amp; 1) || (state &gt;&gt; i+2 &amp; 1))) return false; &#125; return true;&#125;int count(int state)//计算每个状态中的1的个数即炮兵的个数&#123; int res = 0; for(int i = 0;i &lt; m;i++) res += state &gt;&gt; i &amp; 1; return res;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt; m;j++) &#123; char c; cin&gt;&gt;c; if(c == 'H') g[i] += 1 &lt;&lt; (m - j - 1);//把山地和平原看成01二进制然后转化为十进制存放到数组中欧冠 &#125; //cout&lt;&lt;g[i]&lt;&lt;endl; &#125; //筛出合法的状态 for(int i = 0;i &lt; 1 &lt;&lt; m;i++) &#123; if(check(i)) &#123; state.push_back(i); cnt[i] = count(i);//计算对应每个合法状态中1的个数即炮兵的个数 &#125; &#125; //for(int i = 1;i &lt;= n+2;i++) for(int i = 1;i &lt;= n;i++) &#123; for(int u = 0;u &lt; state.size();u++)//第i-1行的状态 &#123; for(int j = 0;j &lt; state.size();j++)//第i行的状态 &#123; for(int k = 0;k &lt; state.size();k++)//第i-2行的状态 &#123; int a = state[u],b = state[j],c = state[k]; if((a &amp; b) || (a &amp; c) || (b &amp; c)) continue;//第i行、第i-1行、第i-2行不能相互攻到 if((g[i-1] &amp; a) || (g[i] &amp; b) || (g[i-2] &amp; c)) continue;//第i-1行和第i行不能占到山地上，从而确定了第i行和第i-1行的状态，然后就可以枚举第i-2行的状态 f[i &amp; 1][a][b] = max(f[i &amp; 1][a][b],f[i-1 &amp; 1][c][a] + cnt[b]); &#125; &#125; &#125; &#125; //cout&lt;&lt;f[n+2 &amp; 1][0][0]; int res = 0; for(auto t1 : state) &#123; for(auto t2 : state) &#123; res = max(res,f[n &amp; 1][t1][t2]); &#125; &#125; cout&lt;&lt;res; return 0;&#125;]]></content>
      <categories>
        <category>StateCompression</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewAndInsightOfCOVID-19]]></title>
    <url>%2F2020%2F05%2F04%2FViewAndInsightOfCOVID-19%2F</url>
    <content type="text"><![CDATA[记录一下疫情爆发四个多月的感悟和一点思考老师要写的一篇论文，顺便把它贴到博客上好了里面有些是客套话看个乐子就完事了x 2020年当真是一个魔幻的年代，每个人可能都未曾想到会是以这种方式来开局，离当初疫情爆发差不多快过去了四个多月，现在回过头来看我们当初疫情爆发的时候，肯定想不到今天会有今天这样子，趁着这个机会我也想写一写我对这个疫情的所见所闻所感，以及对我们当下国家乃至整个世界会产生什么样的深远影响。 还记得一月份期末考试结束，我在一月十二号搭高铁回家，其实当时大家就已经有警觉感了，因为当时不管是火车站还是地铁上，其实人们都已经有所意识，到处都在消毒到处都在通风，但是当时还没多少人戴口罩，人们当时也许觉得只是一个比较严重的流感而已，因为那个时候还没有明确的说明这个病毒是具有明显的人传人的迹象，所以当时虽然人们有所警觉，但是并没有多少人会想到这样的局面。 我在回家以后，局势慢慢的就变得不那么明确了起来，每天的新闻的报道越来越严重，我又处于疫情最严重的湖北这个地方，所以说实话，当初其实是对这个病毒心里有点抵触的，但其实更担心的是家里的老年人，我完全不敢设想如果他们感染了病毒，我们家这个小小的家庭会产生什么样的变故，好在的是，当时家里人都对这个病毒有很大的防备心，从各种渠道去买了很多口罩屯在家里以备不时之需，全家人除了去超市买生活必需品基本上都不出门，值得庆幸的是，家里的亲戚都安然无恙，甚至几个在当医生的亲戚朋友也都很健康，我觉得这才是在一场灾难面前不幸中的万幸吧。 对于这场疫情，我觉得应该保持一种客观、求实的态度去评价政府的工作，对于政府，既有做的好的地方，自然也有做的不好的地方。 先说说我认为做的不好的地方吧，我觉得最大的感触就是疫情之处信息不透明，从去年12月31日就知道感染的患者就已经从华南海鲜市场传染到其他地方了，这样一个明显的人传人的现象当初没有及时的传递给公众，虽然说当时有可能传递恐慌的情绪，但是我觉得政府的透明应该做的更好才行，而不是一味的隐瞒，我觉得李文亮医生的事迹我们不能忘记，正是有类似李文亮医生的吹哨人才能传递给公众事实的真相，所以我们需要更加完善这样一种重大疫情的反馈机制才行，而不是被少数人一拖再拖。其次我觉得应该增加国家CDC（卫健委）的地位才行，不应该让CDC的决策者去一层一层的上报上级才行，而是需要单独把CDC独立出来，他们应该有自己的声音去面对不同程度的疫情有着及时、迅速的上报和反馈机制才行再说说我觉得我们政府做的好的地方吧，那就是社会主义国家动员全国之力去办大事的能力，因为我听家里的老人说过，即便是非典的时候当时在我的家乡湖北，都没有面临过这么严峻的局面，好在政府调集全国各地的医疗队来志愿武汉志愿湖北，我觉得从内心里面是真的很温暖，因为真心体会到什么叫做“一方有难，八方支援”，我觉得这样的动员机制，是保障我们在遇到突发重大应急事件的一个有力的举措。其次就是我觉得中国的医疗体系需要继续的保持下去，不能被一些人忽悠把医疗全部私有化，公有化的医疗体系也是不可少的，否则如果全部都是私有化的医院，再遇到重大突发事故，哪个医生愿意站出来为你支援呢？所以我觉得也得警惕一些人想把中国的医疗体系全部私有化的论调，我觉得医生的待遇水平当然应该提高，但是混合所有制的医疗体系也是必不可少的，不能全盘照搬西方的经验，西方好比北欧他们的医疗福利体系是有着高税收来保证体系的运转的，不同的国家有着不同的国情，我们中国需要发展出符合自己特色的医疗体系去适应中国人民日益增长的医疗需求，但同时也需要满足医生们的权益，保证他们首先，安全要受到保证，坚决抵制那些伤医的行为，要把这种行为坚决写进法律里面，给医生以最大的保障；其次就是应该提高医生的待遇水平，只有医生的待遇水平提高了，才能减少那些医生和药房合谋的行为，从而也减少了医生乱开药的行为。所以如何平衡这两者，我觉得需要我们的政府和广大人民去集思广益去商量出一个比较好的一个解决方案。 我觉得我们也不能盲目的去迷信西方，迷信西方的那套理论，因为当初二月份的时候，当我们的疫情还在刚开始发酵的时候，西方都在看我们的戏，我们当中也有不少声音，应该照搬西方的那套救助的体系，才能保证我们能够控制住疫情，可是最后的结果却让人大跌眼镜，西方的人均医疗资源类似每个人平均的病床数都比中国要高不少，可是呢？结果西方因为政治家们的作秀，导致他们失去了控制疫情的宝贵时间，导致他们疫情的大爆发，就拿美国来说，他们总的新冠疫情的确诊人数已经超过了一百万，对比中国的八万多的数据，如果把美国的数据放到我们中国，那简直是不可想象的一件事，而且重点是美国地广人稀，但是他们还是抗疫失败了，所以值得我们思考的是，要避免像西方那样，将抗疫政治化，变成政治家们的一场作秀，本来应该是一场可怕的病毒导致的疫情，却被像特朗普这样的政治家形容成“只是一个大号的流感”，并且还引用美国每年死亡于流感的人数拿新冠疫情的死亡人数来做对比。恕我直言，这样的人是对生命对自然没有一点敬畏之心的人，我真的对西方国家死亡于新冠疫情的人们感到悲哀，如果不是他们政府的无能和无视，哪会有这么多人会白白的死于新冠疫情之中？可笑的是，这些应该为这场灾难负责的政治家们现在还活蹦乱跳的活跃在生活中，并且就算到现在为止还时不时的去质疑这场灾难，还想着疫情还没完全消除的情况下就完全复工复产，可以这么说，在这些政治家的眼中早已失去了人性，失去了对生命的敬畏之心，他们在意的只是自己的选票罢了，所谓的感染人数，所谓的死亡人数，在他们的眼里可能只是简简单单的一个数字罢了，但是对于那些因新冠疫情死亡的人们，每一个数字都意味着一个家庭的破碎，所以我希望我们中国人要有自己，不仅是对自己的制度方面要有自信，而是对各个方面都要有自信 我其实也是在反思，为什么我们对西方媒体的一些宣传如此感兴趣？个人认为，说到底还是一个话语权的问题，中国现在是在国际上去找到一种认同感，但是这个话语权不在自己的手上，所以对于西方来说，无论你中国做的有多好有多差，他们在话语之间就能把一个白的东西描述成黑的，比如如果中国抗疫的好，那一定是政府偷报瞒报数据了；如果中国抗疫的不好，就是理所当然的事情，是因为社会主义没有资本主义优越，反正一个问题你从不同的角度去分析完全可以得出一个不同的结论。所以在美国为首代表的西方势力的眼里，中国就像古代还尚未开化的蛮夷一样，你做什么都是错的，哪怕连呼吸都是错的，都应该是被口诛笔伐的对象，中国应该学会像日本那样脱亚入欧才能受到我们西方的尊重，所以我觉得用一句话来总结就是用毛的话来说就是“放弃幻想，准备斗争”，就比如从中美贸易战开始，我们当时其实有很多投降派害怕美国对中国的围追堵截，诶，觉得只要美国能放过中国，那么一切代价都是可以付出的，我觉得其实这也是一种民族不自信的体现，你觉得如果真的对美国的要求一再的妥协满足，美国难道就真的会满足吗？不见得吧，反倒会一直变本加厉，苏洵早在《六国论》里面就有曾说过，“今日割五城，明日割十城，然后得一夕安寝。起视四境，而秦兵又至矣。”这句话放到如今何尝不适合？当初苏联解体之后，俄罗斯作为继承苏联的主体对美国抛出的一个个橄榄枝信以为真，把国有资产廉价的卖给西方，把航空母舰、各种武器当做废铁一样卖给别人，一味的按照西方的休克疗法一步步去瞎搞，最后差点俄罗斯元气大伤，从一个发达国家退回成发展中国家，难道这样的事实还不值得我们所警惕并吸取教训吗？ 诚然，在这个后真相时代，英文名叫做“post-trush”，我们作为个人也需要对我们眼前的所见所闻所感要有自己一个清晰的认知，不能轻易的被媒体的一些事实所带节奏，其实很多媒体所报道的事情，根本就没有辨别出事情的真相，只是为了满足当下人们的口味，为了符合人们的感性诉求然后对事实调油加醋之后再加工形成的作品，人们对事实的真相本身是什么并不感兴趣，人们对事情产生的情绪已经超过了事实的本身，我们需要警惕这种现象的发生，同时我们也要意识到所谓的媒体们所报道的事实不一定就一定是事实的真相，我们需要自己保留自己的一份独立的思考才行，不能盲目根据片面的报道就跟着起哄，同时也希望一些媒体能够以客观公正的态度去报道新闻才行。回到我们的新冠疫情带来的危机，危机危机，那么自然有危也有机，新冠疫情给我们带来的负面影响固然很大，但是我们同时需要看待，这何尝不是一场危机呢，促使我们国家加快对数字化、5G、信息互通等方面的建设。 说几个将来疫情结束之后会带来改变的产业吧。 第一就是在线教育和协同办公，这个几乎每个学生或者工作了的人都深有体会吧，学生在家里需要用手机电脑等一起上课，工作的人需要用软件的方式远程办公协同才行，我觉得这次新冠疫情是对这几个产业的一个发展的大机遇，因为它已经深刻的改变了我们平时的生活方式，所以他们需要思考，如果疫情结束之后恢复平静之后，这个产业要怎么做才能更加有竞争力，能够让人们在疫情结束之后能够习惯这样的学习或者工作方式。 第二就是新零售，疫情的原因，导致我们都不能出门到实体店去购物，去实地的考察，这个时候新零售的发展机遇就很大了，如何使得人们坐在家里就能够像线下的方式去购买到自己想要买的东西，未来新零售的发展趋势一定是线上与线下相结合的方式才能够满足未来广大消费者日益增长的需求，才能够在未来日趋激烈的竞争中生存下来 第三就是医疗建设方面的发展了，经过这次疫情，估计每个人对于医疗健康方面的意识都大大提高，我觉得这也是这些企业的一个机遇了，因为原来没有这场疫情之前人们可能都还抱着一个无所谓的态度，但是经历过后这种深刻的印象，会导致人们对于未来的医疗健康的保障方面会有着更高的要求。最后就是人们对于智慧城市方面有着更高的要求了，因为武汉这个千万人口级别的城市封城导致我们的生活带来了巨大的影响，但假设武汉对于每个市民的情况都能被掌握，每个人都能够被精确的追踪，每个流动人口都能被记录，那么即便下一次再遇到类似的灾难我们也会应对的从容有序，智慧城市包括：交通管理、物流供应链、应急灾备、信息溯源等等，都会全面数据化，甚至具备了人工智能的灾备预测等等。相信疫情过后，中国对于城市的管理水平，会更上一层台阶。 最后的最后，我想说，2020年的开局虽然很艰难，但是中国人民从来就是不怕艰难和困苦的，从哪里跌倒，就要从哪里爬起来，中国人民的学习精神一直是世界上各个民族最诚恳的，所以我对我们中国未来的发展，抱有着充分乐观的态度去看待它，但是我同时也得指出，未来可能疫情会常态化发展，很可能新冠疫情会一直伴随着我们，伴随着全世界都难以被彻底消灭，所以我们需要时刻保持一个警惕的态度去应对不同的局面，不能再有疫情一开始的麻痹大意了，但同时，我相信，只有经历过磨难之后，希望的花才能绽放的更加璀璨吧！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>新冠疫情下的一点思考与见解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing12-NumberOfOptionsForTheBackpackProblem-dp]]></title>
    <url>%2F2020%2F05%2F02%2FAcWing12-NumberOfOptionsForTheBackpackProblem-dp%2F</url>
    <content type="text"><![CDATA[AcWing12. 背包问题求方案数 - dp45 题目 输入输出 分析这题问的就是在01背包的条件下，问最优选法的方案数 所谓的最优选法，就是找到使背包价值最大的方案的总数 我们可以用两个数组来进行计算f[i][j]和g[i][j] 其中f[i][j]表示从前i个物品中选，体积恰好为j的方案的最大价值注意这里定义的是体积恰好为j，所以初始化的时候要把除了f[0][0]之外的全部初始化为负无穷 g[i][j]表示从前i个物品中选，体积恰好为j的方案的最大价值时的方案数 那么g[i][j]就是对应着f[i][j]的方案数 那么我们看f[i][j]的状态转移方程 f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i]); 如果f[i-1][j] &gt; f[i-1][j-v[i]]+w[i]意味着最大价值的方案要从f[i-1][j]转移过来那么g[i][j] = g[i-1][j] 如果f[i-1][j] &lt; f[i-1][j-v[i]]+w[i]意味着最大价值的方案要从f[i-1][j-v[i]]+w[i]转移过来那么g[i][j] = g[i-1][j - v[i]] 如果f[i-1][j] == f[i-1][j-v[i]]+w[i]说明最大价值的方案从这两条路线都能转移过来那么意味着两条路径都要相加，并且记得取模即g[i][j] = (g[i-1][j] + g[i-1][j - v[i]]) % mod; 然后从f[n][i]中找到价值最大为res然后再循环f[n][i]，如果当f[n][i] == res的时候对应cnt = (cnt + g[n][i]) % mod;这里表达的意思就是把找到最大价值时的选法总数全部加起来 这样最终得到的cnt即为最优方案的总数 没有优化前的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e3+10,mod = 1e9+7;int n,m;//f[i][j]表示从前i个物品中选，体积恰好为j的最大价值//g[i][j]表示从前i个物品中选，体积为j时取到最大价值的方案数int f[N][N],g[N][N];int v[N],w[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; memset(f,-0x3f,sizeof f); f[0][0] = 0; g[0][0] = 1; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt;= m;j++) &#123; f[i][j] = f[i-1][j]; if(j - v[i] &gt;= 0) &#123; f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]); if(f[i-1][j] &gt; f[i-1][j-v[i]]+w[i]) g[i][j] = g[i-1][j]; else if(f[i-1][j] &lt; f[i-1][j-v[i]]+w[i]) g[i][j] = g[i-1][j - v[i]]; else g[i][j] = (g[i-1][j] + g[i-1][j - v[i]]) % mod; &#125; else &#123; g[i][j] = g[i-1][j]; &#125; &#125; &#125; int res = 0; for(int i = 0;i &lt;= m;i++) res = max(res,f[n][i]); int cnt = 0; for(int i = 0;i &lt;= m;i++) &#123; if(f[n][i] == res) &#123; cnt = (cnt + g[n][i]) % mod; &#125; &#125; cout&lt;&lt;cnt; return 0;&#125; 把数组的二维等价化简为一维123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e3+10,mod = 1e9+7;int n,m;int f[N],g[N];int v[N],w[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; memset(f,-0x3f,sizeof f); f[0] = 0; g[0] = 1; for(int i = 1;i &lt;= n;i++) &#123; for(int j = m;j &gt;= v[i];j--) &#123; /* int maxv = max(f[j],f[j-v[i]]+w[i]); int cnt1 = 0; if(maxv == f[j]) cnt1 = (cnt1 + g[j]) % mod; if(maxv == f[j-v[i]]+w[i]) cnt1 = (cnt1 + g[j-v[i]]) % mod; g[j] = cnt1; f[j] = maxv; */ if(f[j] &lt; f[j-v[i]]+w[i]) g[j] = g[j - v[i]]; else if(f[j] == f[j-v[i]]+w[i]) g[j] = (g[j] + g[j - v[i]]) % mod; f[j] = max(f[j],f[j-v[i]]+w[i]); &#125; &#125; int res = 0; for(int i = 0;i &lt;= m;i++) res = max(res,f[i]); int cnt = 0; for(int i = 0;i &lt;= m;i++) &#123; if(f[i] == res) &#123; cnt = (cnt + g[i]) % mod; &#125; &#125; cout&lt;&lt;cnt; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>backpackdp</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode3-LongestSubstringWithoutRepeatingCharacters-TwoPoints]]></title>
    <url>%2F2020%2F05%2F02%2FLeetCode3-LongestSubstringWithoutRepeatingCharacters-TwoPoints%2F</url>
    <content type="text"><![CDATA[LeetCode3.最长不含重复字符的子字符串 - 双指针 44 题目及输入输出 分析这题是一个经典的双指针算法的问题 暴力做法就是两重循环，就是从每个字母从前往后去找不重复的字符串 然后每次取一个max 那么我们怎么去优化呢？ 我们可以用一个双指针i和j从下标0开始 如果没有重复的字符串就把j往后移动，j++ 否则遇到了重复的字符串就把i往后移，i++ 然后每次移动的过程中都取一次max 举例 对于字符串”abcabcbb”那么j一直加到3的时候，其实表明这个时候前面有3个不同的字符串然后每次都要取一个最大值res = max(res,j-i); 对于字符串”abdvvvdcfgvdd”j加到前面的那几个v对应的第二个v的下标的时候因为这个时候对应的v始终都为true所以i会不断向右移动直至与j相等为止 所以如果中间有很多重复的元素，那么双指针算法总是可以跳过重复元素，然后从重复元素的最右端的那个元素再从前往后进行枚举 代码如下1234567891011121314151617181920212223class Solution &#123;public: unordered_map&lt;char,bool&gt; judge; int lengthOfLongestSubstring(string s) &#123; int res = 0; for(int i = 0,j = 0;i &lt; s.size() &amp;&amp; j &lt; s.size();) &#123; if(!judge[s[j]]) &#123; judge[s[j]] = true; j++; &#125; else &#123; judge[s[i]] = false; i++; &#125; res = max(res,j-i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>TwoPoints</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing327-CornField-StateCompression]]></title>
    <url>%2F2020%2F05%2F01%2FAcWing327-CornField-StateCompression%2F</url>
    <content type="text"><![CDATA[状压dp的简单例子 - AcWing327.玉米田43 题目 输入输出 分析考虑状态的表示通常需要保存一定的状态数据(一种状态需要对应一种数据值)同时每个状态数据可以分解成许多数据单元 通常情况下每个状态数据可以通过一个整数来表示同时将这个整数分解成二进制形式。 比如在一行棋盘的格子上放棋子，在格子上放棋子表示1不放棋子表示0。 这样用0或者1来表示状态数据的每个单元，而整个状态数据就是一个一串0和1组成的二进制数。通常这样的状态数据实现为一个基本的数据类型或者一种哈希值，同时需要注意的是状态数据中的每个单元不能太多。 具体题目的思路状态转移方程f[i][j]表示所有摆完前i行，且第i行状态为j的方案数那么对于每一个合法的状态f[i][b]，上一行的状态为f[i-1][a];那么f[i][b] += f[i-1][a]枚举每一个上一行能转移到下一行的状态如果我们能枚举出每个能从i-1行状态转移到第i行的状态，然后把所有能转移的状态全部加起来并取模就得到了所有能转移到第i行的合法状态 状态压缩dp一般都要求预先把合法的状态i能够转移到其他所有合法状态都预先处理出来注意，这里有两个要求，第一是状态合法，第二是状态i能够转移到状态j，那么我们就把能转移的合法状态记录下来即head[state[i]].push_back(state[i]); 因为题目给的条件是1表示土地肥沃可以种，0表示不能种，这里我根据习惯把所有的1变成0，把所有的0变成1，即1代表不能种，0代表可以种，即a[i][j] ^= 1，这样做的好处是不能种的地方为1方便判断，比如上一层对应的状态与这一层对应状态的同一列都为1的话说明状态i就不能转移到状态j，这个时候我们只用判断state[i] &amp; state[j] 如果大于0的话说明不合法即 1234bool check(int a,int b)//检查a和b的两个状态是否有重合的部位,这里的a和b对应着二进制状态的十进制表示&#123; return !(a &amp; b);&#125; 然后把每一行的01序列转化为十进制存放到num数组里面 枚举从0到(1 &lt;&lt; m) - 1的合法状态并且存放到state中，这里的合法状态是指状态的二进制表示不能有连续的1 枚举每一个合法的状态state，如果state[i]和state[j]没有重合的1的话说明状态可以由state[j]转移到state[i]并且存放到head[M]中，即head[state[i]].push_back(state[j]) 初始化f[0][0] = 1,表示一行都没摆的情况下，方案数为1然后枚举每一行i从1到n令c = num[i]表示第i行初始的状态然后再枚举合法的状态，如果第i行初始的状态与合法的状态state[j]没有重复的1的时候表示第i行可以种成state[j]的形式然后再枚举能转移到state[j]的每个状态，表示上一层能够转移到下一层的所有可能的合法状态，最后加上取模 1234567if(check(c,state[j])) &#123; for(int k : head[state[j]]) &#123; f[i][state[j]] = (f[i][state[j]] + f[i-1][k]) % mod; &#125; &#125; 再次强调一下，因为我这里把题目中的0和1全部都颠倒了一遍，即0变成1,1变成0，这样做的好处就是如果判断冲突的时候同一列位置如果都是1就不能种下去，方便我们判断 最后的结果就是第n行枚举每个状态i从1到 (1 &lt;&lt; m) -1res = (res + f[n][i]) % mod如果能转移到的状态就存在对应的值，不能转移到的状态对应的值就为0 当然你也可以跟y总那样枚举到n+1行，然后f[n+1][0]就是对应的最终值 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 15,M = 1 &lt;&lt; 12,mod = 100000000;int f[N][M];//f[i][j]表示所有摆完前i行，且第i行状态为j的方案数int a[N][N];//记录初始的地图int num[M];//记录每一行初始的二进制状态的十进制表示int n,m;vector&lt;int&gt;state;//记录合法的状态vector&lt;int&gt;head[M];//head[state[i]]表示能转移到state[i]的所有合法状态int calculate(vector&lt;int&gt; t)//把每一层的二进制状态转换成十进制&#123; int res = 0; reverse(t.begin(),t.end());//把二进制翻转一下方便我们计算 for(int i = 0;i &lt; t.size();i++) &#123; res += pow(2,i)*t[i]; &#125; return res;&#125;bool judge(int t)//如果哪个状态有连续的1说明不能作为合法的状态&#123; for(int i = 0;i &lt; m;i++) &#123; if((t &gt;&gt; i &amp; 1) &amp;&amp; (t &gt;&gt; (i+1) &amp; 1)) return false; &#125; return true;&#125;bool check(int a,int b)//检查a和b的两个状态是否有重合的部位&#123; return !(a &amp; b);&#125;/*//等价写法bool check(int a,int b)//检查a和b的两个状态是否有重合的部位&#123; for(int i = 0;i &lt; m;i++) &#123; if((a &gt;&gt; i &amp; 1) &amp;&amp; (b &gt;&gt; i &amp; 1)) return false; &#125; return true; &#125;*/int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) &#123; vector&lt;int&gt;tmp; for(int j = 1;j &lt;= m;j++) &#123; cin&gt;&gt;a[i][j]; a[i][j] ^= 1;//把所有的1变成0，所有的0变成1方便我们后续的判断 tmp.push_back(a[i][j]); &#125; num[i] = calculate(tmp);//把每一层的二进制状态转化为十进制 &#125; for(int i = 0;i &lt; 1 &lt;&lt; m;i++)//保证每个状态都没有连续的1 &#123; if(judge(i))//如果每个对应的二进制中没有连续的1，说明可以作为合法的状态并记录 &#123; state.push_back(i); &#125; &#125; for(int i = 0;i &lt; state.size();i++)//state[i]和state[j]没有重合的1的话说明状态可以由state[j]转移到state[i]，并存放到head[M]里面 &#123; for(int j = 0;j &lt; state.size();j++) &#123; if(check(state[i],state[j])) &#123; head[state[i]].push_back(state[j]); &#125; &#125; &#125; f[0][0] = 1;//表示一行都没摆的情况下，方案数为1 for(int i = 1;i &lt;= n;i++) &#123; int c = num[i];//第i行初始的状态 for(int j = 0;j &lt; state.size();j++) &#123; if(check(c,state[j]))//如果第i行初始的状态与合法的状态state[j]没有重复的1的时候，表示第i行可以种成state[j]的形式 &#123; for(int k : head[state[j]]) &#123; f[i][state[j]] = (f[i][state[j]] + f[i-1][k]) % mod;//枚举能转移到state[j]的每个状态，并加上取模 &#125; &#125; &#125; &#125; int res = 0; for(int i = 0;i &lt; 1 &lt;&lt; m;i++) res = (res + f[n][i]) % mod; cout&lt;&lt;res; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>StateCompression</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeInterviewQuestion51-XOR]]></title>
    <url>%2F2020%2F04%2F28%2FLeetCodeInterviewQuestion51-XOR%2F</url>
    <content type="text"><![CDATA[LeetCode面试题51. 数组中数字出现的次数 - 异或 42 题目及输入输出 分析由题意可知，题目要求时间复杂度为O(n),空间复杂度为O(1) 那么也就意味着 只能通过循环去解决问题 不能去额外开哈希表、数组或者其他容器 我们的解决方法就是用异或的方法 如果题目中只有一个数出现1次，其他数都出现2两次那么我们只用初始化res = 0;for(int t : nums) res ^= t;最后相同的数都会被抵消，异或的结果为0，得到的结果肯定为只有出现1次的那个数 但是题目中有两个数出现的次数为1次对于数组中不同的只出现过1次的数a和b 我们可以先从头到尾把数组所有的数都异或一遍这样得到的结果即为a ^ b 对于a ^ b，因为a和b一定不相同，所以a和b的二进制中至少有1位是不同的那么我们就可以根据这个特点来进行分组 对于a ^ b，向右移k位时为1，就表示a和b的二进制表示在第k位一个为0一个为1那么我们重新遍历数组，对于每个数的二进制表示初始化a = 0,b = 0第k位为0就与a异或，第k位不为0就与b异或 最后得到的a和b就是数组中只出现过1次的两个数 代码如下12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; int t = 0; for(int tmp : nums) &#123; t ^= tmp; &#125; int i; for(i = 0;i &lt; 20;i++) &#123; if(t &gt;&gt; i &amp; 1 == 1) &#123; break; &#125; &#125; int a = 0,b = 0; for(int tmp : nums) &#123; if(tmp &gt;&gt; i &amp; 1 == 1) &#123; a ^= tmp; &#125; else &#123; b ^= tmp; &#125; &#125; return &#123;a,b&#125;; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>XOR</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing1064-StateCompression]]></title>
    <url>%2F2020%2F04%2F27%2FAcWing1064-StateCompression%2F</url>
    <content type="text"><![CDATA[一种类型的状态压缩dp - AcWing1064.骑士42 题目及输入输出 分析 由题目的分析可知，每一行状态只跟上一行的状态有关于是 我们可以从第i行开始枚举有效的状态 再枚举第i行能转移到第i+1行的状态 最后把第n行所有有效状态的数量加起来即可 闫氏dp分析法 注意点 需要预先处理出来有效的状态有效的状态需要满足：状态里面不能有连续的1我们可以提前枚举出来有效的状态然后记录到一个vector中 我们需要预先存储一个有效的状态能够转移到那些状态中去如果状态a能够转移到状态b，那么需要满足(1)a &amp; b == 0，即a和b的二进制表示的相同的位数不能同时有1(2)check(a | b)是否为true，即a和b的并集同样不能存在连续的1，如果存在连续的1说明国王的周围部分包括下一层的国王，这样的状态也是不成立的 最后的结果会爆int，需要用long long来存储最后的结果 需要预先写出一个check函数来判断状态是否有连续的1，用一个count函数来计算状态里面有多少个1 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 12,M = 1 &lt;&lt; 10,W = 110;LL f[N][W][M];//f[i][j][k]表示前i行，放置了j个国王，且第i行状态为k的方案数vector&lt;int&gt; head[M];//存放第i个状态能转移到的合法状态vector&lt;int&gt; state;//存放合法状态int n,m;int cnt[M];bool check(int state)&#123; for (int i = 0; i &lt; n; i ++ ) if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1)) return false; return true;&#125;int count(int state)&#123; int res = 0; for (int i = 0; i &lt; n; i ++ ) res += state &gt;&gt; i &amp; 1; return res;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) if (check(i)) &#123; state.push_back(i); cnt[i] = count(i); &#125; for(int i = 0;i &lt; state.size();i++) &#123; for(int j = 0;j &lt; state.size();j++) &#123; int x = state[i],y = state[j]; if( (x &amp; y) == 0 &amp;&amp; check(x | y)) &#123; head[i].push_back(j); &#125; &#125; &#125; f[0][0][0] = 1; for(int i = 1;i &lt;= n+1;i++) &#123; for(int j = 0;j &lt;= m;j++) &#123; for(int k = 0;k &lt; state.size();k++) &#123; int c = cnt[state[k]]; int a = state[k]; for(int b : head[k]) &#123; if(c &lt;= j) &#123; f[i][j][a] += f[i-1][j-c][state[b]]; &#125; &#125; &#125; &#125; &#125; LL res = 0; for(int i = 0;i &lt; 1 &lt;&lt; n;i++) res +=f[n][m][i]; cout&lt;&lt;res; return 0; &#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>StateCompression</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShareDealing]]></title>
    <url>%2F2020%2F04%2F27%2FShareDealing%2F</url>
    <content type="text"><![CDATA[一个稍微复杂一点的状态机模(三种状态) - 1058. 股票买卖 V41 题目 输入输出 分析由题目分析可知卖股票之后，会有一个一天的冷却期 所以需要分成三种状态 手中有股票 卖出股票后的第一天(因为有冷却期不能买股票，所以要单独分出来) 卖出股票后的第二天 代码如下1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5+10;int f[N][3];//0对应有货，1对于无货的第一天，2对应无货的第二天及以后的天数int w[N];int n;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) cin&gt;&gt;w[i]; f[0][0] = f[0][1] = -0x3f3f3f3f; f[0][2] = 0; for(int i = 1;i &lt;= n;i++) &#123; f[i][0] = max(f[i-1][0],f[i-1][2] - w[i]); //手中有货 f[i][1] = f[i-1][0] + w[i]; //手中无货的第一天 f[i][2] = max(f[i-1][2],f[i-1][1]); //手中无货的第二天 &#125; cout&lt;&lt;max(f[n][1],f[n][2]); return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>AcWing</category>
        <category>FSP</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmallestHamiltonDistance]]></title>
    <url>%2F2020%2F04%2F25%2FSmallestHamiltonDistance%2F</url>
    <content type="text"><![CDATA[最短Hamilton路径(一种类型的状态压缩dp)40 题目 输入输出 思考题目要求的是从0到n-1的最短距离的方案我们可以发现，我们所需要的不是整个方案是什么，而只是方案最优解是多少 所以我们只需要记录当前这个方案的最优解即可那么我们考虑的状态，发现这个点访问与否可以用0和1来表示 比如如果有从0到4，5个点，那么10100就表示访问了2和4,0,1,3没有访问 所以我们可以用状态压缩的方式去做这道题 显而易见，对于每个确定的点j说明从原点能走到j 又i &gt;&gt; k &amp; 1成立的话 说明能从原点走到k 那么从原点走到j的最小值即求从原点走到不同的k再走到j所有距离的最小值 注意点 i - (1 &lt;&lt; j)可以用i ^ (1 &lt;&lt; j)来代替，因为i表示已经走过了哪个点，如果想消去j这个点，其实就是要把i里面从右往左数第j位这个位置的1改成0，因为i其实是把二进制数转化为十进制表示，那么减去j这个点其实就表示为i - $2^{j}$而2^j就相当于把1左移j位，那么i - $2^{j}$ == i - (1 &lt;&lt; j)然而因为i和(1 &lt;&lt; j)其实都是二进制，i ^ (1 &lt;&lt; j)，因为这两者从右往左数的第j为都是1，异或的时候第j位就为0了位运算会更加快一点 代码如下12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int n;int a[N][N];int f[M][N];//f[i][j]表示从0到j，走过的路程用二进制i来表示的路径的最小值int main()&#123; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) scanf("%d",&amp;a[i][j]); memset(f,0x3f,sizeof f);//初始的情况把所有点都赋成正无穷，保证所有的点一定是从0转移过来的 f[1][0] = 0; //f[1][0]表示从0走到0，走过的点二进制表示为(00000...001)即为1，这个时候路径的长度为0 //即对应f[1][0] = 0 for(int i = 1;i &lt; 1 &lt;&lt; n;i++)//枚举所有可能的状态 &#123; for(int j = 0;j &lt; n;j++)//对于每个点j &#123; if(i &gt;&gt; j &amp; 1)//如果能从原点走到j，或者说走过的路径中包含j这个点 &#123; for(int k = 0;k &lt; n;k++)//枚举每一个点k &#123; if(i &gt;&gt; k &amp; 1)//如果又能从原点走到k，或者说走过的路径中也包含k这个点 f[i][j] = min(f[i][j],f[i - (1 &lt;&lt; j)][k] + a[k][j]);//原点到j的距离最小值等于原点到k的距离，然后再加上k到j的距离取一个min &#125; &#125; &#125; &#125; cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>Hamilton</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2020%2F04%2F23%2FKMP%2F</url>
    <content type="text"><![CDATA[KMP算法模板及理解39 简介KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。 KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在“hello,world”主串中查找“world”模式串的位置)。 暴力的做法对于主串S[N]和模板串P[N],要找模板P在主串S中的每个起始位置12345678910111213主串长度为n,模板串长度为mfor(int i = 1;i &lt;= n;i++)&#123; bool flag = true; for(int j = 1;j &lt;= m;j++) &#123; if(S[i] != p[j]) &#123; flag = false; break; &#125; &#125;&#125; 如何优化暴力的做法？暴力的做法是从主串的起始位置i开始，每次从头开始枚举模板串，如果有不相同的字符就直接break掉，再从i+1的位置开始进行匹配 显然，这种做法会进行大量重复性的工作比如主串 ababaeaba模板串 ababacd我枚举到第5个字符的时候发现此时主串中的e和模板串的c并不匹配但是两个串中都有相同的前缀aba，这个时候可以滑动 如图所示，主串的i-1和模板串的j位置对应的字符串是相等的 到了i和j+1这里对应的字符就不相等 如果是暴力做法那么肯定就是把模板串整体往后挪一位然后再开始重新判断 但是显然我们在之前匹配的过程中已经做了大量的重复工作 所以我们思考怎么样才可以多挪动几位 因为这很容易可以想到如果是12主串 abcabcxhhhh模板串 abcabcyjklm我们匹配到主串的x和模板串的y这里就不匹配了但是这里再把模板串往后挪动一位也肯定不匹配啊即12主串 abcabcxhhhh模板串 abcabcyjklm因为除非是一模一样的字符串，不然两个相同的字符串其中一个往后挪动一位还完全一致是不可能的 所以模板串挪到什么地方才对呢？ 1234即挪到主串 abcabcxhhhh模板串 abcabcyjklm这里才能相同 因为从模板串可以看出来，一开始枚举到第6位的c的时候主串和模板串前面都还一致，直到枚举到第七位的时候就不相同了这个时候就需要滑动模板串 这个时候就需要next数组了next数组的含义就是：用来存模板串中每个前缀最长的能匹配前缀子串的结尾字符的下标 从模板串可知截止到第6位c之前的abcabc，后面的abc和前缀abc是相同的，此时第6位c对应的next数组的值next[6] = 3,表示模板串中以第i个字符结尾的字符串应该跳到模板串的next[i]的位置往后继续匹配，如果对应的后面一个字符不匹配的话，则需要继续滑动，对应到模板串上就相当于要匹配的位置不断的往前跳动 因为主串的abcabc….和模板串的abcabc…..已经匹配了那么我如果不想再把模板串往后挪一位从头开始匹配的话 那么我就需要找到一个方法挪动之后使得模板串的前缀部分与原来主串对应匹配的后缀部分相匹配才行 但是又因为主串对应匹配的后缀部分和一开始模板串对应匹配的后缀部分是相同的 那么第1步就可以转化为找模板串的前缀部分和后缀部分匹配的最大部分才行，而且匹配的字符串长度越大的话，从形象上来理解模板串滑动距离也越小。 个人理解 求next数组其实就是把模板串也当成一个主串，错位来跟模板串来进行最大匹配，当匹配成功的时候主串中对应的下标i和模板串中对应的下标j+1其实是对应滑动最短的距离之后可以再从j+1的位置开始进行匹配，如果后面一个字母对应不匹配就继续滑动 我们其实是找到最大前缀截止的地方方便我进行下一次匹配，然后我惊奇的发现我假设存在这种情况，和最大后缀又是相等的，所以直接转换成求最大后缀来求出next数组了。 那么对于不同的主串和模板串来说，匹配到不同的字母的时候，但是他们两个前缀都是相等的，这个时候前面相同的部分其实就可以看作是同一个模板串，然后因为我们已经处理了next数组，表示如果是模板串和模板串匹配的时候应该滑动几位，又因为这个时候主串和模板串前面的部分相同，我们就可以看成是模板串与模板串匹配然后直接套用next数组来表示模板串应该滑动多少，或者说是应该跳回到哪个位置再往后继续匹配。 注意点 模板串和主串下标都要从1开始储存，且主串和模板串需要错位去枚举，即主串是从i = 1开始枚举，模板串是从j = 0开始枚举，每次枚举S[i]与P[j+1]是否相同 当模板串和主串匹配成功的时候，我们仍需要使j = ne[j]，继续滑动模板串，看模板串从哪个地方开始进行继续进行匹配，因为继续滑动模板串的话如果能进行匹配的话，表示此时滑动之后模板串的前缀又和之前主串匹配成功的后缀是相同的，这个时候我们就又省去了很多不必要的步骤 题目 输入输出 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int N = 1e5+10,M = 1e6+10;char p[N],s[M];//p是模板串，s是原串，找到p在s中的所有起始位置int next[N];int n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1; //求next数组 //next数组从2开始匹配就行了，因为next[1] = 0表示第一个字母匹配失败了，我就只能从0开始匹配 for(int i = 2,j = 0;i &lt;= n;i++) &#123; //这里其实是把模板串也当成一个主串来进行匹配 //当匹配的模板串对应的j没有退回起点，且主串中的i和模板串中的j+1不匹配的话，就继续滑动模板串 while(j &amp;&amp; p[i] != p[j+1]) j = ne[j]; //当i和j+1匹配的时候，表明 if(p[i] == p[j+1]) &#123; j++; next[i] = j; &#125; &#125; //KMP匹配过程 for(int i = 1,j = 0;i &lt;= m ;i++) &#123; //当匹配的模板串对应的j没有退回起点，且主串中的i和模板串中的j+1不匹配的话，就滑动模板串 //j如果退回起点就表明需要重新开始匹配 while(j &amp;&amp; s[i] != p[j+1]) j = next[j]; //当模板串和主串匹配的时候就不断往后挪动 if(s[i] == p[j+1]) j++; //当模板串匹配到最后一个字符的时候，表明这个时候匹配成功，那么这个时候就输出模板串的起始位置在主串中对应的下标 if(j == n) &#123; printf("%d ",i-n); j = next[j];// &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM-dp]]></title>
    <url>%2F2020%2F04%2F21%2FFSM-dp%2F</url>
    <content type="text"><![CDATA[一个简单的状态机模型38. 状态机模型的基本要素 AcWing1049. 大盗阿福题目 输入输出 分析用一个数组f[i]来表示抢前i家店铺的最大收益对于每一个店铺来说都有抢与不抢两种状态所以就可以用1表示选择最后一个店铺，0表示不选最后一个店铺所以分析可知对于未选最后一个店铺，那么它紧接着的后面一个店铺可以不抢，也可以抢所以状态可以从0走到0，也可以从0走到1 对于选了最后一个店铺，它就不能选择抢紧接着的后面一个店铺所以状态只能从1走到0 闫氏dp分析法 对于状态f[i,0]最后一个可以从(i-1,0) -&gt; (i,0) (表示不抢前一个店铺)也可以从(i-1,1) -&gt; (i,0) (表示抢前一个店铺) 对于状态f[i,1]只能从从(i-1,0) -&gt; (i,1) (前一个店铺不能抢，只能从0转移过来) 注意点 初始化要注意f[0][0] = 0,f[0][1] = -INF，状态机要给一个入口才能进入到状态机模型的0和1中具体问题分析理解的话就是第0个店铺如果不抢的话价值肯定为0，如果抢的话不存在这种情况，设置为负无穷 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int f[N][2],w[N];int n,T;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;w[i]); f[0][0] = 0,f[0][1] = -0x3f3f3f3f; for(int i = 1;i &lt;= n;i++) &#123; f[i][0] = max(f[i-1][0],f[i-1][1]); f[i][1] = f[i-1][0] + w[i]; &#125; printf("%d\n",max(f[n][1],f[n][0])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>FiniteStateMachine</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kruskal]]></title>
    <url>%2F2020%2F04%2F21%2Fkruskal%2F</url>
    <content type="text"><![CDATA[kruskal算法37。 题目 输入输出 思路kruskal算法 将所有边按权重从小到大排序//快排O(mlogm)可以定义结构体,里面存放变量a,b,w分别代表对应的点和边的权重 枚举每条边，a—-b 权重是w 如果当前a和b不连通(find(a) != find(b)) 将这条边加入集合中 且加上这条边对应的权值 （可以用并查集来操作） 如果ab不连通，将这条边加入集合中去其实就是在a与b之间加一条边，对应add操作即p[find(a)] = find(b);判断是否连通，就是判断a和b是否在一个连通块之中 关键代码12345678int a = Edges[i].a,b = Edges[i].b,w = Edges[i].w; a = find(a),b = find(b); if(a != b) &#123; p[a] = b; cnt++;//存当前加了多少条边 res += w;//存放最小生成树边的所有权重之和 &#125; 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int n,m;int p[N];struct Edge&#123; int a,b,w; bool operator &lt; (const Edge &amp;W) const &#123; return w &lt; W.w; &#125; &#125;Edge[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x]; &#125;int kruskal()&#123; int res = 0,cnt = 0; for(int i = 1;i &lt;= n;i++) p[i] = i;//用并查集一定记得先初始化！！！ for(int i = 0;i &lt; m;i++) &#123; int a = Edges[i].a,b = Edges[i].b,w = Edges[i].w; a = find(a),b = find(b); if(a != b) &#123; p[a] = b; cnt++;//存当前加了多少条边 res += w;//存放最小生成树边的所有权重之和 &#125; &#125; if(cnt &lt; n-1) return -1;//如果连的边数少于n-1的话说明不是连通的 return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; m;i++) &#123; int a,b,w; scanf("%d%d%d",&amp;a,&amp;b,&amp;w); Edges[i] = &#123;a,b,w&#125;; &#125; sort(Edges,Edges+m,cmp); int t = kruskal(); if(t == -1) puts("impossible"); else printf("%d",t); return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>kruskal</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prim]]></title>
    <url>%2F2020%2F04%2F19%2FPrim%2F</url>
    <content type="text"><![CDATA[Prim算法 第三十六次笔记。坚持一个星期没记笔记了，之前写过的又都忘了。 题目 输入输出 大致的思路123456781. 初始化所有点到集合的距离为正无穷,d[i] = +∞2. for(int i = 1;i &lt;= n;i++)&#123; 找到集合为距离最近的点t;(找到点t使得d[t]最小)(当集合还没有点的时候随便找一个点) (每次迭代找一个不在最小生成树的点，然后用这个点更新其他所有点到集合的距离，然后把这个点加到集合中去) 用t更新其他点到集合的距离(d[i] = min(d[t],g[t][i]))(集合的距离就是从集合外的一点到集合内部点最短的那条边，称为集合的距离) st[t] = true;&#125; 模拟样例因为一开始每个点到集合的距离都是正无穷第一步随便拿一个点到集合中，比如把1拿到集合中此时st[1] = true 然后拿1更新其他点到集合的距离所以d[2] = 1;d[3] = 2;d[4] = 3; 从剩下的点(2,3,4)中选着距离最近的点，也就是2st[2] = true;然后用2去更新其他点到集合的距离d[3] = min(d[3],g[2][3]) = min(2,3) = 2d[4] = min(d[3],g[2][3]) = min(2,INF) = 2从剩下的点(3,4)中选着距离最近的点，也就是3st[3] = true;然后用3去更新其他点到集合的距离d[4] = min(d[3],g[3][4]) = min(2,4) = 2最后把点4加进集合中去st[4] = true; 最后的生成树为图中绿色的边 注意点 集合中还没有点，即所有点的d[t]都是INFt == -1的时候就把第一个点加入到集合中去当找到第一个点更新了第一个d[1]之后，因为下面已经用第一个点更新了其他点所以此时集合里面都不为INF了而是有确定的值此时再到除了第一个点以外的其他点看找到其他到集合距离最短的一个点123456789101112for(int i = 1;i &lt;= n;i++) int t = -1; for(int j = 1;j &lt;= n;j++) &#123; if(!vis[j] &amp;&amp;((t == -1)||(d[j] &lt; d[t])))//当点不在集合中的时候 &#123; //1.集合中还没有点，即所有点的d[t]都是INF //t == -1的时候就把第一个点加入到集合中去 t = j; //2.当找到第一个点更新了第一个d[1]之后，因为下面已经用第一个点更新了其他点 &#125; // 所以此时集合里面都不为INF了而是有确定的值 // 此时再到除了第一个点以外的其他点看 // 找到其他到集合距离最短的一个点 &#125; 需要初始化所有点到集合的距离为正无穷，且每条边赋值之前也要把每条边的距离设置为正无穷且只要不是第一个点，就把对应点到集合的距离加起来即if(i != 1) res += d[t]; 如果不是第一个点且到集合的距离还为正无穷的话，说明这个图不是连通图 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int N = 510,INF = 0x3f3f3f3f;int n,m,res = 0;bool vis[N];int g[N][N],d[N];//g[i][j]表示i和j的距离,d[i]表示i到集合的距离int prim()&#123; for(int i = 1;i &lt;= n;i++) &#123; int t = -1; for(int j = 1;j &lt;= n;j++) &#123; if(!vis[j] &amp;&amp;((t == -1)||(d[j] &lt; d[t])))//当点不在集合中的时候 &#123; //1.集合中还没有点，即所有点的d[t]都是INF //t == -1的时候就把第一个点加入到集合中去 t = j; //2.当找到第一个点更新了第一个d[1]之后，因为下面已经用第一个点更新了其他点 &#125; // 所以此时集合里面都不为INF了而是有确定的值 // 此时再到除了第一个点以外的其他点看 // 找到其他到集合距离最短的一个点 &#125; vis[t] = true;//放入集合中就改为true if(i != 1 &amp;&amp; d[t] == INF) return INF;//如果不是第一个点到集合的距离还是INF的话说明这个图不是连通图，直接返回INF //if(i != 1) res += d[t]; 如果没有消除自环影响的那一步，那么就要先加入树的权重 //因为下一步用这个点更新其他点的时候当i = t时，d[t] = min(g[t][t],d[t])，自环就会导致d[t]变得更小 for(int i = 1;i &lt;= n;i++) d[i] = min(g[t][i],d[i]); //只要不是第一个点，就把对应点到集合的距离加起来 if(i != 1) res += d[t]; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(g,0x3f,sizeof g); memset(d,0x3f,sizeof d); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a != b)//消除自环的影响 g[a][b] = g[b][a] = min(g[a][b],c);//消除重边的影响 &#125; int t = prim(); if(t == INF) printf("impossible"); else printf("%d",t); return 0;]]></content>
      <categories>
        <category>AcWing</category>
        <category>Prim</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1010-radix]]></title>
    <url>%2F2020%2F04%2F08%2FPAT-1010-radix%2F</url>
    <content type="text"><![CDATA[PAT - 1010 Radix 第三十五天离放假过去了整整九十天。 题目 输入输出 题意题意就是给你四个数N1,N2,tag,radix当tag = 1时,radix为N1的进制;当tag = 2时,radix为N2的进制; 问你有没有当另外一个数的进制为多少的时候，N1 == N2成立 分析思路这题的思路大致为 把已知进制的那个数转化为10进制target 再二分枚举另外一个数的进制，枚举的进制转化为10进制，判断找到的数是否等于target如果相等，返回进制数，如果不相等，说明不存在，返回impossible 注意点 有一个很容易犯的思维定势，就是他已给的数的进制最大就是36，但是我们要求的另外一个数的进制可能远大于36因为N1,N2最大是十位，那么最大的数应该为zzzzzzzzzz,转换为10进制差不多就是1e16，所以我们在计算calc函数的时候，要判断1(double)res * r + get(x) &gt; 1e16， 这个时候res一定要转化成double类型，因为可能res = 1e15,然后再计算一遍res * r + get(x)会超出long long的范围，从而又从long long前面的范围开始而double可以存储最多为10^308级别的数，一定够用，所以我们这个时候要用double来转换判断是否超过范围，如果超出范围，直接返回一个很大的数即可 二分枚举的时候应该是calc(n2,mid) &lt;= target，这样我们求出的l就是小于等于target的最后一个数，那么二分过后如果calc(n2,l)如果不能与target说明就不存在，如果等于就说明存在 calc函数的第二个参数的r也应该设置成long long类型，方便后面二分的时候也计算对应进制转化为十进制的值 把k进制转化为10进制可以用秦九韶算法，即 12345for(auto x : n) &#123; if((double)res * r + get(x) &gt; 1e16) return 1e18; res = res*r + get(x); &#125; 这样可以降低时间复杂度 一个小技巧，就是如果tag == 2的时候我们直接swap(n1,n2)即可，这样我们可以保证始终n1对应的是确定进制的数，我们就不用再用if去判断对应的情况了 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;string n1,n2;LL tag,target;int radix;LL get(char s)&#123; if(s &gt;= '0' &amp;&amp; s &lt;= '9') return s-'0'; return s - 'a' + 10; &#125;LL calc(string n,LL r)&#123; LL res = 0; for(auto x : n) &#123; if((double)res * r + get(x) &gt; 1e16) return 1e18; res = res*r + get(x); &#125; return res;&#125;int main()&#123; cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;tag&gt;&gt;radix; if(tag == 2) swap(n1,n2); target = calc(n1,radix); LL l = 0,r = target + 1; for(auto t : n2) l = max(l,get(t)+1); while(l &lt; r) &#123; LL mid = l + r &gt;&gt; 1; if(calc(n2,mid) &gt;= target) r = mid; else l = mid + 1; &#125; if(calc(n2,l) == target) &#123; cout&lt;&lt;l; &#125; else puts("Impossible"); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>每天AC的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces479-div3-E-dfs]]></title>
    <url>%2F2020%2F04%2F04%2Fcodeforces479-div3-E-dfs%2F</url>
    <content type="text"><![CDATA[Codeforces Round #479 (Div. 3) - E. Cyclic Components 第三十四天，每天还是要坚持积累才行。 题目 输入输出 题意题目的大意就是给你几个连通块，问你里面有几个环 思路 从一个点开始遍历他能遍历到的所有的点然后存到vector里面 再检查vector里面每个点的出度是否为2，如果不为2返回false然后break，全为2就返回true，res++; 注意点 因为如果是一个环的话，那么每个点的出度都是2，如果在遍历的过程中只要发现有一个点的出度不为2，直接break掉循环下一个点 dfs的过程中需要用一个st[N]数组来判断是否访问过 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 2e5+10;vector&lt;int&gt; query[N],tmp;bool st[N],backup[N];int n,m,res = 0;void dfs(int x)&#123; st[x] = true; tmp.push_back(x); for(int i = 0;i &lt; query[x].size();i++) &#123; if(!st[query[x][i]]) &#123; dfs(query[x][i]); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); query[a].push_back(b),query[b].push_back(a); &#125; for(int i = 1;i &lt;= n;i++) &#123; if(!st[i]) &#123; tmp.clear(); dfs(i); int flag = 1; for(int i = 0;i &lt; tmp.size();i++) &#123; if(query[tmp[i]].size() != 2) &#123; flag = 0; break; &#125; &#125; if(flag) res++; &#125; &#125; cout&lt;&lt;res; return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
        <category>div3</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>每天AC的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing1296-NumberTheory-Dfs]]></title>
    <url>%2F2020%2F03%2F27%2FAcWing1296-NumberTheory-Dfs%2F</url>
    <content type="text"><![CDATA[一个与约数相关的数论问题 - AcWing1296.聪明的燕姿 第三十三天 题目 输入输出 题意题目的大意就是给一个数S 让你找到有多少数能够满足它约数的和等于S 比如S = 42 这个时候就有3个数满足条件 41 = (1 + 41) == 4220 = (1 + 2 + 4 + 5 + 10 + 20) == 4226 = (1 + 2 + 13 + 26) == 42 分析思路算术基本定理N = P1^a1 * P2^a2 * … * Pn^an则N的约数个数为(a1+1)(a2+1)…(an+1) 假设N的一个约数为D D = P1^b1 * P2^b2 * … * Pn^bn其中bi可以取到0，范围是0&lt;= bi &lt;= ai 因为只有和N的质因数一一对应一定能得到约数因为bi可以从0取到ai,那么每一个bi就有(ai+1)种选法 约数的个数就是每个bi对应多少种选法相乘即约数个数就为(a1+1)(a2+1)…(an+1) 约数之和S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 这个怎么理解呢 因为每一个约数为D = P1^b1 * P2^b2 * … * Pn^bn 那么S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 这个公式的意思就是从每个括号里面取出来一个数然后相乘，就能得到一个约数Di然后所有的约数Di相加就得到约数之和S 举个例子对于S = 42来说，42对应的结果里面有一个为20，20 = (1 + 2 + 4 + 5 + 10 + 20)20 = 2^2*5对于两个质因数2和5来说2可以取0,1,2次，5可以取0,1次所以S = (1+2+2^2)(1+5) = 42 继续分析所以我们最暴力的想法一定就是枚举了，比如对一个数S枚举从1到S-1的所有数的约数，再判断他们的约数和是否等于S 但是这么做显然会超时，因为1 &lt;= S &lt;= 2*10^9 这个时候我们就可以观察我们的约数和的公式S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an) 假设这个时候有一个约数和S满足(1+2)(1+2+2^2)(1+2+2^2+…+2^k)3x5x9x17x33x65x129 = 635037975 就已经接近1e9的量级了，可见符合条件的项不会很多 那么这个时候我们就可以用dfs进行搜索，看我们能不能得到符合条件的(1+pk+pk^2+…+pk^ak)能够使得S能够整除，即S % (1+pk+pk^2+…+pk^ak) == 0然后S /= (1+pk+pk^2+…+pk^ak),再dfs到下一层 应该先从小到大枚举P1234for(p : 2,3,5,7,...) for(a : 1,2,3,...) if(S mod (1+p1+p1^2+...+p1^a1) == 0) dfs(下一层) 这个时候我们还需要继续思考特殊情况 如果ai = 1的话，S = (1+Pi)的时候，因为Pi为质数，那么S-1也一定为质数，那么这个时候只需要判断S-1是否为质数即可 又S只会有两种情况，就是一种情况包括一个因子里面有(1+Pi)，另一种情况不包括(1+Pi)S = (1+Pi)(1+Pj+Pj^2…..)S = (1+Pi+Pi^2)(1+…..) 但是这两种情况都可以看出来Pi ^2 &lt;= S所以我们dfs枚举Pi的上限就是$\sqrt{ S }$ 所以dfs应该设置成三个参数dfs(last,product,S) 1.last参数表示上一个枚举的质数是谁，我们这样枚举的目的就是先把前面符合条件的质数枚举完了再枚举后面的质数，这样不会带来重复，降低了时间复杂度 比如质数为P = 2,3,5,7…. 如果枚举2之后再dfs到下一层，那么这个时候就应该再从3开始进行枚举而不是再从头开始枚举 2.product参数product表示 S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)中 当前进行到哪一个括号里面的最高次项Pi^ai的乘积和比如S = (1+2+2^2)(1+3+3^2+3^3)(1+….)则dfs到第三层的时候product = 2^2*3^3 (product : 1 — &gt; 2^2 — &gt; 2^2*3^3) 又由算术基本定理可知一个数N = P1^a1 * P2^a2 * … * Pn^an product = P1^a1 * P2^a2*….. 如果product要从第一层(一开始product初始化为1)进到第二层，此时product(2) = product(1) * P1^a1S = S’ / (1+p1+p1^2+…+p1^a1) 然后再dfs(last,product(2),S) ==(等价于) dfs(last , product(1)*P1^a1 , S’/(1+p1+p1^2+…+p1^a1)) 3.S参数从上面的分析可知S参数就代表着从一开始的S除以(1+pk+pk^2+…+pk^ak)后剩余的乘积 所以每一层我们都应当判断S-1是否为质数，如果S-1是质数的话,也需要记录，但是不需要返回上一层继续往下搜即可就比如2424 = (1+23) = (1+2)(1+7) = (1+3)(1+5)第一层的时候判断23是质数，所以记录res[len++] = 1*23同时也需要继续往下做然后依次判断2、7 或者3、5能不能满足条件只要有S-1为质数，说明就有满足条件的数，这个时候就需要记录结果 为什么S-1一定要大于上一层的质数？因为我们要保证质数是从小到大枚举的，只有剩下的S-1是大于上一层的质数的时候，(1+S)才有可能成为最初的那个S的一个因子 因为我们要表示S’ = (1+ 2 + 2^2+…)(1 + 3 + 3^2 + …)…(1+S)越往后枚举对应的那个Pi也越大，所以S-1一定要大于上一层的质数才能满足条件 S == 1对应的是什么情况？S == 1对应的就是S’只由一个括号即只有一个P,S’ = (1+p+p^2+…+p^k)组成的情况比如 7 = (1 + 2 + 2^2) ——-&gt;对应413 = (1 + 3 + 3^2) ——-&gt;对应915 = (1 + 2 + 2^2 + 2^3) ——-&gt;对应8这种情况表明，我从p = primes[i]开始枚举，一个p得到的序列和就把一开始的S’给整除了或者说这个序列和与S’相等，即此时的p得到的序列和(1+p+p^2+…+p^k) == S’ 所以此时S’ / (1+p+p^2+…) == 1dfs到下一层直接就是dfs(last,p^k,1)那么dfs到下一层S == 1的时候,product = p^k就是对应我们要找的那个数 注意点1.求质数的过程应该用线性筛的方法去做2.dfs(last,product,S)其中last应该初始化为-1这样我们在一开始判断S-1大于前面的质数的时候应该特判,S-1 &gt; ((last &lt; 0) ? 0 : primes[last])因为最小是(1+2)那么S起码是2,所以应该有S &gt; 1 即S-1 &gt; 0 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50000;//N = sqrt(2e9)bool st[N];int primes[N],cnt = 0;//线性筛int S,res[N],len;void get_primes(int n)&#123; for(int i = 2;i &lt;= n;i++) &#123; if(!st[i]) primes[cnt++] = i; for(int j = 0;primes[j]*i &lt;= n;j++) &#123; st[primes[j]*i] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125;int is_prime(int n)&#123; if(n &lt; N) return !st[n];//没有被筛过说明就是质数，返回true for(int i = 0;primes[i] &lt;= n / primes[i];i++) &#123; if(n % primes[i] == 0) return false; &#125; return true;&#125;void dfs(int last,int product,int S)//last表示上一个用的质数的下标是什么,product当前最高次项的结果,S表示每次处理后剩余多少&#123; if(S == 1) &#123; res[len++] = product; return ; &#125; //比如20 = 2^2 * 5 //N = P1^a1 * P2^a2 * ... * Pn^an //S = (1+p1+p1^2+...+p1^a1)(1+p2+p2^2+...+p2^a2)...(1+pn+pn^2+...+pn^an) //42 = (1 + 2 + 2^2)*(1 + 5),其中2^2和5就分别是最高次项p1^2*p2^1 if(S-1 &gt; ((last &lt; 0) ? 0 : primes[last]) &amp;&amp; is_prime(S-1)) &#123; res[len++] = product * (S-1); &#125; for(int i = last+1;primes[i] &lt;= S / primes[i];i++) &#123; int p = primes[i]; for(int j = 1+p,t = p;j &lt;= S;t *= p,j += t) &#123; if(S % j == 0) &#123; dfs(i,product*t,S/j); &#125; &#125; &#125;&#125;int main()&#123; get_primes(N-1); while(cin&gt;&gt;S) &#123; len = 0; dfs(-1,1,S); sort(res,res+len); cout &lt;&lt; len &lt;&lt; endl; if (len) &#123; sort(res, res + len); for (int i = 0; i &lt; len; i ++ ) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>NumberTheory</category>
        <category>dfs</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diver-dp]]></title>
    <url>%2F2020%2F03%2F25%2FDiver-dp%2F</url>
    <content type="text"><![CDATA[跟一般背包问题有区别的二维费用背包问题 - AcWing 1020.潜水员第三十二天！striving 题目 输入输出 分析如图所示，对于一般的题目来看，它似乎只是一个二维费用背包问题 但是这个题目的不同之处就在于它的要求是体积至少为j时候的最少费用 以一维费用举例的话1.体积最多为j,初始化f[N]全部初始为0，要保证体积V&gt;=0 2.体积恰好为j,只能初始化f[0] = 0，其余全部为正无穷，要保证体积V&gt;=0 3.体积至少为j,只能初始化f[0] = 0，其余全部为正无穷，不用保证体积V&gt;=0的情况 体积最多为j，那么体积不为0的情况也包含f[0] = 0的情况因为一个物品都不选的时候，总体积为多少都无所谓，那么此时f[N]全部为0 体积恰好为j，那么一个物品都不选的时候，体积只能为0，所以只有f[0] = 0合法，其余的情况都不合法根据题目情况设置成正无穷还是负无穷 体积至少为j，一个物品都不选的情况和体积恰好为j的情况一样，因为不选物品体积就只能为0 那为什么体积至少为j的时候就不用保证体积V&gt;=0呢？在这个题里面结合具体情况理解来看我觉得就是就算j &lt; V[i]的话，表示还需要的氧气或者氮气的体积j比现在提供的V[i]要少 但是提供的氧气或者氮气的体积多一点也不要紧啊，依然能满足潜水员的使用，所以没问题 但即使所需要的氧气或者氮气所需的是数量是负数，负数会越界 但其所需数量与0是等价的，因此可以通过所需数量为0来转移 当体积为0的时候就一定意味着每一个气缸都没有选，而气缸的重量都是大于0的 代码如下123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 22,M = 80,K = 1e4+10;int m,n,k;int f[N][M],O2[K],N2[K],W[K];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i &lt;= k;i++) &#123; scanf("%d%d%d",&amp;O2[i],&amp;N2[i],&amp;W[i]); &#125; memset(f,0x3f,sizeof f); f[0][0] = 0; for(int i = 1;i &lt;= k;i++) &#123; for(int j = n;j &gt;= 0;j--) &#123; for(int l = m;l &gt;= 0;l--) &#123; f[j][l] = min(f[j][l],f[max(0,j-O2[i])][max(0,l-N2[i])]+W[i]); &#125; &#125; &#125; printf("%d",f[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>dp</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheFactorChain-Of-X]]></title>
    <url>%2F2020%2F03%2F25%2FTheFactorChain-Of-X%2F</url>
    <content type="text"><![CDATA[数论相关知识一 - AcWing 1295.X的因子链第三十一天！一个多月了！ 题目 输入输出 分析分析题意 1.最大长度如果想让X的因子组成的因子链最长，那么它的因子链一定得是质数才行，不然如果是合数的话就可以拆分成两个以上的和从而使它的长度增加 所以问最大长度就是问对X分解质因数后质因数的总和 2.最大长度序列对于X = 540 = 2^2 * 3^3 * 5来说序列的最大长度就是2 + 3 + 1 = 6最长长度就为 2 4 12 36 108 540x2 x2 x3 x3 x3 x5或者 2 6 12 36 108 540x2 x2 x2 x3 x3 x5…….等等 那么因为所有的2和所有的3都可以互换位置，那么我们就要去掉2和3他们可以互换位置的情况，即除以2!*3!从而只剩一种情况 最大长度的子序列个数就为(2+3+1)!/(2!*3!*1!) = 720/(2*6*1) = 60 3.分解质因数A.我们可以用线性筛的方法来分解质因数,st[N]数组表示有没有被筛的意思，如果没有被筛，表明当前这个数是质数，然后用这个数去筛掉其他合数 因为每个数只会被筛一次，所以时间复杂度为O(n) B.我们在筛质数的图中可以开一个minp数组，来记录对应的数X的最小质因数是谁 这样子可以方便我们对X分解质因数 X最小的质因数为p = minp[X],然后min[X / p]是另一个质因数，依次类推可以得到X的所有质因数 比如540 = 2^2*3^3*5 123456789101112131415161718void get_primes(int x)&#123; for(int i = 2;i &lt;= x;i++) &#123; if(!st[i]) &#123; minp[i] = i; primes[cnt++] = i; &#125; for(int j = 0;i*primes[j] &lt;= x;j++) &#123; int t = i*primes[j]; minp[t] = primes[j]; st[t] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125; 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;/*对于X = 540 = 2^2 * 3^3 * 5来说序列的最大长度就是2 + 3 + 1 = 6最长长度就为 2 4 12 36 108 540x2 x2 x3 x3 x3 x5或者 2 6 12 36 108 540 x2 x2 x2 x3 x3 x5等等那么因为所有的2和所有的3都可以互换位置，那么我们就要去掉2和3他们可以互换位置的情况，即除以2!*3!只剩一种情况最大长度的子序列个数就为(2+3+1)!/(2!*3!*1!) = 720/(2*6*1) = 60*/typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int primes[N],minp[N],X;bool st[N];int cnt = 0;void get_primes(int x)&#123; for(int i = 2;i &lt;= x;i++) &#123; if(!st[i]) &#123; minp[i] = i; primes[cnt++] = i; &#125; for(int j = 0;i*primes[j] &lt;= x;j++) &#123; int t = i*primes[j]; minp[t] = primes[j]; st[t] = true; if(i % primes[j] == 0) break; &#125; &#125;&#125;int main()&#123; get_primes(N-1); while(scanf("%d",&amp;X) != -1) &#123; int k = 0,tot = 0; int count[N]; while(X &gt; 1) &#123; int t = minp[X]; fac[k] = t,count[k] = 0; while(X % t == 0) &#123; count[k]++; X /= t; tot++; &#125; k++; &#125; LL res = 1; for(int i = 1;i &lt;= tot;i++) res *= i; for(int i = 0;i &lt; k;i++) &#123; for(int j = 1;j &lt;= count[i];j++) &#123; res /= j; &#125; &#125; printf("%d %d\n",tot,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Number-theory</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheMaxXOR]]></title>
    <url>%2F2020%2F03%2F24%2FTheMaxXOR%2F</url>
    <content type="text"><![CDATA[最大异或对(字典树)第三十天！ 题目 输入输出 分析思路暴力解法12345678int res = 0;for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; i;j++) &#123; res = max(res,a[i]^a[j]); &#125;&#125; 暴力解法的时间复杂度显然超时，所以我们需要对内层循环进行优化 那么内层循环的含义是什么？ 内层循环的含义就是从a[0]到a[i-1]这些中找到一个与a[i]异或最大的值 那么这个操作就可以用Trie树进行优化 1.因为要使异或对最大，把a[i],a[j]都转化成二进制数，那么我们从高位开始就要开始与a[i]不同 2.因为0&lt;=Ai&lt;2^31,那么从30位开始从高往低去存储Ai对应的二进制数，从而形成一个字典树 3.我们应该先存储再查询，因为如果先查询再存储的话，那么当根节点为0即字典树里面还什么都没有的情况就要特判，为了避免这种情况我们就先存储再查询 4.查询的时候因为要使得异或最大，所以如果要查询a[i]对应的最大异或值对应的a[j]，那么a[j]的二进制表示就要尽可能的与a[i]的不同，比如a[i]为(11101)那么a[j]最好就为(00010) 所以再查询字典树的时候，如果a[i]当前的二进制位为1，那么就往字典树的0方向走，如果二进制位为1，就往字典树的1方向走但是如果没有对应相反的方向的话，就只能从相同的方向去走了 在每次查询一开始就初始化res = 0,然后在循环中依次res*2+u或者res*2+!u因为我们字典树就是从高位开始存储的，所以这样做没问题 所以我们用O(n)的时间复杂度就解决了问题，这里运用的正是空间换时间的思想 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010,M = 31*N;int n;int a[N];int son[M][2],idx;void insert(int x)&#123; int p = 0; for(int i = 30;i &gt;= 0;i--) &#123; int t = x &gt;&gt; i &amp; 1; if(!son[p][t]) son[p][t] = ++idx; p = son[p][t]; &#125;&#125;int query(int x)&#123; int p = 0,res = 0; for(int i = 30;i &gt;= 0;i--) &#123; int t = x &gt;&gt; i &amp; 1; //如果从根节点开始和a[i]另一个方向走 if(son[p][!t]) &#123; p = son[p][!t]; res = res*2 + !t; &#125; else//如果没有另一个方向，就只有往这个方向走了 &#123; p = son[p][t]; res = res*2 + t; &#125; &#125; return res;&#125;int main()&#123; scanf("%d",&amp;n); int res = 0;//因为0异或任意值都是任意值，所以res可以设置成0 for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); for(int i = 0;i &lt; n;i++) &#123; insert(a[i]);//先插入再查询，避免了特判的情况 int t = query(a[i]); res = max(res,a[i]^t);//把每次的结果都与res取一个最大值，这样一重循环就能解决问题 &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>TrieTree</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TrieTree]]></title>
    <url>%2F2020%2F03%2F24%2FTrieTree%2F</url>
    <content type="text"><![CDATA[Trie字符串统计(字典树) 第二十九天！ Trie树Trie树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。 此外Trie树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。 它的Key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。 它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。 存储如图所示，对于很多字符串我们从根节点开始，把根节点设为0，然后对每个字符串依次从前往后存储到一课树中，到达字符串的末尾就用一个cnt[N]++数组打上一个标记，表示以这个字母结尾的字符串是有一个字符串的 查找从根节点开始走，与要寻找的单词开始匹配 1.如果找到的下一个结点不存在要寻找的单词，就返回false 2.如果要寻找的单词到结尾了没有cnt[N]数组的标记，表示Trie树里也没有要寻找的单词，返回false 题目 输入输出 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std; //trie树，字典树const int N = 100010;int son[N][26];//每一个结点最多只会连26条边，因为只有小写字母,且这个数组存放的是每一个字母对应的idx//且第一维存放的是父节点的idx，第二位存放的是子节点字母从a到z映射到0到25的值int cnt[N];//以当前这个点解结尾的单词有多少个int idx;//下标是0的点，既是根节点，又是空节点char str[N];void insert(char str[])&#123; int p = 0;//从根节点开始 for(int i = 0;str[i];i++)//字符串结尾是\0 &#123; int u = str[i] - 'a'; //如果p这个结点不存在u这个儿子 if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++;//循环完之后即为最后一个点，让这个点的cnt++，表示以这个点为结尾的多了一个&#125;int query(char str[])&#123; int p = 0; for(int i = 0; str[i];i++) &#123; int u = str[i] - 'a'; if(!son[p][u]) return 0;//如果要寻找的下一个结点不存在，返回false p = son[p][u]; &#125; return cnt[p];//返回出现了多少次&#125;int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; char op[2]; scanf("%s%s",&amp;op,&amp;str); if(op[0] == 'I') insert(str); else printf("%d\n",query(str)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>TrieTree</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum-match-of-bipartite-graph]]></title>
    <url>%2F2020%2F03%2F21%2FMaximum-match-of-bipartite-graph%2F</url>
    <content type="text"><![CDATA[二分图的最大匹配第二十八天,差不多四十多天才完成了接近一个月的量，深深感受到人的惰性是多么可怕 关于二分图的定义，可以看我上一章染色法判定二分图里面的相关知识，这里不再赘述 二分图最大匹配的思路如果所示，对于一个二分图来说，左右两边为两个集合，我们要求左右两边最多能匹配多少条边一开始A连F，匹配A-F 然后下一个点B连E，匹配B-E 下一个点C连F，但是这个时候F已经被A相连了这个时候就回过头来找F对应的A，看A还有没有其他能相连的点，然后发现A还和H相连 这个时候就让A匹配H，A-H，这个时候F就没人连，然后C就可以和F匹配了，即C-F 最后一个点D匹配G 所以最终所有能匹配的边即为A-H,B-E,C-F,D-G即最多匹配四个边 如何去实现这个过程？我们可以用邻接矩阵去连接从左集合到右集合的边 然后用一个match[i]来记录右边集合已经匹配的是左边集合中的哪个点这样我们遇到矛盾的时候就可以快速找到右边集合对应匹配的左边集合的那个点 然后看左边集合的那个点时候还可以找到除了当前匹配这个点的另外的点 如果能找到，那么就皆大欢喜返回true，如果不能，就返回false 注意点1.最后我们从左边的每一个点开始寻找右边有没有能点能匹配的时候要加一个判重数组st[N]st数组用来防止重复搜索相同的点。而且当图中有环的时候，不加st数组可能会无限循环下去，就出现段错误了 且st数组每次搜索前都需要重置成false，因为匹配结果记录在match数组中，st数组用来判重，避免在某次匹配中重复遍历点和边。2.我们只用加从左边集合到右边集合的一条边即可，因为我们用match数组记录右边数组已经匹配的点，然后就可以直接find(match[j])判断是否成立 题目 输入输出 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 510,M = 1e5+10;//因为只用加一个边，所以M不用翻倍int h[N],e[M],ne[M],idx;bool vis[N];int match[N];int n1,n2,m;void add(int a,int b)&#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125;bool find(int x)//判断x能否与二分图另一个连通块的点连上边&#123; for(int i = h[x];i != -1;i = ne[i]) &#123; int j = e[i]; if(!vis[j]) &#123; vis[j] = true; //如果j还没有已经匹配的对象的话 if(match[j] == 0 || find(match[j]))//因为已经使vis[j]等于true了， &#123; //所以在find已经match好了的t = match[j]的时候就不会再重复匹配j，而是去找下一个能够匹配的点 match[j] = x; return true;//如果能够匹配，返回true表示x已经找到匹配的对象 &#125; &#125; &#125; return false;//否则返回false表示匹配不成功&#125;int main()&#123; scanf("%d%d%d",&amp;n1,&amp;n2,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); add(a,b);//添加a到b的一条边，因为我们的操作只需要从a找到b，就算是遇到已经匹配好的情况 //也是从已经match好了的b对应的match[b]重新去寻找除了b能够匹配的点，所以这里只需要add一条边 &#125; int res = 0; for(int i = 1;i &lt;=n1;i++)//我们只需要从左边的二分图开始进行匹配即可 &#123; memset(vis,0,sizeof vis);//匹配结果记录在match中，vis数组用来判重，避免在某次匹配中重复遍历点和边。 if(find(i)) res++; &#125; printf("%d",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>bipartite-graph</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bipartite-graph]]></title>
    <url>%2F2020%2F03%2F21%2Fbipartite-graph%2F</url>
    <content type="text"><![CDATA[染色法判定二分图 第二十七天，一个多月了，才发现坚持一件事是多么困难 染色法判定二分图什么是二分图 简而言之就是两个子集的内部的点没有边相连边只在两个子集之间连接 二分图的一个重要性质二分图当且仅当图中不含奇数环 因为如果存在奇数环(环当中点的数量为奇数)，从起点开始，起点属于左边的集合A那么下一个点就属于右边的集合B，下一个点的下一个点就属于左边的集合A 依次类推，可以推回起点是属于右边的集合，这与一开始起点属于左边的集合矛盾了 所以如果一个图是二分图，它肯定不存在奇数环 判断一个图是不是二分图从一个点开始，把它染色成1，把它相邻的点都染成2，把相邻的点的下一个相邻点染成1，然后依次类推 所以在染的过程中如果出现了矛盾，那么就不是一个二分图即一条边的两个点颜色不能相同 判断矛盾的条件1.染当前这个点，判断他相邻的点颜色如果和他相同的话，矛盾如果没出现矛盾的话，说明这个图是二分图 题目 输入输出 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5+10,M = 2e5+10;int h[N],e[M],ne[M],idx;//因为要加a到b和b到a的边，所以e,ne的大小要翻倍int n,m;int color[N];void add(int a,int b)&#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++;&#125;bool dfs(int u,int c)&#123; //没有被染色，先把u这个点染成c这个颜色 color[u] = c; //遍历u这个结点连接的结点，依次染成不同的颜色 for(int i = h[u];~i;i = ne[i]) &#123; int j = e[i]; //还没有被染过色的话 if(color[j] == 0) &#123; //就把当前结点染成3-c，这样做的好处是我们一开始把u染成1 //然后相邻的被染成3-1 = 2，染成2之后再进入dfs中c = 2，则相邻结点染成3-2 = 1 //如果相邻结点继续染色后返回为false产生矛盾的话说明当前的图不为二分图，返回false if(!dfs(j,3-c)) return false; &#125; //如果染过色的话就判断这个结点和相邻的结点颜色是否相同，如果相同返回false else if(color[j] == c) return false; &#125; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); add(a,b),add(b,a); &#125; int flag = 1; //因为二分图不一定是连通的，所以要从每个点开始判断 for(int i = 1;i &lt;= n;i++) &#123; if(color[i] == 0 &amp;&amp; !dfs(i,1)) &#123; flag = 0; break; &#125; &#125; if(flag) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>bipartite-graph</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recordingtime]]></title>
    <url>%2F2020%2F03%2F17%2Frecordingtime%2F</url>
    <content type="text"><![CDATA[记录自己的每一天,总结与反思 从今天开始记录自己每天干了些什么，完成多少任务，应该怎么去改进与反思 第四周4.91. 李范全书开始（8：00 - 11：00） 2. 英语单词150个（11：00 - 12：00） 3. 英语阅读继续积累（18：20 - 19：00） 4. PAT辅导课（7：00-9：00） 5. DIV3（4，5）（15：00 - 17：30） 6. 整理算法题到博客上 7. 复习acwing基础课提高课的技巧 8. 操作系统（13：30 - 15：00） 9. 完成计算化学作业 开始学习全书的内容，少看手机，提高效率如果有一个任务没完成 4.71. 李范全书开始 2. 英语单词150个 3. 英语阅读 4. 汤家凤收尾 5. 1800题继续做 6. 整理数学刷题的易错点和技巧 7. PAT辅导课（7：00-9：00） 8. DIV3 9. 整理算法题到博客上 10. 复习acwing基础课提高课的技巧 新的开始，加油了！ 第三周4.3跟昨天的任务差不多 汤家凤基础课 1800题 div3 洛谷dfs 操作系统 贪吃蛇项目 PAT辅导课 英语阅读 多弄一下贪吃蛇项目，以及重新开始背英语单词！坚持学习操作系统 4.21. acwing银行排队(pat) 2. 汤家凤基础课 3. 1800题 4. div3 5. 洛谷dfs 6. 操作系统 7. 贪吃蛇项目 8. PAT辅导课 9. 英语阅读 明天打游戏的时间挪到星期五完成上面所有任务，不完成不睡觉 除了洛谷的dfs和银行排队系统看不太懂意思没完成之外，其余或多或少都有多完成，今后要更加把控质量！ 3.31 汤家凤 1800题 英语单词 英语阅读 codeforces div3 算法提高班 洛谷dfs AC saber 贪吃蛇项目！ 操作系统 整理博客 线性代数 数据结构 完成以上任务至少70% 3.301. 汤家凤 2. 1800题 3. 英语单词 4. 英语阅读 5. codeforces div3 6. 算法提高班 7. 洛谷dfs 8. AC saber 9. 贪吃蛇项目！ 10. 操作系统 刷数学题不看手机晚上十二点前睡觉！用电脑尽量少干不相关的事情，争取每天九点前做好每一件事，九点后自己想干嘛干嘛尽量少看东方财富！！！ 总结今天状态很不多，明天继续保持！ 第二周3.281. AC saber 复习 2. PAT每日一题 3. 汤家凤数学 4. 1800题继续做 5. 英语单词 6. 英语阅读 7. 贪吃蛇项目继续开始 8. 数据结构 9. 算法提高课 10. 蓝桥杯真题继续刷 从明天开始尝试不设番茄钟进行学习同时，争取一天不看手机！ 3.25早晨 1. 汤家凤数学（8：00-10：00） 2. 数学1800题（ 10：10-11：30） 3. 英语单词（11:30-12:00) 中午 1. 睡觉（12：50-13：20） 2. 英语单词（13：20-13 : 50） 下午 1. 复习并查集（14：00-14：30） 2. 总结Acwing潜水员到博客中 3. 算法提高课dp（14：30 - 15：30） 4. 蓝桥杯数论继续学习并总结（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 继续完成贪吃蛇项目 （19 ：30 - 21 ：00） 十点之后的时间自行安排继续加油！今天完成任务的一半差不多，效率很低很低，明天开始对自己设置惩罚如果没完成80%任务！ 3.24早晨 1. 英语单词（7：30-8：00） 2. 汤家凤数学（8：00-10：00） 3. 数学1800题（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习快排与归并排序（14：00-14：30） 2. 算法提高课dp（14：30 - 15：30） 3. 蓝桥杯数论开始学习（15：30-17：30） 4. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 开始动手贪吃色项目（20：30 - 21：30） 十点之后的时间自行安排 总结今天的效率还行，能达到大约80%的感觉，但是在很多地方仍然需要继续更加专心才行，感觉番茄todo的每个番茄钟可以调到45分钟，适当的长一点对自己也有好处，起码不用再经常经常惦记着什么时候结束了，自己能够更加专注的去刷题今天开始了贪吃蛇项目，以后每天会分出一个半小时的时间去完成它！ 既然选择了开始，就要坚持下去。而且还要养成英文检索的习惯！加油 3.23早晨 1. 英语单词（7：30-8：00） 2. 汤家凤数学（8：00-10：00） 3. 数学1800题（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习模拟散列表（14：00-14：30） 2. 复习堆排序（14：30 - 14：50） 3. 复习字典树、最大异或对（14：50-15：30） 4. 蓝桥杯数论开始学习（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 开始动手贪吃色项目（20：30 - 21：30） 十点之后的时间自行安排明天加油啦，已经有小朋友比你还努力了，你还有什么不努力的理由呢？ 第一周3.21的任务安排周末的两天要加油啊！！！！早晨 1. 英语单词（7：30-8：00） 2. 数学1800题 （8：00-10：00） 3. 算法提高课dp（ 10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习染色法判定二分图（14：00-14：30） 2. 复习匈牙利算法（14：30 - 14：50） 3. 复习字典树（14：50-15：30） 4. 蓝桥杯数论开始学习（15：30-17：30） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30 - 21：30） 十点之后的时间自行安排 3.20的任务安排早晨 1. 英语单词（7：30-8：00） 2. 数学汤家凤（8：00-10：00） 3. 数学1800题（10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习Prim算法（14：00-14：30） 2. 复习kruskal算法（14：30 - 14：50） 3. Floyd（14：50-15：30） 4. 蓝桥杯复习贪心最后两题以及数论开始学习（15：30-17：00） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30-21：30） 十点之后的时间自行安排 总结今天的效率依旧不尽如人意，还是因为早晨看股市的缘故导致自己喜欢分心，周末需要尝试一下自己不看股市真正专注的情况了下午还好，但是PAT还是没抽时间去做题，晚上也是因为想吃外卖等因素导致没有完成今天的任务，今天的完成度还是只有65%左右但是今天把要交的作业都弄到手了，明天抽时间做完，明天多抽时间在做算法题上了 3.19的任务安排早晨 1. 英语单词（7：30-8：00） 2. 数学汤家凤（8：00-10：00） 3. 数学1800题（10：10-11：30） 4. 英语单词（11:30-12:00) 中午 1. 英语单词（12：30-13：00） 2. 睡觉（13：00-13：40） 下午 1. 复习八数码问题（14：00-14：30） 2. 八皇后（14：30 - 14：50） 3. dijkstra和SPFA（14：50-15：30） 4. 蓝桥杯复习贪心专题（15：30-17：00） 5. PAT每日一题（17：00-17：30） 晚上 1. 英语阅读（18：30-19：30） 2. 浙大数据结构（19：30-20：30） 3. 操作系统（20：30-21：30） 十点之后的时间自行安排 总结今天的学习效率还是不尽如人意，效率只有60%不到的样子，原因还是因为炒股看东方财富、以及困觉的原因，明天一定要避免这种情况发生！！！早晨多抽出时间来写1800题，下午多写写题目，今天PAT和英语阅读都没做，明天花时间补上一篇！明天一定要坚持试一试效率看能不能到90% 3.18的任务安排早晨1.英语单词 7:30-8:002.数学网课 4章 8:00-10:003.1800题 10:10-11:30 中午1.英语单词 11:30 - 12:00(or 12:00-12:30)2.睡觉 12:50 - 13:30 下午14:00-17:301.复习字符串哈希2.继续学习双指针BFS图论3.开始刷蓝桥杯的题目4.PAT每日一题 晚上1.英语阅读 18:30 - 19:302.数据结构 19:45 - 20:303.操作系统 20:30 - 21:30洗澡半个小时22：00以后自己安排时间 总结今天基本上完成了80％的任务，除了操作系统和蓝桥杯的题目没有刷之外基本上都还可以，数学刷题的速度需要加快但是由于早晨和下午看股市导致自己无法专心到学习中来，以后要从股市中脱身出来专心考研学习！！！]]></content>
      <categories>
        <category>recording</category>
      </categories>
      <tags>
        <tag>记录自己的每一天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-1215]]></title>
    <url>%2F2020%2F03%2F15%2FAcWing-1215%2F</url>
    <content type="text"><![CDATA[一道树状数组与逆序对思想结合的题目 第二十六天。心碎 题目 输入输出 分析思路由样例可以分析得到，这道题就相当于一个冒泡排序，每次交换相邻两个人 每次从前往后去扫，如果前面比后面大就交换 但是这其中的思想就是一种逆序对的思想 因为冒泡排序每排序一次，逆序对的数量就减1 所以冒泡排序交换的次数就是逆序对的数量 所以针对一个小朋友来说 如果前面有K1个小朋友比它高，那么必然会交换K1次到这个小朋友的后面 同理如果后面有K2个小朋友比它高，那么必然会交换K2次到这个小朋友的前面 所以交换的次数就是K1+K2次 于是我们可以用一个树状数组来进行存储，树状数组的大小为题目中最大的数值 以数值来进行存储 查询一下大于这个数的数有多少个，然后加到sum[i]中 然后把这个数加入到树状数组中 同理查询一下小于这个数的数有多少个，然后加到sum[i]中 然后把这个数加入到树状数组中 最后sum[i]中存储的就是每个数左右两边对应的k1+k2然后用等差数列求和公式sum[i]*(sum[i]+1)/2 因为最坏情况下可能要交换10^5次，那么10^5*(10^5+1)/2 = 5*10^9，但是int的范围大约在2*10^9，所以最后的结果可能会爆int，所以要在乘积里面就转换成long long res += 1LL*sum[i]*(sum[i]+1)/2 注意点1.因为从前往后循环的过程中把每个身高的人数记下来了，所以可以查询小于当前身高的人数。后半部分同理，所以要从后往前循环！2.第二次从后往前求的时候记得要把树状数组清零再求 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//树状数组的写法const int N = 1000010;typedef long long LL;int a[N],C[N],sum[N];//树状数组维护的是每个身高的人数int n;int lowbit(int x)&#123; return x &amp; -x;&#125;int add(int x)&#123; for(int i = x;i &lt; N;i+= lowbit(i)) C[i]++;//人数加1&#125;int query(int x)&#123; int res = 0; for(int i = x;i &gt;= 1;i -= lowbit(i)) res += C[i]; return res;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); LL res = 0; //求每个数前面有多少个比它大，对于a[i]来说，求a[i]+1到N里面有多少个数就是比它大的数 for(int i = 1;i &lt;= n;i++) &#123; sum[i] = query(N-1) - query(a[i]);//数组的最大的下标为N-1 add(a[i]); &#125; //把树状数组清零，再从后往前 memset(C,0,sizeof C); //求每个数前面有多少个比它小，对于a[i]来说，就是求从1到a[i]-1有多少个数比它要小 for(int i = n;i &gt;= 1;i--) &#123; sum[i] += query(a[i]-1); add(a[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; res += 1LL*sum[i]*(sum[i]+1)/2; &#125; printf("%lld",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2392-dp]]></title>
    <url>%2F2020%2F03%2F08%2Fluogu-P2392-dp%2F</url>
    <content type="text"><![CDATA[P2392 kkksc03考前临时抱佛脚(可以转化成01背包的一个问题)第二十五天，坚持。 题目 输入输出 分析思路这一题的思路跟一开始见到的想法不一样 一开始我以为如果一共有三道题目，分别要4分钟、3分钟、2分钟 我以为写如果同时写4分钟的题和3分钟的题，必须4分钟的题写完了才能写下一道 但是根据样例来看并不是这样，比如4分钟内同时写4分钟的和3分钟的题，3分钟的题写完了的时候就可以直接写下一道题，那么就需要4 + (2 - (4 - 3)) = 5 因为可以有两个脑处理问题，如果把所有的时间平均成两半最好了，也就是两个脑所消耗的时间差为0最好，但显然不一定所有的数据都一定能满足两个脑能同时为t/2，所以我们要尽可能的保证两个脑子所消耗的时间差最小 既然不能保证同时为t/2，那么一定有一个脑子处理的时间小于t/2，另一个大于t/2 于是这题就可以转换成一个01背包问题，即在体积为t/2的情况下，能够把背包尽可能填满的最大值，这里价值也是时间，那么最后f[t/2]就是在t/2体积的情况下能够装满其中一个脑子的最多时间，那么另外一个脑子用的时间就是t - f[t/2]，最后取一个max，max(f[t/2],t - f[t/2])就是一科里面所用的最少的时间了 举一个例子10,8,7,3,2,1 合理的方案就是写10分钟和8分钟的，这时候t = 10 然后8分钟写完了，写那个7分钟的，t = 10 7分钟的写了2分钟还能5分钟写完 所以还剩5,3,2,1 这个时候写5分钟同时写3分钟的，t = 10 + 5 = 153分钟写完了同时再写2分钟的 则写完15分钟后还剩下1分钟的作业，最后t = 15 + 1 = 16 最后左脑10 + 3 + 2 + 1 = 16右脑8 + 7 = 15 所以就相当于把这么多的物品平均分到两个篮子里面使得两个篮子的物品总和相差最小，越平均越好 代码如下123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 610,M = 21;int f[N];int num[M];int s[4];int main()&#123; for(int i = 0;i &lt; 4;i++) scanf("%d",&amp;s[i]); int t = 0; for(int k = 0;k &lt; 4;k++) &#123; int sum = 0; for(int j = 1;j &lt;= s[k];j++) &#123; scanf("%d",&amp;num[j]); sum += num[j]; &#125; memset(f,0,sizeof f); //cout&lt;&lt;sum/2&lt;&lt;"----"&lt;&lt;endl; for(int i = 1;i &lt;= s[k];i++) &#123; for(int j = sum/2;j &gt;= num[i];j--) &#123; f[j] = max(f[j],f[j-num[i]]+num[i]);//转换为01背包问题的写法 &#125; &#125; //cout&lt;&lt;f[sum/2]&lt;&lt;endl; t += max(f[sum/2],sum-f[sum/2]); &#125; printf("%d",t); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1363-dp]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-1363-dp%2F</url>
    <content type="text"><![CDATA[一个关于背包问题具体方案的求解 第二十四天，继续整理一些比较典型的题目 题目 样例 分析思路 如图所示，可以把这个题转换为一个背包问题来求解，最后如果要求具体的方案，可以最后的状态一步一步向前转移来判断，用状态的转移最后求出具体的方案 因为f[n][0]表示从前n个物品，且总体积模3余0的最大价值，那么我们应该把digits[N]数组从小到大排序，因为我们最后是从后往前推导状态能否转移过来 所以可以从后往前，把较大的数放到后面来判断，如果状态能够转移就先选最大的数，然后依次判断状态能够转移继续选数，因为是从大到小枚举，所以能选则选 因为我们最后求得的f[n][0]表示的是价值最大的选法，就是可以选的数字最多是多少，然后再从最大的数字从后往前推状态的转移即可，如果可以转移就表示能选digits[i]就先选，然后再转移判断能不能继续选 注意点1.因为存在全是{“0”,”0”,”0”,”0”…..}这种情况，为了避免消除前导0，我们可以直接判断res途中是否为”0”，因为从大到小枚举，已经出现0了，那么后面接着的不可能比0大，所以直接返回”0” 2.f[0][1],f[0][2]都是不合法的状态要赋给一个很小的值才行 代码如下1234567891011121314151617181920212223242526272829303132class Solution &#123;public: const int N = 1e4+10; string largestMultipleOfThree(vector&lt;int&gt;&amp; digits) &#123; sort(digits.begin(),digits.end());//因为我们是从最后的状态来往前推，所以数组从小到大排序即可 int f[N][3],num[N]; memset(f,0,sizeof 0); int n = digits.size(); f[0][1] = f[0][2] = -1e8;//因为f[0][1],f[0][2]都是不合法的状态，没有数不可能模余1或2，所以要设置成一个很大的负数 for(int i = 1;i &lt;= n;i++) num[i] = digits[i-1]; for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt;= 2;j++) &#123; f[i][j] = max(f[i-1][j],f[i-1][(j + 3 - num[i] % 3 )%3]+1); &#125; string res = ""; if(f[n][0] &lt;= 0) return "";//如果f[n][0]小于等于0，表示没有数字符合情况，直接返回空字符串 for(int i = n,j = 0;i;i--) &#123; if(f[i][j] == f[i-1][(j + 3 - num[i] % 3 )%3]+1)//如果能转移到右边选第i个物品的情况 &#123; res += to_string(num[i]);//选第i个物品 j = (j + 3 - num[i] % 3 )%3;//继续转移状态 &#125; if(res == "0") return res;//因为存在全是&#123;"0","0","0","0".....&#125;这种情况， //为了避免消除前导0，我们可以直接判断res途中是否为"0"，因为从大到小枚举，已经出现0了，那么后面接着的不可能比0大，所以直接返回"0" &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>dp</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1368]]></title>
    <url>%2F2020%2F03%2F03%2FLeetCode-1368%2F</url>
    <content type="text"><![CDATA[一个典型的01BFS的题目(最短路) 第二十三天，开始整理除了模板题之外的其他题目传送门 题目 样例 分析思路这题从题意上分析可知可以抽象成从点(0,0)走到点(n-1,m-1)的路径中最少修改的次数，其也跟最短路有关(一般的最短路的问题是问最短距离，这个最少的修改次数也可以跟最短路相关) 如果最短路的边权全部都是1的话可以用BFS进行求解，但是因为这个图的权值是0和1都存在，如果走的方向相同当前格子就为0，否则就为1，这个时候就不能用简单的BFS进行求解，而是用01BFS进行求解 01BFS，就不是简单的用queue去存储而是用一个双端队列deque去存储，如果当前边权为0就加入到队头、如果是1就加入到队尾，这样可以保证队列里面的单调性，确保我们取出的队头一定是最小的 说白了01BFS就是一个特殊的dijkstra算法，只不过是把堆优化版的dijkstra中的优先队列改成双端队列而已，队头必然是最小值，而且因为是从起点开始拓展的，如果边权为0加入队头，如果为1就加入队尾，然后依次拓展，这样一定保证队列里面单调的，这样子我们每次取的队头一定是最小值且是从起点拓展的。 同理，既然是最短路算法可以解决这个问题，我们同样可以用堆优化的dijkstra和SPFA去解决问题，思路跟上述类似不再详述，具体的过程在下列代码中 注意点为什么不能用dp？因为这个图更新的时候有一种环形的依赖关系，状态的更新可能是有循环的，没有一个明显的拓扑序 代码如下(01BFS)1234567891011121314151617181920212223242526272829303132333435typedef pair&lt;int,int&gt; PII;int n = grid.size(),m = grid[0].size(); int d[n+1][m+1]; bool vis[n+1][m+1];//判断是否拓展过 memset(d,0x3f,sizeof d); memset(vis,0,sizeof vis); int dx[5] = &#123;0,0,0,1,-1&#125;,dy[5] = &#123;0,1,-1,0,0&#125;; deque&lt;PII&gt; q; d[0][0] = 0; q.push_front(&#123;0,0&#125;); while(q.size()) &#123; PII t = q.front(); q.pop_front(); if(vis[t.first][t.second]) continue; vis[t.first][t.second] = true; for(int k = 1;k &lt;= 4;k++) &#123; int x = t.first+dx[k],y = t.second+dy[k]; if(x &lt; 0||x &gt;= n||y &lt; 0|| y &gt;= m) continue; int w = grid[t.first][t.second] != k ? 1 : 0; if(d[x][y] &gt; d[t.first][t.second] + w) &#123; d[x][y] = d[t.first][t.second] + w; &#125; if(w) q.push_back(&#123;x,y&#125;); else q.push_front(&#123;x,y&#125;); &#125; &#125; return d[n-1][m-1]; 代码如下(SPFA)123456789101112131415161718192021222324252627282930313233343536typedef pair&lt;int,int&gt; PII; const int N = 110;int dx[5] = &#123;0,0,0,1,-1&#125;,dy[5] = &#123;0,1,-1,0,0&#125;; int n = grid.size(),m = grid[0].size(); int d[N][N]; bool vis[N][N] = &#123;false&#125;;//这个数组是判断点是否在队列中 memset(d,0x3f,sizeof d); d[0][0] = 0; queue&lt;PII&gt; q; q.push(&#123;0,0&#125;); vis[0][0] = true; while(q.size()) &#123; auto t = q.front(); q.pop(); int x = t.first,y = t.second; vis[x][y] = false; for(int i = 1;i &lt;= 4;i++) &#123; int newx = x + dx[i],newy = y + dy[i]; if(newx &lt; 0 || newx &gt;= n || newy &lt; 0|| newy &gt;= m) continue; int w = grid[x][y] == i ? 0 : 1; if(d[newx][newy] &gt; d[x][y] + w) &#123; d[newx][newy] = d[x][y] + w; if(!vis[newx][newy]) &#123; q.push(&#123;newx,newy&#125;); vis[newx][newy] = true; &#125; &#125; &#125; &#125; return d[n-1][m-1];]]></content>
      <categories>
        <category>Leetcode</category>
        <category>SPFA</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BellmanFord-and-SPFA]]></title>
    <url>%2F2020%2F02%2F29%2FBellmanFord-and-SPFA%2F</url>
    <content type="text"><![CDATA[BellmanFord和SPFA算法第二十二天。 Bellman-Ford算法题目 输入输出 分析思路dijkstra算法不能处理有负权边的情况Bellman-Ford算法适用于带负环的图，如果题目限制了最短路经过的边的个数，如上图的代码，那么有负环也无所谓了，因为限制k次导致我们不能无限的经过负环实现思路：1234for(循环n次) for(循环所有边a,b,w) dist[b] = min(dist[b],backup[a]+w)//其中所有边就可以直接用一个结构体数组来存储，不一定需要邻接表，只要能遍历到所有边就可以了 为什么用backup[N]数组来存放上一个的结果如图所示，如果题目要求k = 1，那么我们从1到3只能选择下面一条路径去求如果不用backup数组来存放上一个的话那么d[1] = 0d[2] = min(d[1]+1,d[2]) = 1此时再继续循环d[3]= min(d[2]+1,d[2]) = 2此时d[3]就是用上一个已经更新了的2来继续更新的此时则发生串联那么我们只调用上一个的backup数组d[1] = 0;backup[1] = 0,backup[2] = INF,backup[3] = INF;d[2] = min(d[2],backup[1]+1) = 1//1—2(1)d[3] = min(d[3],backup[2]+1) = INF//2—3(1)d[3] = min(d[3],backup[1]+3) = 3//1—3(3) 时间复杂度为O(nm) 注意点1.为什么是d[n] &gt; 0x3f3f3f3f/2？因为存在负权边，那么虽然n也是正无穷，但是经过负权边可能会把n的正无穷减小一点，但是也不会减太多，最多减500*10000，所以写成d[n] &gt; 0x3f3f3f3f/2即可判断2.memset函数是以字节为单位赋值的，每个int包含4个字节，所以memset完之后所有数会变成0x3f3f3f3f 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510,M = 10010;int n,m,k;int d[N],backup[N];struct Edge&#123; int a,b,w; &#125;edges[M];int bellman_ford(int s)&#123; memset(d,0x3f,sizeof d); d[s] = 0; for(int i = 0;i &lt; k;i++) &#123; memcpy(backup,d,sizeof d); for(int j = 0;j &lt; m;j++) &#123; int a = edges[j].a,b = edges[j].b,w = edges[j].w; d[b] = min(d[b],backup[a] + w); &#125; &#125; if(d[n] &gt; 0x3f3f3f3f/2) return -1; return d[n];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i = 0; for(int i = 0;i &lt; m;i++)&#123; int a,b,w; scanf("%d%d%d",&amp;a,&amp;b,&amp;w); edges[i] = &#123;a,b,w&#125;; &#125; int t = bellman_ford(1); if(t == -1) puts("impossible"); else printf("%d\n",t); return 0;&#125; SPFA算法题目 输入输出 分析思路SPFA算法是bellman-ford算法的优化在bellman-ford算法中，他要遍历所有边来进行更新，但是每一次迭代不一定每一条边都需要更新 dist[b] = min(dist[b],dist[a]+w) 那么SPFA可以对其进行优化dist[b]如果想变小的话，那么一定是dist[a]变小了如果dist[a]不变，那么dist[b]也一定不变 那么我们每次就可以用一个队列(堆、优先队列，但是一般来说用队列就可以了)进行存储，队里面就存放的就是所有变小的结点，只要队列里面不空，就取出队头t，更新t的所有出边，如果更新成功，就把b加入队列，如果队列里面已经有b了，就不用再存放进队列里面了 它的基本思路就是我更新过谁，我就再拿谁去更新别人，一个点如果没有被更新过，那么它就没有必要去更新别人，只有前面的点变小了，后面的点才会跟着变小 我的理解就是，它这个点变小了，他肯定会影响更多的点，所以就需要放入队列里面进行操作 注意点1.spfa只会更新所有能从起点走到的点，所以如果无解，那么起点就走不到终点，那么终点的距离就是0x3f3f3f3f 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int h[N],e[N],ne[N],d[N],w[N],idx;bool vis[N];//vis[i]是判断是否存入过队列中int n,m;void add(int a,int b,int c)&#123; e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int spfa(int s)&#123; queue&lt;int&gt;q; q.push(s); vis[s] = true;//存入队列，vis[s] = true d[s] = 0; while(!q.empty()) &#123; int t = q.front(); q.pop(); vis[t] = false;//从队列中取出就改为false for(int i = h[t];i != -1;i = ne[i]) &#123; int j = e[i]; if(d[j] &gt; d[t] + w[i]) &#123; d[j] = d[t] + w[i]; if(!vis[j]) &#123; q.push(j); vis[j] = true;//加入队列就改为true &#125; &#125; &#125; &#125; if(d[n] == 0x3f3f3f3f) return -1; return d[n]; &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h); memset(d,0x3f,sizeof d); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t = spfa(1); if(t == -1) puts("impossible"); else printf("%d",t); return 0;&#125; SPFA判断负环题目 输入输出 分析思路在SPFA算法中dist[x]表示从起点s到x的最短距离那么我们可以用一个cnt[N]数组来存放，表示边数12345dist[x] = dist[t] + w[i]cnt[x] = cnt[t] + 11----------t——x| |---------------因为上面表示从1到t再到x的路径比下面的要短那么从1到t再到x的边数就是从1到t的边数再+1即cnt[x] = cnt[t] + 1此时如果cnt[x]&gt;=n的话，意味着从1到x至少经过了n条边，经过了n条边如果没有环的话就意味着有n+1个点，但是我们题目只有n个点，说明最短路径中存在环，这个环一定是负权的，因为如果是正权的，那经过这个环路径会变大，那我肯定不会经过这个环所以SPFA算法可以用来判断是否有负环 注意点1.有负环的话相当于某些点到起点的距离为负无穷，然后SPFA算法是正确的，且初始时这些点的距离为0,0大于负无穷，所以一定会把这些距离为负无穷的点不断更新，所以不需要把d数组赋值为正无穷 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int h[N],e[N],ne[N],d[N],w[N],idx,cnt[N];bool vis[N];//vis[i]是判断是否存入过队列中int n,m;void add(int a,int b,int c)&#123; e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int spfa()&#123; queue&lt;int&gt;q; for(int i = 1;i &lt;= n;i++) &#123; vis[i] = true; q.push(i); &#125; while(!q.empty()) &#123; int t = q.front(); q.pop(); vis[t] = false; for(int i = h[t];i != -1;i = ne[i]) &#123; int j = e[i]; if(d[j] &gt; d[t] + w[i]) &#123; d[j] = d[t] + w[i]; cnt[j] = cnt[t] + 1; if(cnt[j] &gt;= n) return 1; if(!vis[j]) &#123; q.push(j); vis[j] = true; &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h); //memset(d,0x3f,sizeof d); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t = spfa(); if(t) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>AcWing</category>
        <category>BellmanFord</category>
        <category>SPFA</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OptimizationOfDijkstra-byheap]]></title>
    <url>%2F2020%2F02%2F28%2FOptimizationOfDijkstra-byheap%2F</url>
    <content type="text"><![CDATA[堆优化的djiksra二十一。 题目 输入输出 分析dijkstra算法是针对单元最短路的一个算法n为点的数量,m表示边的数量但是朴素的dijkstra算法的时间复杂度为O(n^2)堆优化的dijkstra算法时间复杂度为O(mlogn) 因为朴素的dijkstra算法时间复杂度最高的部分就是两重循环找到离t距离最近的点，那么在一堆数里面找最小的数就可以用堆来进行优化了，那么时间复杂度会变成O(mlogn)具体的分析思路和关键步骤看如下代码即可 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;typedef pair&lt;int,int&gt; PII;//维护距离的时候还需要知道结点编号，所以需要用一个pair来存储int h[N],e[N],w[N],ne[N],idx = 0,d[N];int n,m;bool vis[N] = &#123;false&#125;;void add(int a,int b,int c)//记住模板&#123; //e[i]存放的是从a指向b的结点 e[idx] = b; //w[i]存放的是a到b的边权 w[idx] = c; ne[idx] = h[a]; h[a] = idx++;&#125;int dijikstra()&#123; fill(d+1,d+1+n,INT_MAX); d[1] = 0; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//用小根堆，使得堆最上面的元素最小 heap.push(&#123;0,1&#125;); while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int distance = t.first,ver = t.second; if(vis[ver]) continue; vis[ver] = true; //h[i]、w[i]中的i都是指的下标idx，求d[j]时候中的j是具体的点，所以j = e[i]取出对应被指向的那个点是谁 //ver是起点，i = h[ver]表示从起点能指向的下一个点，然后继续寻找，找到它能够到达的所有的点 for(int i = h[ver];i != -1;i = ne[i]) &#123; int j = e[i];//i = h[ver]为被指向那个的点对应的下标，然后e[i]就是存放被指向那个点是谁 if(distance + w[i] &lt; d[j])//w[i]指的是从起点指向下一个点对应的边权 &#123; //比如a指向b，那么w[b]就表示a到b的距离 //distance就表示从起点到ver的距离 d[j] = distance + w[i];//distance + w[i] &lt; d[j]表示从ver经过i这个点到j比直接到j的距离要短的话，就更新 heap.push(&#123;d[j],j&#125;);//并把更新后的距离和对应点的编号都插入到堆里面 &#125; &#125; &#125; if(d[n] == INT_MAX) return -1; return d[n]; &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); memset(h,-1,sizeof h);//设置从起点指向最后一个点到-1结束，取边界 while(m--) &#123; int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); add(a,b,c);//用邻接表进行存储就不需要再对重边进行处理，因为它可以保证会选最短的边 &#125; printf("%d",dijikstra()); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200225]]></title>
    <url>%2F2020%2F02%2F25%2F20200225%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>DiaryOfInvestment</category>
      </categories>
      <tags>
        <tag>投资心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MatrixOfFastPower]]></title>
    <url>%2F2020%2F02%2F25%2FMatrixOfFastPower%2F</url>
    <content type="text"><![CDATA[矩阵快速幂第二十天。 题目 输入输出 分析思路 注意点1.在计算矩阵快速幂的时候可能会爆int，所以要用long long存储2.f[N] = f[1]*A^N-1 因为f[n] = {fn,fn+1,Sn}那么f[2]就对应Sn经过快速幂最后得到的Sn的值3.对于计算fn*A12345for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt; N; j ++ ) temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m; a代表1X3的矩阵，b代表3X3的矩阵 这两个矩阵相乘后得到1X3的矩阵，所以是a的每一行a[j]去乘以b的第i行的j个数从上往下4.对于计算A*A1234567int temp[N][N] = &#123;0&#125;; for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt; N; j ++ ) for (int k = 0; k &lt; N; k ++ ) temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m; a和b都代表3X3的矩阵，那么最后相乘会得到3X3的矩阵 a[i][k]*b[k][j]表示a的每一行的第k个数乘以b的每一列的第k个数 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;int n,m;const int N = 3; //int f[N];int a[3][3] = &#123;&#123;0,1,0&#125;,&#123;1,1,1&#125;,&#123;0,0,1&#125;&#125;;void mul(int a[],int b[],int c[][N])&#123; int temp[N] = &#123;0&#125;; for(int i = 0;i &lt; N;i++) &#123; for(int j = 0;j &lt; N;j++) &#123; temp[i] = (temp[i]+(LL)b[j]*c[j][i]) % m; &#125; &#125; memcpy(a,temp,sizeof temp); &#125;void mul(int a[][N],int b[][N],int c[][N])&#123; int temp[N][N] = &#123;0&#125;; for(int i = 0;i &lt; N;i++) &#123; for(int j = 0;j &lt; N;j++) &#123; for(int k = 0;k &lt; N;k++) &#123; temp[i][j] = (temp[i][j] + (LL)b[i][k]*c[k][j])% m; &#125; &#125; &#125; memcpy(a,temp,sizeof temp); &#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); n--; int f[N] = &#123;1,1,1&#125;; while(n) &#123; if(n &amp; 1) mul(f,f,a);//res = res *a; mul(a,a,a);//a *= a; n &gt;&gt;= 1; &#125; cout&lt;&lt;f[2]; //f[N] = f[1]*A^N-1 因为f[n] = &#123;fn,fn+1,Sn&#125;那么f[2]就对应Sn经过快速幂最后得到的Sn的值 return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>FastPower</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashOfString]]></title>
    <url>%2F2020%2F02%2F24%2FHashOfString%2F</url>
    <content type="text"><![CDATA[字符串哈希 第十九天，加油！ 题目 输入输出 样例 分析思路这题可以用字符串哈希的方式去解决把字符串看成是一个P进制的数str = “ABCABCDEYXC…..”那么h[0] = 0;h[1] = “A”的hash值h[2] = “AB”的hash值h[3] = “ABC”的hash值h[4] = “ABCA”的hash值…1.那么对于1到N的字符串来说如果想求L到R区间的hash值因为h[R]表示1到R的hash值h[L-1]表示1到L-1的hash值那么对于P进制来说，由于从左到右是从高位往低位走对于h[R]来说，下标R对应的为P^0,R-1为P^1,…,依次类推1对应的就是P^(R-1)对于h[L-1]，下标L-1对应的为P^0,L-2为P^1,…,依次类推1对应的就是P^(L-2)那么我们把h[L-1]向左移直到与h[R]对齐，左移的位数就是R-1-(L-2) = R-L+1比如123456789，我们要求789这个哈希值那么就找到7之前的哈希值123456然后向左移3位得到123456000最后123456789 - 123456000 = 789所以从L到R这段的hash值就表示为h[R] - h[L]*P^(R-L+1) 2.对于字符串hash来说ABCD假设映射为(1234)p那么ABCD的hash值就为(1*P^3+2*P^2+3*P^1+4*P^0)mod Q那么映射的hash值就是0到Q-1的数了PS:Q经验值取2^64，p一般取131或者13331 注意点1.字符串哈希默认P进制中的P = 131或者133312.不能把某一个字母映射成0，假设A映射成0，A的hash值为0，那么AA的hash值也为0，这样不同的字符串映射成了同一个数字，所以需要避免这种现象3.因为映射的Q为2^64,我们可以不用取模运算，直接用unsigned long long 来存储我们所有的h[i]，溢出的时候就相当于模上2^644.预处理前缀就是h[i] = h[i-1]*P + str[i]; 应用可以应用于一个字符串里面判断有没有两段是完全相同，这个方法比KMP要更好而且很多拓展的题目也可以应用到这个字符串哈希方法 草稿 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010,P = 131;int n,m;char str[N];ULL h[N],p[N];ULL get(int l,int r)//计算(l,r)的hash值&#123; return h[r] - h[l-1]*p[r-l+1]; &#125;int main()&#123; scanf("%d%d%s",&amp;n,&amp;m,str+1); p[0] = 1;//令P^0 = 1 for(int i = 1;i &lt;= n;i++) &#123; p[i] = p[i-1] * P;//预处理P^i h[i] = h[i-1]* P + str[i];//计算字符串的前缀和取模hash值，因为用的是ULL类型所以就不用取模运算了 &#125; while(m--) &#123; int l1,r1,l2,r2; scanf("%d%d%d%d",&amp;l1,&amp;r1,&amp;l2,&amp;r2); if(get(l1,r1) == get(l2,r2)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing240-UnionFind]]></title>
    <url>%2F2020%2F02%2F22%2FAcWing240-UnionFind%2F</url>
    <content type="text"><![CDATA[一个稍微复杂一点的并查集模型摸了两天，今天是第十八天，争取一周能有五篇吧 题目 输入输出 分析思路我们可以用一个并查集的思路来做这道题不管是不是同类我们都放到一个集合里面或者说是放到一个子树里面我们可以设置距离根节点距离为1的点为吃掉根节点的，距离为2的点为被根节点吃的，距离为0的点(即模3余0)判断思路1.如果x,y均大于n，说明是假话2.A.当t == 1的时候，如果x和y的祖宗节点px,py相同的话，那么说明x和y在同一个集合里面，这个时候就判断x到根节点的距离d[x]和y到根节点的距离d[y]的关系，因为如果只有x和y到根节点距离相等的时候表示x和y是同类,那么距离不等的时候就不是同类，即(d[x] - d[y]) %3 != 0的时候表示距离不等，为假B.当t == 1的时候，如果x和y的祖宗节点px,py不相同的话，那么说明x和y不在同一个集合里面，那么这个时候就令x的祖宗结点px指向y的祖宗结点py这个时候px到根节点的距离需要计算令px指向py，(d[x] + ？)%3 = d[y] % 3则？ = d[y] - d[x] ，？ = d[px];即d[px] = d[y] - d[x];下面代码里有更形象的解释3.当t == 2的时候A.当x和y的祖宗结点相同的时候即px == py时，说明x和y在同一个集合里面如果x比y的距离多1,即(d[x] - d[y]-1)%3 == 0，说明他俩就是x吃y，否则不是下面代码里有更形象的解释B.当x和y的祖宗结点不相同的时候即px != py时，说明x和y不在同一个集合里面，这个时候就令x的祖宗节点指向y的祖宗节点，因为x吃y所以(d[x] + d[px]) % 3 == (d[y] + 1) % 312345678910因为是x吃y，那么x到根节点的距离比y要多1 因为距离根节点为1的点是吃根节点的，距离为2的点是被根节点吃的 ----------------- | | v | | | 0-----&gt;1-------&gt;2 比如0是根节点，1是吃根节点的距离为1,2是被根节点吃的距离为2 那么2吃1的话即2到根节点的距离要比1到根节点的距离多1 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;using namespace std;const int N = 50010;int n,m;int p[N],d[N];//d[i]表示到父节点的距离，只不过find之后才会变成到祖宗节点的距离int find(int x)&#123; if(p[x] != x)//如果x不是树根的话 &#123; int t = find(p[x]);//先找到根节点，并存起来 //p[x] = find(p[x]); d[x] += d[p[x]];//d[x]就是点x到点p[x]之间的距离，而d[p[x]]就是点p[x]到根节点的距离 p[x] = t; &#125; return p[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) p[i] = i; int res = 0; while(m--) &#123; int t,x,y; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x &gt; n|| y &gt; n) res++; else &#123; int px = find(x),py = find(y); if(t == 1) &#123; //如果x和y在同一个根节点上，但是x到根节点的距离和y到根节点距离模3不相同，说明x和y不是同类 //因为如果是同类的话到根节点的距离模3应该相同 if(px == py &amp;&amp;(d[x] - d[y]) %3 != 0) res++; else if(px != py)//如果x和y不在同一个根节点上 &#123; p[px] = py;//令x的根节点指向y的根节点，即px----&gt;py d[px] = d[y] - d[x];//那么px到根节点的距离就是如下所示 /* d[x] x-----px | |？ V y-----py d[y] 令px指向py，(d[x] + ?)%3 = d[y] % 3 则? = d[y] - d[x] ，？ = d[px]; 即d[px] = d[y] - d[x]; */ &#125; &#125; else//如果t == 2 &#123; //x吃y，那么x到根节点的距离比y要多1 //因为距离根节点为1的点是吃根节点的，距离为2的点是被根节点吃的 /* ----------------- | | v | | | 0-----&gt;1-------&gt;2 比如0是根节点，1是吃根节点的距离为1,2是被根节点吃的距离为2 那么2吃1的话即2到根节点的距离要比1到根节点的距离多1 */ if(px == py &amp;&amp; (d[x] - d[y]-1)%3 != 0)//x和y在同一个集合里面 &#123; //如果x比y的距离多1,即(d[x] - d[y]-1)%3 == 0 //说明他俩就是x吃y，否则不是 res++; &#125; else if(px != py)//x和y不在一个集合里面 &#123; p[px] = py;//令x的祖宗节点指向y的祖宗节点 d[px] = d[y] + 1 - d[x]; //因为x吃y所以(d[x] + d[px]) % 3 == (d[y] + 1) % 3 /* d[x] x-----px | |d[px] V y-----py d[y] */ &#125; &#125; &#125; &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-154-SlidingWindow]]></title>
    <url>%2F2020%2F02%2F19%2FAcWing-154-SlidingWindow%2F</url>
    <content type="text"><![CDATA[AcWing154.滑动窗口第十五天！今天开始单推AKi！！！！！！！！ 题目 样例 输入输出 分析思路这题应该用单调队列的思路去解决问题1.如果用暴力方法来维护的话每次需要遍历一遍队列然后去找到最大值和最小值每次把一个数插入队尾然后再删除队头时间复杂度为O(NK)挪动N次，扫描K次 2.如何去优化？比如当前队列里面3,-1,-3只要-1在，-3一定在，那么一定不会用到-1，所以我们就可以把这个元素删掉所以在队列里面，如果后面有一个元素比当前这个元素小的话，就可以把当前这个元素删掉了所以删掉一定不会用到的元素后，那么队列里面应该变成从小到大的元素了因为如果如果后面一个元素比当前元素小，就会删掉当前这个元素所以最大值和最小值就不用再继续遍历了，可以直接从队头/队尾取出最值，时间复杂度为O(1)同理求最大值的方法对称再来一遍就行了 注意点1.单调队列应该存放数组的下标，这样可以方便我们去判断队头是否滑出了窗口2.至少扫描了K个数之后再进行输出即i &gt;= k-1,表示扫描了0到k-1这k个数之后再输出队头元素 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;const int N = 1000010;int n,k,a[N],st[N];int hh = 0,tt = -1;//hh为队头,tt为队尾int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); //找到窗口中的最小值 for(int i = 0;i &lt; n;i++) &#123; //判断队头是否还在窗口内 //如果队头小于队尾，且滑动窗口超过了最左边的队头，那么hh就右移 if(hh &lt;= tt &amp; i - k + 1 &gt; st[hh]) hh++; //如果队尾的值大于a[i]，即队尾的元素大于后面那个元素，这个时候就把队尾大的元素出队 //直到队列里面都是比后面元素a[i]小的时候停止 while(hh &lt;= tt &amp;&amp; a[st[tt]] &gt;= a[i]) tt--; //这个时候再把a[i]的下标加入队列中，加入下标到队列中的好处是可以判断是否超过边界 st[++tt] = i; //最小值一定是在队头的位置 if(i - k + 1 &gt;= 0)//当至少扫描了K个数之后输出 printf("%d ",a[st[hh]]); &#125; cout&lt;&lt;endl; hh = 0,tt = -1; //找到窗口中的最大值 for(int i = 0;i &lt; n;i++) &#123; if(hh &lt;= tt &amp; i - k + 1 &gt; st[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[st[tt]] &lt;= a[i]) tt--; st[++tt] = i; if(i - k + 1 &gt;= 0) printf("%d ",a[st[hh]]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>SlidingWindow</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[intervaldp-qujiandp]]></title>
    <url>%2F2020%2F02%2F16%2Fintervaldp-qujiandp%2F</url>
    <content type="text"><![CDATA[一个需要思考的区间dp问题第十四天desu！ 题目 输入输出 分析题目提取模型分析题目我们可以知道密码是由A、B、C、D四个回文子串串成的一个序列但是因为年代久远，A、B、C、D中有的密码脱落了所以它组成的这个序列就不是回文子串了我们需要找到当初最少添加多少个字母才能重新组成一个回文子串———&gt;添加n个字母组成回文子串,意味着原序列S里面也有n个字母没有对应的字母———&gt;继续转化,即转化为原序列S中删除n个字母可以形成回文串比如ABCDCBA,原本需要加一个D形成回文子串,我们可以转化为减去一个D形成ABCCBA回文子串———&gt;所以我们需要找到原序列S中的最长回文子序列即ABCDCBA里面的”ABC_CBA”回文子序列可以不连续 用dp的思想去解决问题显然，这题可以用区间dp的思路去解决问题状态用f[L,R]表示所有S[L,R]之间回文子串集合长度的最大值我们可以从f[L,R]来分解为四个部分1.如果S[L] == S[R]即区间[L,R]的两个端点相等的话那么f[L,R] = f[L+1,R-1] + 2;即等于去除这两个端点里面子序列的值加上22.如果S[L] != S[R]那么可以继续分情况讨论A.如果S[L]这个端点不在回文子序列里面B.如果S[R]这个端点不在回文子序列里面C.如果S[L]和S[R]都不在回文子序列里面然后f[L,R]对上述三种情况取一个max即可，虽然这三种情况有重复的部分，但是不影响我们取最大值，且C这种情况可以包含到AB两种情况中去那么f[L,R] = max(f[L+1,R],f[L,R-1]); 注意点1.我们这题应该从长度为1来开始进行枚举比如ABCBAC,A、B、C、B、A、C对应的f[L][R] = 1,即L == R的时候然后依次AB、BC、CB、BA、AC依次进行枚举这样子长度从小到大进行枚举，从而保证不漏2.我们求出的是最长回文子序列的长度f[0][n-1]，还要用n减去f[0][n-1]从而得到要删去字母的个数，同时也是题目要求添加字母形成回文串的个数 代码如下：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1010;int f[N][N];//f[L][R]表示区间[L,R]之间的所有回文子序列集合长度的最大值， //最后f[0][n-1]对应的就是最大回文子序列的长度，n - f[0][n-1]即为脱落的种子数//注意，最大回文子序列和最大回文子串不同，最大回文子序列可以不连续而最大回文子串需要连续string str;int main()&#123; cin&gt;&gt;str; int len = str.size(); for(int i = 1;i &lt;= len;i++) &#123; for(int l = 0;l + i -1 &lt; len;l++ ) &#123; int r = l + i - 1; if(l == r) &#123; f[l][r] = 1; continue; &#125; if(str[l] == str[r]) f[l][r] = f[l+1][r-1] + 2; else f[l][r] = max(f[l+1][r],f[l][r-1]); &#125; &#125; cout&lt;&lt;len - f[0][len-1]; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SumOfCountInversions]]></title>
    <url>%2F2020%2F02%2F14%2FSumOfCountInversions%2F</url>
    <content type="text"><![CDATA[逆序对的数量 第十三天,加油！ 逆序对的定义对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对。重要的地方在于，一个元素可以不只是在一个逆序对中存在。如果 k &gt; j &gt; i 且 a[i] &gt; a[j] &gt; a[k]，那么这里有两个逆序对，分别是 (a[i], a[j]) 和 (a[i], a[k]), a[i]是可以使用多次的。 题目 输入输出 思路这道题可以用分治的思路解决，因为我们观察可知如果把一个数组一分为二，那么有三种情况1.两个数都在左边2.两个数都在右边3.两个数一个在左边一个在右边 假设数组的左右两边都已经按顺序排序好了我们这个时候就要考虑第三种情况假设数组为4,5,6,8,12,1,2,3,7,8这个时候我们枚举左边进行排序比如4比1大，那么4右边一直到中间的数一定也都比1大这个时候我们直接令res = mid - i + 1即为1对应的逆序对然后依次类推 为什么要排序？如上图所示，当进行排序过后方便我们进行计算以上面的数组为例归并排序最后分组8 | 5 | 12| 4| 6 | 8| 2 | 3 | 7 | 1 | 当一半一半的递归下去进行分组的时候8 和 5分到了左右两边这个时候第一种情况和第二种情况为0考虑第三种情况因为8比5大所以res += 1然后把8和5进行排序成5和8依次类推再合并进行5,8|4,6,12然后再合并左右两边，从而得到最终的结果 为什么这样排序不会改变逆序对数量？我个人的理解是左边的逆序对和右边的逆序对分别单独计算不会改变既在左边也在右边的逆序对，把左右的逆序对数目统计了之后就可以分别排序然后再计算第三种情况的逆序对数目 总之，这题就是在归并排序里面加一个计算逆序对的思想 注意点1.这题的数据会爆int，所以要转化成long long的形式记录数据2.当l == r的表示[l,r]区间只有一个数，返回0 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 100000 + 10;int a[N],tmp[N];int n;LL merge_reverse(int l,int r)&#123; if(l == r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_reverse(l,mid)+merge_reverse(mid+1,r); int i = l,j = mid + 1,k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) &#123; if(a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; tmp[k++] = a[j++]; res += mid - i + 1; &#125; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for(int i = 0;i &lt; k;i++) a[l+i] = tmp[i]; return res; &#125;int main()&#123; cin&gt;&gt;n; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); cout&lt;&lt;merge_reverse(0,n-1); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[difference_chafen]]></title>
    <url>%2F2020%2F02%2F13%2Fdifference-chafen%2F</url>
    <content type="text"><![CDATA[差分模板 Day12,struggling! 差分的意义对于一维数组A[i],在[l,r]区间上使得每一个数同时加上一个C这个操作需要O(n)的时间复杂度而差分可以让我们从O(n)的时间复杂度降低到O(1)的复杂度 一维差分操作原数组a[N]存放每个数,b[N]为差分数组使得b[1] = a[1];b[2] = a[2] - a[1];b[3] = a[3] - a[2];…b[N] = a[N] - a[N-1]; 从而b[1] + b[2] + b[3] + … + b[i] = a[i];即b[N]数组的前缀和为a[i] 思路对于一个区间[l,r]上，我们想要让a[l]到a[r]所有数都加上C那么我们可以使b[l] += C,b[r+1] -= C;因为b[l] += C意味着求前缀和的时候在区间[l,N]的所有数都加上了一个Cb[r+1] -= C意味着求前缀和的时候在区间[r+1,N]的所有数都减去了一个C这样使得求前缀和的时候得到a的时候[l,r]区间都加上了一个C因为只要b[l] += C之后，最后求前缀和的时候l之后r之前的对应的a都会加到b[l]即a[i] = b[1] + b[2] + … + b[l] + … + b[i] 同理如果i在l之前的区间则不会加到b[l]，如果在r之后的区间也会加到b[r+1]，加C减C抵消 一维差分的例题题目 输入输出 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100000 + 10;int a[N],b[N];int n,m;int l,r,c;void insert(int l,int r,int c)&#123; b[l] += c; b[r+1]-=c;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a[i]); insert(i,i,a[i]); &#125; while(m--) &#123; scanf("%d %d %d",&amp;l,&amp;r,&amp;c); insert(l,r,c); &#125; for(int i = 1;i &lt;= n;i++) &#123; b[i]+=b[i-1]; &#125; for(int i = 1;i &lt;= n;i++) &#123; printf("%d ",b[i]); &#125; return 0;&#125; 注意点我们在进行插入操作的时候可以把a[N]看成一个全为0的数组然后在区间(i,i)的地方一个一个插入a[i]. 二维差分思路二维差分就是把一维差分的操作扩展到了二维 即二维数组a[i][j]存储每个数b[i][j]存储差分和计算b[i][j]的二维前缀和求出a[i][j] 关键对于矩阵(x1,y1),(x2,y2)这一块区域如果要同时加上C对应的操作为b[x1][y1] += C;b[x2+1][y1] -= C;b[x1][y2+1] -= C;b[x2+1][y2+1] += C; 注意图里面虽然是紧挨着的，但是计算机里面是对应一个一个坐标所以我们要从(x2+1,y1)和(x1,y2+1)开始 题目 输入输出 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000 + 10;int a[N][N],b[N][N];int n,m,q;void insert(int x1,int y1,int x2,int y2,int c)&#123; b[x1][y1] += c;//相当于(x1,y1)到右下角的区域全部加了c b[x2+1][y1] -=c;//相当于(x2+1,y1)到右下角的区域全部减去c b[x1][y2+1] -=c;//相当于(x1,y2+1)到右下角的区域全部减去c b[x2+1][y2+1] += c;//相当于(x2+1,y2+1)到右下角的区域全部加了c&#125;int main()&#123; scanf("%d %d %d",&amp;n,&amp;m,&amp;q); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; scanf("%d",&amp;a[i][j]); insert(i,j,i,j,a[i][j]); /*等价写法 b[i][j] = a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; 因为a[i][j]是b[i][j]的前缀和，那么a[i][j] = b[i-1][j] b[i][j]的前缀和数组为S[i][j] S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + b[i][j]; 因为a就是b的前缀和数组，所以S可以转换为a 那么a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + b[i][j]; 即b[i][j] = a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; */ &#125; int x1,y1,x2,y2,c; while(q--) &#123; scanf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c); insert(x1,y1,x2,y2,c); &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; printf("%d ",b[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 注意点同一维差分，我们在进行插入操作的时候相当于在区域[(i,j)(i,j)]这个地方插入a[i][j]]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing1209-dfs]]></title>
    <url>%2F2020%2F02%2F11%2FAcWing1209-dfs%2F</url>
    <content type="text"><![CDATA[AcWing1209.带分数第十一天~ 题目 输入输出 分析思路n可以表示成n = a + b / c的形式且a、b、c组成的数字为1到9且只能出现一次那么a、b、c就是1到9组成的全排列然后再随机分配成3个数 思路1第一种思路就是枚举1到9的全排列然后把每次的排列隔两个板子分成3个数然后再判断是否符合n = a + b / c 时间复杂度9!*9(枚举全排列的时间复杂度为n!*n)*C(8,2)(即9个数之间插两块板子) = 91445760差不多九千多万的复杂度大致的思路即为1.枚举全排列2.枚举位数3.判断等式是否成立 注意点在把1到9的全排列用两个板子分成三段可以用一个calc函数来进行计算calc(i,j)表示对数组里面i到j位转换为对应的数，即123456789int calc(int l,int r)&#123; int re = 0; for(int i = l;i &lt;= r;i++) &#123; re = re*10 + num[i]; &#125; return re;&#125; 思路2第二种思路是在第一种思路上进行的优化因为n = a + b / c，那么即b = n*c - a*c我们只需要枚举a和c就可以求出b来再判断1.b里面是否有0或者a和c重复的数字2.最后判断1到9里面是否还有数字没用到过这样可以降低时间复杂度大致的思路就是1.枚举a2.在枚举a的基础上去枚举c3.根据a和c求出b，然后再去判断是否满足条件(枚举a的基础上去枚举c其实是一个嵌套的dfs) 注意点这里 b = n*c - a*c中c可能有8位然后和n最大6位相乘会爆int，需要转化成long long 进行计算 思路1对应的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 10;int num[N];//num数组存放每次全排列的结果int used[N] = &#123;false&#125;;//定义一个数组来判断全排列的时候哪些数用过哪些数没用过int res = 0,n;int calc(int l,int r)&#123; int re = 0; for(int i = l;i &lt;= r;i++) &#123; re = re*10 + num[i]; &#125; return re;&#125;void dfs(int u)&#123; if(u == 9) &#123; for(int i = 0;i &lt; 7;i++) for(int j = i+1;j &lt; 8;j++) &#123; int a = calc(0,i); int b = calc(i+1,j); int c = calc(j+1,8); if(a &gt; n) continue; if(b == n*c - a*c) res++; &#125; return ; &#125; for(int i = 1;i &lt;= 9;i++) &#123; if(!used[i]) &#123; used[i] = true; num[u] = i; dfs(u+1); used[i] = false; num[u] = 0; &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; dfs(0); cout&lt;&lt;res; return 0;&#125; 思路2对应的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 10;int n;bool st[N], backup[N];int ans;bool check(int a, int c)&#123; LL b = n * (LL)c - a * c; if (!a || !b || !c) return false; memcpy(backup, st, sizeof st); while (b) &#123; int x = b % 10; // 取个位 b /= 10; // 个位删掉 if (!x || backup[x]) return false; backup[x] = true; &#125; for (int i = 1; i &lt;= 9; i ++ ) if (!backup[i]) return false; return true;&#125;void dfs_c(int u, int a, int c)&#123; if (check(a, c)) ans ++ ; for (int i = 1; i &lt;= 9; i ++ ) if (!st[i]) &#123; st[i] = true; dfs_c(u + 1, a, c * 10 + i); st[i] = false; &#125;&#125;void dfs_a(int u, int a)&#123; if (a &gt;= n) return; if (a) dfs_c(u, a, 0); for (int i = 1; i &lt;= 9; i ++ ) if (!st[i]) &#123; st[i] = true; dfs_a(u + 1, a * 10 + i); st[i] = false; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs_a(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing93-dfsCombination]]></title>
    <url>%2F2020%2F02%2F10%2FAcWing93-dfsCombination%2F</url>
    <content type="text"><![CDATA[一个简单的递归实现的枚举问题 第十天，好好总结之前学过的东西！明天得开始好好按计划执行了 题目 输入输出 分析思路这题是要我们从1到n这n个整数里面随机选出m个数且按照从小到大进行输出 举例假设我们从1到5这5个数里面随机选出3个来我们可以从三个位置来进行分析如果所示我们第一个位置选1之后，那么第二个位置只能从2到5进行选择所以我们dfs函数的参数应该这样考虑1.因为要枚举每个位置，用一个数组way[N]来记录每个位置放什么数2.要用一个参数来判断枚举到哪个位置，用一个变量u来表示当前枚举到第几个位置3.因为枚举完一个数到一个位置之后，后面的数只能比已经枚举的数要大，所以要用一个变量start来表示当前最小可以从start开始枚举4.排列性枚举里面需要判重数组，因为他不知道哪个数有没有用过，但是组合枚举就不需要这个判重数组了 代码如下1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 26;int n,m;//n表示1到n个数，m表示从n个数中随机选取m个int way[N];//定义一个数组来存放每个位置对应的数void dfs(int u,int start)//u表示当前数组枚举在第几个位置,start表示可以从start向后选&#123; if(u == m+1) &#123; for(int i = 1;i &lt;= m;i++) cout&lt;&lt;way[i]&lt;&lt;" "; cout&lt;&lt;endl; return ; &#125; for(int i = start;i &lt;= n;i++) &#123; way[u] = i; dfs(u+1,i+1); way[u] = 0; &#125; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,1); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EulerSieve]]></title>
    <url>%2F2020%2F02%2F09%2FEulerSieve%2F</url>
    <content type="text"><![CDATA[欧拉筛模板 Day 9! 12345678910111213141516171819202122int primes[N], cnt;int minp[N];bool st[N];void get_primes(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) &#123; minp[i] = i; primes[cnt ++ ] = i; &#125; for (int j = 0; primes[j] * i &lt;= n; j ++ ) &#123; int t = primes[j] * i; st[t] = true; minp[t] = primes[j]; if (i % primes[j] == 0) break; &#125; &#125;&#125; st[i] == 0表示没有被筛过,1表示被筛过否则从小到大枚举质数，然后把质数的i倍都筛掉1.我们筛掉的一定是合数，primes[j]一定不大于i的最小质因子，故一定是用最小质因子筛除的 2.合数一定会被筛掉，因为合数一定包含一个最小质因子设数N的最小质因子为pN = p * N/p则当i枚举到N/p的时候,因为p是最小质因子一定在primes数组里面会被枚举到t = N/p * p = N即合数N一定会被筛掉 核心本题的核心在于if (i % primes[j] == 0) break;这句话上当 i是prime[j]的倍数时，i = kprime[j]，如果继续运算 j+1，i * prime[j+1] = prime[j] * k prime[j+1]，这里prime[j]是最小的素因子，当i = k * prime[j+1]时会重复，所以才跳出循环。 举例假设2, 3, 4, 5, 6, … 12 请问12在什么时候被筛去的呢？ 按上述解释以及程序计算，在i == 4时，质数表中已有2, 3，可以4 * 3 == 12. 后续 i == 6时， 质数表2, 3, 5，也可以 6 * 2 == 12 筛去12. 跟着程序算一次便知，i == 4时只筛去了8，为何不筛去12，因为12的最小质因数为2，由4 mod 2 == 0也可以看出4不是最小质因数，与2配对的因数6将在后面筛去12，这样才是用最小质因数去筛。 而线性的证明，只需由上述例子中看出每个被筛去的数都是唯一的由 最小质因数（其实也就是最小正因数，易证）配对的因数（相应的最大因数）筛去，每个数只被筛去一次，故为O(n)。]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SegmentTree]]></title>
    <url>%2F2020%2F02%2F08%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[线段树 第八天！加油啊！！！！奥利给！ 线段树的两个功能1.单点修改，时间复杂度为O(logn)2.区间查询，时间复杂度为O(logn) 四个基本操作1.pushup: 用子节点的信息更新当前结点信息2.build: 在一段区间上初始化线段树3.modify: (单点)修改4.query: 查询操作 根据具体例子来写一个线段树同上次用树状数组的那题，这次用线段树进行求解 题目 输入输出 线段树会存到一个一维数组里面其中下标为x的结点 父节点为x/2 或 x &gt;&gt; 1 左儿子是2x 或 x &lt;&lt; 1 右儿子是2x+1或 x &lt;&lt; 1|1 因为线段树是一棵树，所以一开始第一层会有n个点然后第二层有n/2个点，第三层有n/4个点依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数所以最后一层最多有2n个n + n/2 + n/4 + …+ 1 + 2n &lt; 4n 所以结点个数小于4n我们设置的数组大小应为4*N我们用一个结构体数组来存放各个结点的信息1234struct Node&#123; int l,r; int sum;&#125;tr[4*N];其中l,r代表当前结点的左右边界,sum为当前结点左右边界里面所有数的和 具体的四个基本操作pushup操作pushup是把子节点的信息更新到父节点这里的题就对应着把子节点的值更新以后，向上更新到父节点1234void pushup(int u)&#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1|1].sum;&#125; build操作我们这里设置一个函数build(u,l,r)表示把(l,r)这一段的数初始化为线段树其中u一般为根节点,l,r一般为我们要初始化成线段树的数组的边界1234567891011void build(int u,int l,int r)//u为当前结点边界,l,r为左右边界&#123; if(l == r) tr[u] = &#123;l,r,w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid+1,r); pushup(u);//把信息往上传递 &#125;&#125; 我们设置mid = l + r &gt;&gt; 1然后u的左儿子对应的就是build(u &lt;&lt; 1,l,mid)右儿子对应的就是build(u &lt;&lt; 1|1,mid+1,r) 需要注意的点当l == r的时候表示到达了根节点，这个时候直接赋值同时在进行每个操作的时候同样要进行初始化即tr[u] = {l, r};表示进入这个函数后u结点对应的边界为l到r query操作在这个题目里面query操作对应的就是计算区间和了我们定义query(u,l,r)为计算区间(l,r)的区间和，其中u一般为根节点开始12345678910111213int query(int u,int l,int r)&#123; //如果结点u对应的边界l1,r1在区间l到r之间，直接返回sum if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; //否则计算u对应边界的中点 int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; //如果l小于u对应的中点，说明需要到u的左儿子里面继续寻找 if(l &lt;= mid) sum += query(u &lt;&lt; 1,l,r); //同理如果r大于u对应的中点，说明需要到u的右儿子里面继续寻找 if(r &gt; mid)sum += query(u &lt;&lt; 1|1,l,r); return sum;&#125; modify操作在本题里面modify为修改某个点对应的值我们定义modify(u,x,v)为修改下标为x对应的值要加上v，u一般从根节点开始1234567891011void modify(int u,int x,int v)&#123; if(tr[u].l == tr[u].r) tr[u].sum += v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1,x,v); else modify(u &lt;&lt; 1|1,x,v); pushup(u); &#125;&#125;本人的理解就是有点二分查找的意思，u从根节点开始假设一个数组下标为1,2,3,4,5,6,7，我们要修改下标为5的数那么根节点u边界为1到7mid = 1 + 7 &gt;&gt; 1 = 4 &lt; 5这个时候就要从5到7去找，即u的右儿子继续寻找mid = 5 + 7 &gt;&gt; 1 = 6 &gt; 5这个时候就找5到6，即u的左儿子继续寻找然后mid = 5 + 6 &gt;&gt; 1 = 55 == 5这个时候即为根节点，修改对应的值后再pushup(u)更新结点 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;//线段树//对应的操作//pushup: 用子节点的信息更新父节点//build: 在一段区间上初始化线段树//modify: 单点修改或者修改操作//query: 查询操作/*假设第一层有n个点，那么第二层有n/2个点，第三层有n/4个点 依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数 所以最后一层最多有2n个 n + n/2 + n/4 + ...+ 1 + 2n &lt; 4n 所以结点个数小于4n 线段树存到一个一维数组里面 下标为x的结点 父节点为x/2 或 x &gt;&gt; 1 左儿子是2x 或 x &lt;&lt; 1 右儿子是2x+1或 x &lt;&lt; 1|1*/const int N = 100010;int n,m;int w[N];struct Node&#123; int l,r; int sum;&#125;tr[4*N];void pushup(int u)&#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1|1].sum;&#125;void build(int u,int l,int r)//u为当前结点边界,l,r为左右边界&#123; if(l == r) tr[u] = &#123;l,r,w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid+1,r); pushup(u);//把信息往上传递 &#125;&#125;int query(int u,int l,int r)&#123; if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; if(l &lt;= mid) sum += query(u &lt;&lt; 1,l,r); if(r &gt; mid)sum += query(u &lt;&lt; 1|1,l,r); return sum;&#125;void modify(int u,int x,int v)&#123; if(tr[u].l == tr[u].r) tr[u].sum += v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1,x,v); else modify(u &lt;&lt; 1|1,x,v); pushup(u); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;w[i]); build(1,1,n); int k,a,b; while(m--) &#123; scanf("%d%d%d",&amp;k,&amp;a,&amp;b); if(k == 0) printf("%d\n",query(1,a,b)); else modify(1,a,b); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinaryIndexedTree]]></title>
    <url>%2F2020%2F02%2F06%2FBinaryIndexedTree%2F</url>
    <content type="text"><![CDATA[树状数组及其模板题第七天！777777777 从求区间和的问题来进行深入思考对于这种求区间和的问题，一般我们都是通过一个前缀和数组计算S[n]-S[m-1]从而求得区间[m,n]的和但是，如果我们中途要随时给第x个整数加上某一个数v那么我们需要重新更新前缀和数组S，时间复杂度为O(n)如果进行K次这样的操作那么时间复杂度为O(Kn)我们难以接受 于是我们就要想一个办法来解决这个问题降低时间复杂度 于是我们就应用树状数组来解决问题 树状数组的两个应用1.给区间中的某个位置加上一个数2.求前缀和从而方便得到区间和 树状数组仍然是一个数组C[N]，只不过它存的不是从1到N的前缀和而是从区间(x-2^k,x]即C[x] = (x-2^k,x]其中k表示当前下标x对应的数在第k层 举例设有原数组A[N],树状数组C[N]其中对于奇数来说C[1] = A[1]C[3] = A[3]C[5] = A[5]C[7] = A[7]C[9] = A[9]C[11] = A[11]C[13] = A[13]C[15] = A[15] 对于偶数来说第一种C[2] = A[1] + A[2]C[6] = A[5] + A[6]C[10] = A[9] + A[10]C[14] = A[13] + A[14] 第二种C[4] = A[4] + C[3] + C[2] = A[1] + A[2]+ A[3]+A[4]C[8] = A[8] + A[7] + C[6] + C[4] = A[1]+ … + A[8]….C[16] = A[1] + … + A[16] 不难看出，如果把x转换为二进制表示C[x]就表示区间(x-2^k,x]这个前开后闭区间的和其中k表示二进制后面有多少个0对应到我们样例中就是第几层到当前下标x对应层的和 lowbit运算我们定义lowbit(x) = x &amp; -x拿x = 844来举例x|——0000001101001100-x|—-1111110010110100x&amp;-x|-0000000000000100即844对应1后面有2个0lowbit(844) = 2^2 = 4(lowbit(x)也可以理解为能整除x的最大2的幂次) 于是我们可以把区间(x-2^k,x]转换为(x-lowbit(x),x] 最后求出树状数组C[N]即可进行更多的操作 AcWing 1264. 动态求连续区间和题目 输入输出 树状数组模板题 注意点1.lowbit运算 即x &amp; -x2.在下标为x的位置加上v 我们就需要更新树状数组C[i] 即把下标为x,x+lowbit(x),x+2*lowbit(x),…,的树状数组更新3.求前缀和因为C[x]表示区间(x-lowbit(x),x]这个里面的区间和我们只需从x开始从后往前加和直到i等于0为止比如12345res += C[x];y = x - lowbit[x];res += C[y]//而C[y]表示区间(y-lowbit(y),y]即区间一直往前延伸直到为0为止然后依次类推 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n,m,k;int a[N],tr[N];int lowbit(int x)//进行lowbit运算&#123; return x &amp; -x;&#125;void add(int x,int v)//add函数表示在下标为x的位置加v&#123; for(int i = x;i &lt;= n;i += lowbit(i)) tr[i] += v;&#125;int query(int x)//利用树状数组求前缀和&#123; int res = 0; for(int i = x;i &gt; 0;i -= lowbit(i)) &#123; res += tr[i]; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) add(i,a[i]);//生成树状数组 int a,b; //查找操作 while(m--) &#123; scanf("%d %d %d",&amp;k,&amp;a,&amp;b); if(k == 1) add(a,b); else printf("%d\n",query(b) - query(a-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quickSort]]></title>
    <url>%2F2020%2F02%2F05%2FquickSort%2F</url>
    <content type="text"><![CDATA[快速排序[模板]因为各种事情断了两天，就算是第六天吧！接下来还会一直坚持的 题目 输入输出样例 分析思路快速排序的思路,对于一个数列q[N]1.确定分界点 q[l]、q[r]或者是q[l + r &gt;&gt; 1]或者是l到r区间上的随机点值得注意的是如果数据范围很复杂最好不取两个端点而是取中间的点 2.调整区间使得最后调整的区间x点左边都小于等于xx点右边都大于等于x 3.递归处理左右两个区间 注意点1.如果是取区间的中点那么l + r &gt;&gt; 1有可能要改成l + r &gt;&gt; 1 防止出现死循环2.最后左右递归区间的时候要注意那个分界点对x取点的影响，防止出现死循环3.因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r) 反之则划分为(l,i-1),(i,r),这个时候对应的x的取值就要相应改变 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100000 + 10;int n;int f[N];void quick_sort(int num[],int l,int r)&#123; if(l &gt;= r) return ;//如果l&gt;=r则直接返回 int i = l-1,j = r+1; //这里i和j要从区间左右两端的外侧开始，因为后面是先i++,j--然后再进行判断 int x = num[(i + j) / 2]; //当区间划分为下面这种的时候 //quick_sort(num,l,i-1); //quick_sort(num,i,r); //int x = num[(i + j + 1) / 2]; x应该上取整才能防止死循环 while(i &lt; j) &#123; do i++; while(num[i] &lt; x); do j--; while(num[j] &gt; x); if(i &lt; j)swap(num[i],num[j]); &#125; //因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r) //反之则划分为(l,i-1),(i,r) quick_sort(num,l,j); quick_sort(num,j+1,r);&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;f[i]); quick_sort(f,1,n); for(int i = 1;i &lt;= n;i++) printf("%d ",f[i]); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing122-GreedyAlgorithm]]></title>
    <url>%2F2020%2F02%2F02%2FAcWing122-GreedyAlgorithm%2F</url>
    <content type="text"><![CDATA[一个稍微复杂的贪心问题 第五天了，我真的是一天都没有停下来呢。 题目 输入输出格式 分析思路n个小朋友围成一个环，然后每个人只能给左右两个人传递糖果且传递x个糖果消耗的代价为x 第一直觉肯定是糖果多的人怎么传给糖果少的人一时半会看不出来用什么方法可以解决问题，我们于是可以先建立一个数学模型 建立数学模型我们可以设n个小朋友现在手里的糖果数分别为A1,A2,A3 … ,An-1,An我们约定，从An传递到An-1为Xn个糖果数 其中,Xn为正表示糖果从An传递到An-1 反之如果为负，则表示从An-1传递到An 则依题意可知我们最终要求的就是|X1| + |X2| + |X3| + … + |Xn|的最小值 第二次做题的思路然后转化成求一个点到各个C[i]的距离之和最小，就是排序之后的C[i]数组的中点到各个C[i]点之差的和即为最小的距离之和 代码如下12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000000 +10;typedef long long LL;int A[N],C[N],S[N];//A[i]记录原数据,S[i]为A[i]的前缀和数组LL n,sum = 0,avg,res;int main()&#123; scanf("%lld",&amp;n); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;A[i]); sum += A[i]; S[i] = S[i-1]+A[i]; &#125; avg = sum / n; for(int i = 1;i &lt;= n;i++) &#123; C[i] = S[i-1]-avg*(i-1); &#125; sort(C+1,C+1+n); for(int i = 1;i &lt;= n;i++) &#123; res += abs(C[n/2]-C[i]); &#125; cout&lt;&lt;res; return 0;&#125; 第一次做题的思路那么，显而易见最后每个点的结果一定是Ā每个点起初都是Ai，结果都是Ā那么我们通过每个点可以得到n个关系式即A1 - X1 + X2 = ĀA2 - X2 + X3 = ĀA3 - X3 + X4 = Ā … An-1 - Xn-1 + Xn = ĀA1 - Xn + X1 = Ā 整理上式X1 - X2 = A1 - ĀX2 - X3 = A2 - Ā…Xn-2 - Xn-1 = An-2 - ĀXn-1 - Xn = An-1 - ĀXn - X1 = An - Ā 感觉跟差分数列差不多的样子于是我们从最后一项依次递加i项比如最后两项相加可以得到X2 = X1 - ((n-1)Ā - An - An-1 -…- A2)最后三项相加可以得到X3和X1的关系依次类推我们可以得到Xi与X1的一个线性关系从而我们可以把所有的Xi转换成X1+Ci继续进行求解 继续整理Xn = X1 - (Ā - An)Xn-1 = X1 - (2Ā - An - An-1)…X2 = X1 - ((n-1)Ā - An - An-1 -…- A2)X1 = X1 于是我们要求的|X1| + |X2| + |X3| + … + |Xn|可以转换成|X1 - C1| + |X1 - C2| + |X1 - C3| + … + |X1 - Cn| 即转换成在直线上求一点X使得X到C1,C2,C3,…,Cn的距离最小 其中C1 = Ā - AnC2 = 2Ā - An - An-1…Cn-1 = (n-1)Ā - An - An-1 -…- A2Cn = 0 可以发现其中的一个递推关系就是Cn - Cn-1 = Ā - An-1又C1 = Ā - An我们可以根据这个递推关系求出所有的Ci然后再对Ci从小到大排序找到Ci的中间的点就是使得它到其他Ci距离之和最小的点 注意点1.数列最好从1开始方便计算2.当数列从1开始的时候，中间点即为(n+1)/2，需要+13.数据可能爆int，所以要用long long 长整形表示结果 总结这题是AcWing 104. 货仓选址的一个进阶题目，或者说是区间选点加了一个套子难点在于我们在考试的时候如果遇到这种题很难静下心来去分析出题目的数学模型并进行进一步的整理所以需要我们多做题多总结模型才行啊（ 代码如下：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000000 +10;typedef long long LL;int A[N],C[N],S[N];//A[i]记录原数据LL n,sum = 0,avg;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;A[i]);//数据范围较大最好用scanf进行输入 sum += A[i];//计算所有糖果的和 &#125; avg = sum / n;//计算糖果的平均值 int k = 1; C[k] = avg - A[n];//初始化，C[1] = Ā - An for(int i = n;i &gt; 1;i--) &#123; C[k+1] = C[k] + avg - A[i-1];//根据Cn - Cn-1 = Ā - An-1递推关系来算出所有C[i]的值 k++; &#125; C[n] = 0; sort(C+1,C+n+1);//对各个点到原点的距离进行排序 LL res = 0; for(int i = 1;i &lt;= n;i++) &#123; res += abs(C[(n+1)/2] - C[i]);//找到中间的那个点再计算到其他个点的距离之和 &#125; cout&lt;&lt;res;//因为数据保证一定有解，所以我们直接输出res return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mergeSort]]></title>
    <url>%2F2020%2F02%2F01%2FmergeSort%2F</url>
    <content type="text"><![CDATA[归并排序模板今天是第四天！ 归并排序的三个要点1.确定分界点 mid = l + r &gt;&gt; 12.递归排序 然后分成左右两个部分继续递归3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余然后再赋值给原数组 *注意点merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return; 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100010;//归并排序的三个要点/*1.确定分界点 mid = l + r &gt;&gt; 12.递归排序 然后分成左右两个部分继续递归3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余 然后再赋值给原数组* 注意点 merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return;*/int q[N],tmp[N];//设一个额外的tmp数组来int n;void merge_sort(int q[],int l,int r)&#123; if(l &gt;= r) return ;//当区间里面的个数为1个或者没有的话就直接返回 int mid = l + r &gt;&gt; 1; merge_sort(q,l,mid); merge_sort(q,mid+1,r);//把原数组分成左右两边然后继续归并排序 int k = 0,x = l,y = mid+1;//k为tmp里面有几个数 while(x &lt;= mid &amp;&amp; y &lt;= r) &#123; if(q[x] &lt; q[y]) tmp[k++]= q[x++]; else tmp[k++] = q[y++]; &#125; while(x &lt;= mid) tmp[k++] = q[x++];//如果还有剩余的就存放进tmp数组里面 while(y &lt;= mid) tmp[k++] = q[y++]; for(int i = 0;i &lt; k;i++) q[l+i] = tmp[i];//把tmp数组里面的数重新赋值给原数组&#125;int main()&#123; cin&gt;&gt;n; for(int i = 0;i &lt; n;i++) scanf("%d",&amp;q[i]); merge_sort(q,0,n-1); for(int i = 0;i &lt; n;i++) printf("%d ",q[i]); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binarySort]]></title>
    <url>%2F2020%2F01%2F31%2FbinarySort%2F</url>
    <content type="text"><![CDATA[四个常用的二分模板第三天 二分查找的条件判断如果1 2 3 4 4 5 6 7我们如果想找到大于4的最小的那个数，即num[mid] &gt;= 4都得满足条件才行同理找小于4的最后一个数就是num[mid] &lt; 4，使得num[mid]所有的数都得满足小于4这个条件才行 代码如下12345678910111213141516171819202122232425262728293031323334353637383940int main()&#123; int num[9] = &#123;1,2,3,3,4,4,5,5,7&#125;;//测试数据 int L = 0,R = 8; int target = 5;//求小于等于target的最后一个数的下标 while(L &lt; R) &#123; int mid = L + R + 1 &gt;&gt; 1; if(num[mid] &lt;= target) L = mid; else R = mid - 1; &#125;//求大于等于target的第一个数的下标 while(L &lt; R) &#123; int mid = L + R &gt;&gt; 1; if(num[mid] &gt;= target) R = mid ; else L = mid + 1; &#125;//小于target的最后一个数的下标 while(L &lt; R) &#123; int mid = L + R + 1 &gt;&gt; 1; if(num[mid] &lt; target) L = mid ; else R = mid-1; &#125;//大于target的第一个数的下标 while(L &lt; R) &#123; int mid = L + R &gt;&gt; 1; if(num[mid] &gt; target) R = mid; else L = mid + 1; &#125; cout&lt;&lt;L; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个看起来很复杂的组合问题用dp求解]]></title>
    <url>%2F2020%2F01%2F31%2FAcWing1214-dp%2F</url>
    <content type="text"><![CDATA[AcWing1214. 波动数列Day3，striving 题目 输入输出样例 分析思路分析题目的大意一开始分析这道题咋一看是个序列模型，但其实是个组合模型因为可以肯定的是第一个数是不变的设为X那么数列即为X X+d1 X+d1+d2 X+d1+d2+d3 … X+d1+d2+…+dn-1其中di = {+a,-b}整理可得nx + (n-1)d1 + (n-2)d2 + … + dn-1 = S转换后 x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n 则当S和di确定的时候x是一定确定的任何一个满足要求的合法序列对应一个d1到dn-1的取值，反过来也成立这是一一对应的关系 即原序列不同的方案数，等于所有d1到dn-1合法的取值的方案数 转换题目转换为求所有满足要求的所有d1到dn-1所有取法的方案数那么满足的要求是什么？1.di为+a或者-b2.因为x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n 那么S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]即有多少种选法的d1到dn-1的取值代入序列之和对n的余数等于总和S对n的余数 用dp的思路去求解问题状态的表示这道题目就相当于一个组合问题，可以相当于背包问题来做分析状态应该用两维去表示f[i,j]状态对应的集合即为所有从前i个数(前i个di)，且当前总和(总和即表示代入[(n-1)d1 + (n-2)d2 + … + dn-1])除以n的余数的方案的集合属性应该为数量 状态计算f[i,j]考虑最后一步，抓住最后一个不同点最后一步有两种情况因为最后一步是+dn-1有可能是+a,也有可能是-b d1 + d2 + … di(+a)d1’+ d2’+ … di(+a)不管前面的di是多少,di都为+a所以可以所有先去掉这个最后这个di去掉之后就相当于只考虑前i-1项，然后代入(n-1)d1 + (n-2)d2 + … + dn-1但是为了方便我们变换成d1 + 2d2 + … + (n-1)dn-1 (一一对应)(不换也可以)假设前i-1项的原序列和为C则有C(mod n) + ia(mod n) == j(mod n)即 C(mod n) = (j - ia)(mod n)即f[i,j] = f[i-1,(j - ia)%n] 同理当di = -b时f[i,j] = f[i-1,(j + ib)%n] 注意点1.凡是问满足要求不同选法的数量或者最大值时，都可以用以上类似的背包问题的模型2.这题不能用dfs来做因为长度n为1000，dfs时间复杂度为2^1000，不予考虑3.这个题取模的时候有可能为负数那么需要把负余数转换为正余数所以需要写一个函数get_mod4.S的范围包含负数,所以最后不能直接写S%n，也应代入get_mod函数中5.初始化f[0][0] = 1，表示当一项都不选的时候方案数为1，一项都不选代入原序列和为0,0对n取模的余数也为0 结论最后把f[i][j]所有的方案数都求出来最后对应的f[n-1][get_mod(s,n)]即为结果因为S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]所以j = get_mod(s,n)时候对应的方案数为我们所求的结果因为对应的最后一项为dn-1所以i = n-1，表示前n-1项 代码如下：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int maxn = 1010,MOD =100000007; int n,s,a,b;int f[maxn][maxn];int get_mod(int x,int y)//因为x有可能为负数，那么我们取模的时候需要加上y再取模得到正余数&#123; return (x % y + y) % y;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; f[0][0] = 1;//初始化，当一项都不选的时候方案数为1 for(int i = 1;i &lt; n;i++) &#123; for(int j = 0;j &lt; n;j++) &#123; f[i][j]= (f[i-1][get_mod(j-a*i,n)] + f[i-1][get_mod(j+b*i,n)]) % MOD; &#125; &#125; cout&lt;&lt;f[n-1][get_mod(s, n)];//注意S也有可能为负数 return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由两个简单dp组合而成的复杂dp问题]]></title>
    <url>%2F2020%2F01%2F30%2FAcWing1212-dp%2F</url>
    <content type="text"><![CDATA[第二天，坚持。 题目 分析题目题目有两个限制1.只能往右或者往下走2.一定要按照递增的顺序取物品3.一共要恰好取K件 数据范围n和m都为50所以这个题的维度可能比较多 分析f里面一定要有两维i,j来存坐标如果还要存当前取的数的坐标那么就会有四维了这是一个不明智的行为但是我们发现所有数的大小很小，才0到12，有很强的限制所以不需要存最后一个数是哪个数，只需要存最后一个数是多少就行了还有一维就是存最后一个取的物品价值是多少即f[i,j,k,c]前两维表示坐标,k表示当前取多少件,c表示取最后一件的价值是多少 计算时间复杂度50*50*50*12*13 = 390000用最多的时间复杂度10^7/390000约等于25即状态转移的计算量(大概还可以再循环一次)所以大概是五重循环的样子，前四重是状态，还有一重是状态的转移 y氏dp分析法分析dp问题 分为四种情况两大类AB分析最后一步A最后一步从上往下走 B最后一步从左往右走然后A B两类又可以继续划分A：A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品B：B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品 考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的对应的C应该从之前已经选取k-1个物品中最大的价值C’，这个时候直接从0到V进行循环相加即可 对应的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;/*分为四种情况两大类AB分析最后一步A最后一步从上往下走 B最后一步从左往右走然后A B两类又可以继续划分A：A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品B：B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的对应的C应该从之前已经选取k-1个物品中最大的价值C`*/const int N = 51,MOD = 1000000007;int f[N][N][13][14];//f[i,j,k,c]int W[N][N];int n,m,k;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; cin&gt;&gt;W[i][j]; W[i][j]++;//所有物品的价值都+1 &#125; &#125; //初始化 f[1][1][1][W[1][1]] = 1; //取第一件物品 f[1][1][0][0] = 1; //不取第一件物品,这里初始化C为-1其实更好理解,因为C的范围是在0到12，也就是说有可能为0 //取-1表示没取第一件物品，所以C初始化为-1，后面所有的物品价值都会大于-1 //但是数组下标最好不取负数，所以把所有的物品价值W[i][j]都++，第一件不取C初始化为0 for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; if(i == 1 &amp;&amp; j == 1) continue;//已经初始化 for(int u = 0;u &lt;= k;u++)(u和v都是从0开始的) &#123; for(int v = 0;v &lt;= 13;v++) &#123; int &amp;val = f[i][j][u][v];//用一个val做别名免除很长的f[i][j][u][v] val = (val + f[i-1][j][u][v]) % MOD;//每加一次都需要取模 val = (val + f[i][j-1][u][v]) % MOD; if(u &gt; 0 &amp;&amp; v == W[i][j])&#123;//因为要取出一件来，所以u必须大于0(保证u-1大于0)，且只有当C对应的为W[i][j]时才能取出这一件来 for(int c = 0;c &lt; v;c++) &#123; val = (val + f[i-1][j][u-1][c]) % MOD;//因为MOD为1000000007，那么最多只能加两个数取模，否则有可能爆int val = (val + f[i][j-1][u-1][c]) % MOD; &#125; &#125; &#125; &#125; &#125; &#125; int res = 0; for(int i = 1;i &lt;= 13;i++) res = (res + f[n][m][k][i]) % MOD;//最后再把走到[n,m]取了k个数，价值从1到13(因为之前把W[i,j]都加了1)每个相加再取模得到最后的结果res cout&lt;&lt;res; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维前缀和]]></title>
    <url>%2F2020%2F01%2F29%2FAcWing796-TwoDimensionOfSum%2F</url>
    <content type="text"><![CDATA[二维前缀和 什么是前缀和？前缀和的定义:对于给定的数列A，它的前缀和数列S是通过递推来求出来的部分和即S[0] = A[0];S[1] = A[0] + A[1];S[2] = A[0] + A[1] + A[2];…S[n] = A[0] + A[1] + A[2] + … + A[n]; 这样做有什么好处？对于一个数列来说，我想求从下标m到n这一个区间的和如果不处理的话一个一个累加A[m] + A[m+1] + … + A[n]需要O(n)的复杂度我如果询问n次那么每次都要累加n次时间复杂度就是O(n^2) 很显然，如果每次询问的区间有重叠的话那我们每次都要累加多余的次数这个时候我们就要想办法去消除这种多余的步骤来降低我们的时间复杂度 于是我们可以提前预处理数组，取一个前缀和数组来存放数列的前缀这样，如果要求区间[m,n]的和的话值为S[n] - S[m-1]通过预处理把时间复杂度降到了O(1) (用前缀和数组存放也是一种空间来换时间的思想) 这便是一维前缀和的情况但是如果我们遇到了二维的情况应该怎么办呢？ 下面来用一个例题来为讲解二维前缀和 二维前缀和传送门 题目： 输入输出样例 从例题给的数据开始举例当前的二维数组(前缀和数组的下标统一从1开始)原数组A[i][j]表示存放原始数据二维前缀和数组S[i][j]表示从A[1][1]到A[i][j]这个矩阵的所有的和 怎么求二维前缀和数组？ 假设我想求[2,2]这个点的二维前缀和可以利用容斥原理即图中的两个黄色部分(黄色部分包括那个小的蓝色部分)中间那个蓝色部分被加了两次所以要减去最后剩下那个白色部分A[2,2]加上即得到了整个二维前缀和 用代码表示即s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; 计算了二维前缀和接下来就要计算子矩阵的和了假设我要计算从[x1,y1]到[x2,y2]这一部分的前缀和同样利用容斥原理大的矩形S[x2,y2]减去y1旁边的小矩形(黄色部分)s[x2,y1-1]减去x1旁边的小矩形(黄色部分)s[x1-1,y2]最小的那个部分减去了两次需要重新加回来s[x1-1,y1-1]即s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] 代码如下1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1010;int a[maxn][maxn],s[maxn][maxn];int n,m,q;int x1,y1,x2,y2;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; scanf("%d",&amp;a[i][j]); s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];//计算二维前缀和 &#125; &#125; while(q--) &#123; scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf("%d\n",s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]);//从二维前缀和计算子矩阵的和 &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记念自己的21岁。]]></title>
    <url>%2F2020%2F01%2F22%2F20200122%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认真你就输了]]></title>
    <url>%2F2019%2F12%2F25%2F2019-year-end-summary%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191216]]></title>
    <url>%2F2019%2F12%2F16%2F20191216%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191209]]></title>
    <url>%2F2019%2F12%2F09%2F20191209%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra]]></title>
    <url>%2F2019%2F11%2F30%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[浅谈Djikstra算法前言：前几天在算法笔记上看到了晴神对于最短路径算法Dijikstra的一个深入的分析，我感觉挺感兴趣的，顺便想借此机会来深入分析，顺带也是更新下博客了咳咳，顺带说一句我的博客看起来挺乱的，等有时间会做一个分类吧，但我不想把它变成单纯的一个技术博客，而是记录一个我的学习，生活，感悟，以及展示自己兴趣爱好的地方(虽然现在从哪方面看上去这人都挺low的) 好吧，那就开始我对Djikstra算法的认识吧 从最短路径算法Djikstra初谈什么是Djikstra? 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 这是百度百科上的定义，用我们生活中的例子来讲就相当于我们每天在地图上用的导航，导航可以帮我们在错综复杂的街道上，找到一条从出发地到达终点的最短路径 所以我们需要一个好的算法来干这事，而这种算法就叫做最短路算法(SSSP) 而其中Djikstra算法就是最短路算法中的一种(当然也是最简单的一种) 至于为什么叫Djikstra算法，因为Dijkstra算法是由一个叫Dijkstra的荷兰人发明的，故称此算法为Dijkstra算法。(怎么这么多废话) 好了，那现在进入正题 Dijkstra算法的工作原理？因为这个算法是为了求出来在一系列限制条件下两个地方的最短路径，那么我们一般怎么找到从一个地方到另外一个地方的最短路呢？ 对，我们首先得有一张地图才行啊 就拿我国庆去上海玩的经历来说吧 你现在刚从火车站出来搭地铁到人民广场这个下站了，天色已经很晚了，，但是你突然想走去黄浦江边的外滩去看风景 你可能要问，诶我为什么不继续坐地铁到那个南京东路下站然后再走去外滩啊，这样不是更近吗？(然鹅不幸的是国庆的前几天南京东站的晚上基本上都是被封的) 所以你只能选择走去外滩，当然你不可能像红色箭头这样飞过去了，不然警察叔叔会罚你 $10^{10} RMB的，所以你只能找到合适的道路走过去，也就是说你只能走那些标记为“路”的地方 于是我们就可以把每一个路口或建筑看作一个点，有些点与另一些点之间有边连接，这个边其实就是马路，连结了两个地方。 当然，有些马路的车流量比较大，有些在比较小；于是有的马路通过需要花费的时间多，有的花费的时间少。我们把一条马路通过所需要花费的时间，称作这条边的权值。所有的点和边连在一起，就成为了一个图。(没错如果你想直接从人民广场直接直接走到外滩几乎是不可能的，人流量可以把你窒息死) 图这种东西大概长这样： 一个圆就是一个点，圆上的数字是点的序号，绿色的线是边，边旁边的橙色数字是边的权值。之所以加上箭头，是因为我们假设所有马路都是单行线（双向车道改成两条单向车道不就好了）。 具体的Dijikstra算法的证明过程在这里不再给出，具体的过程可以自行百度好了(其实是我的证明水平还8太行) 但是djikstra算法不适用于有负边权的图，在这里不再赘述(才不会告诉你别人已经有更好的解释了啦) 戳这里 对我的理解来说，Djikstra算法最直观的一个解释就是以起点开始寻找有没有其他中介点能够使起点到达其他顶点的距离能够变小 Djikstra算法的一个伪代码12345678910111213141516bool vis[maxn] = &#123;false&#125;;void Djikstra(G, d[],s)&#123; 初始化 for(循环n次)&#123; u = 使d[u]最小的还未访问的顶点的标号 vis[u] = true;//记下u已被访问 for(从u出发能到达的所有顶点v)&#123; if(vis[v] == false &amp;&amp; 以u为中介点使s到达顶点v的最短距离d[v]更优) &#123; 优化d[v]; &#125; &#125; &#125;&#125; 其中G为邻接矩阵，s为起点 vis[i] == true时表示顶点Vi已被访问，vis[i] == false时表示顶点Vi还未访问 d[]表示起点s到达顶点Vi的最短距离，初始化时除了起点的d[s]赋为0，其余的顶点都赋予一个很大的数(比如INT_MAX或者自己赋一个很大的INF)(即相当于把除了起点与其他顶点的边权确认后，其余各个顶点之间的距离设为无穷大(即INF)，这样可以保证后来各个点的最短距离d[i]都是从起点s得来的) 举一个简单的例子拿一个简单的有向图来举例子吧 起点的d[s] = 0，其余点的d[i] = INF; 开始循环，起点1可以到达点3和点2先把vis[1] = true;下次就不再循环到起点1因为d[1] + weight[1][3] &lt; d[3]所以更新d[3]d[3] = d[1] + weight[1][3] = 3;同理d[1] + weight[1][2] &lt; d[2]所以更新d[2]d[2] = d[1] + weight[1][2] = 6; 继续循环，寻找d[i]中最小的点(即离起点最近的)再开始计算这时候d[3] = 3最小(因为d[1]已经被标记过了不再访问)此时就以点3为中介点，看起点以它为中介点到达另外点的距离能不能变短标记vis[3] = true;此时d[3] + weight[3][2] &lt; d[2]; 3 + 2 &lt; 6(即从1-&gt;3-&gt;2的距离比1-&gt;2的离更小)所以更新d[2] = d[3] + weight[3][2] = 5; 又以点3中介点可以到达点4d[3] + weight[3][4] &lt; d[4]; 3 + 3 &lt; INF此时更新d[4] = d[3] + weight[3][4] = 6; 同理以点3中介点可以到达点5d[3] + weight[3][5] &lt; d[5]; 3 + 4 &lt; INF此时更新d[5] = d[3] + weight[3][5] = 7; 此时还能访问的d[2] = 5,d[4] = 6,d[5] = 7,d[6] = INF;然后继续循环发现d[2]最小，于是再以2为中介点进行寻找vis[2] = true;d[2] + weight[2][4] &gt; d[4]; 5 + 5 &gt; 6此时不更新，由于2只能到达4所以结束循环 此时还能访问的d[4] = 6,d[5] = 7,d[6] = INF;于是以点4为中介点进行循环vis[4] = true;由于点4可以到达点5和点6d[4] + weight[4][5] &gt; d[5] 6 + 2 &gt; 7不更新，继续循环d[4] + weight[4][6] &lt; d[6] 6 + 3 &lt; INF所以d[6] = d[4] + weight[4][6] = 9;然后结束循环 此时还能访问的d[5] = 7,d[6] = 9;以点5为中介点进行循环vis[5] = true;由于点5可以到达点6d[5] + weight[5][6] &gt; d[6] 7 + 5 &gt; 9所以不更新，结束循环 此时还能访问的d[6] = 9;vis[6] = true;最后发现除了6自己以外其他点都已访问过，所以结束循环 最后的结果就是d[1] = 0d[2] = 5d[3] = 3d[4] = 6d[5] = 7d[6] = 9 至此算法结束。如果您人脑模拟出来跟上面的图示有不一致的地方建议您重新阅读本拙文。如果您还看不懂请戳这里。 具体实现的代码，以邻接矩阵作为举例这里是以PAT1003为举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;//最大的城市数//N表示一共有N座城市 M表示一共有M条道路 C1 C2分别表示起点和终点int N,M,C1,C2;bool vis[maxn] = &#123;false&#125;;//定义一个数组来判断城市是否被访问int G[maxn][maxn];//表示城市与城市之间的距离int pre[maxn];//存储前驱结点int d[maxn];//记录最短距离,d[u]表示从起点s到达顶点u的最短距离int weight[maxn];//每个点的权值int w[maxn];//记录起点到每个点的最大权值int num[maxn];//num[u]表示起点s到达顶点u的最短路径条数void dijkstra(int s)//s表示起点&#123; fill(d,d+N,INT_MAX);//把所有点的距离都抹掉 d[s] = 0;//把起点的最短距离设置为0 w[s] = weight[s];//起点开始的权值即为起点的权值 num[s] = 1; for(int i = 0;i &lt; N;i++)&#123; //循环n次 int u = -1,MIN = INT_MAX;//u设置为-1是为了方便当找不到可以连接的点时方便判断,MIN存放最小的d[u], for(int j = 0;j &lt; N;j++) &#123; //找到未访问顶点中d[]最小的顶点,因为从起点开始更新了后面的d[u],然后下次循环就要从这个点寻找能到达顶点中距离最小的那个点 if(d[j] &lt; MIN &amp;&amp; vis[j] == false) &#123; u = j;//找到跟起点相距最短的那个点 MIN = d[j];//更新最短的距离 &#125; &#125; if(u == -1) return ;//如果找不到小于INT_MAX的d[]，意味着剩下的顶点和起点s不连通 vis[u] = true;//标记为已访问 for(int v = 0;v &lt; N;v++) &#123; //如果u能到达v 且 v未访问 -&gt; 则以u为中介点到达v可以使d[v]更优 if(G[u][v] != 0 &amp;&amp; vis[v] == false ) &#123; //当以u为中介点的时候能使d[v]变小 if(d[u] + G[u][v] &lt; d[v] ) &#123; d[v] = d[u] + G[u][v];//覆盖d[v] w[v] = w[u] + weight[v];//更新w[v] num[v] = num[u];//覆盖num[v] &#125; else if(d[u] + G[u][v] == d[v])//找到一条相同长度的路径后 &#123; if(w[v] &lt; w[u] + weight[v])//如果这条路径的点权之和更大 &#123; w[v] = w[u] + weight[v];//更新 &#125; num[v] += num[u];//有相同路径长度,则相加num[u],因为当d[u] + G[u][v] &lt; d[v]时候已经算出一个num[v]是符合条件的 &#125; //那么当d[u] + G[u][v] == d[v]时之前d[u] + G[u][v] &lt; d[v]算的num[v]仍然符合条件,则继续加上现在相等时候的num[u] &#125; &#125; &#125;&#125; 分析算法的复杂度？从复杂度来看，主要是外层循环O(V)与内层循环(寻找最小的d[u]需要O(V)、枚举v需要O(V))产生的，总复杂度为O(V*(V+V)) = O(V^2). 但其实Djikstra算法是可以优化到O(nlogn + m)的级别的为什么？因为必须把每个点都标记为已访问(即vis[i] = true)，所以外层循环的O(V)时间是无法避免的但是寻找最小的d[u]的过程可以不必要一个一个重新循环去寻找最小的那个的d[u]可以通过堆优化来降低复杂度，最简单的做法就是直接用STL中的优先队列priority_queue(STL依赖症) 看了上面的代码你可能已经发现了一个问题，那就是如果题目除了最短路径还有其他的要求怎么办？比如PAT1003里面就要求找到从起点到终点的最短路径的条数以及最短路径的数目之和即最短的路径可能不止一条 于是有三种主要的方式来进行考察①新增边权，即以新增的边权花费为例cost[u][v]表示从u -&gt; v的花费，并增加一个数组c[]，令起点s到达顶点u的最少花费为c[u]同理初始化的时候c[s] = 0,其余均为INF这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和c[v]而当d[u] + G[u][v] == d[v]时且c[u] + cost[u][v] &lt; c[v]时更新c[v](即可以是s到v的最少花费更优时更新c[v]) 样例代码:12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; &#125; else if(d[u] + G[u][v] == d[v] &amp;&amp; c[v] &gt; c[u] + cost[u][v])&#123; c[v] = c[u] + cost[u][v]; &#125; &#125;&#125; ②新增点权，即以新增的点权代表城市能收集到的物资为例，用weight[u]表示城市u中的物资数目，并新增一个数组w[]，即从起点s到达顶点u可以收集到的最大的物资为w[u]，初始化的时候w[s] = weight[s],其余均为0，这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和w[v]而当d[u] + G[u][v] == d[v]时且w[u] + weight[u][v] &gt; w[v]时更新w[v](即可以使s到v的最大物资更优)代码与上面类似不再给出 ③求最短路径条数，只需要增加一个数组num[]，令从起点s到达顶点u的最短路径条数为num[u]，初始化时num[s]为1，其余num[u]均为0这样可以使当d[u] + G[u][v] &lt; d[v]使num[v]继承num[u]而当d[u] + G[u][v] == d[v]时将num[u]加到num[v]上 代码如下12345678910111213for(int v = 0;v &lt; n;v++)&#123; //如果v未访问 &amp;&amp; u能到达v if(vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if(d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; num[v] = num[u]; &#125; else if(d[u] + G[u][v] == d[v])&#123; num[v] += num[u]; &#125; &#125;&#125; 鉴于时间关系暂时就先总结这么多，Dijikstra算法其实能扩展的东西还有很多，比如如果题目要求具体的最短路径的话还要另外增加一个记录前驱结点的数组之类的东西，等以后有时间我再来补齐吧!]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191120]]></title>
    <url>%2F2019%2F11%2F20%2F20191120%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>每天一点小感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1032]]></title>
    <url>%2F2019%2F11%2F13%2FPAT-1032%2F</url>
    <content type="text"><![CDATA[1032 Sharing传送门 题目的大意就是: 给出两条链表,要你找出两条链表第一个相交点如果有相交点,给出相交点地址值,如果没有,返回-1 思路：1.给出两条链表，我把所有的结点都标记为false(或者0)，然后我标记第一条链表的所有点为ture(或者1)，我再从第二条链表开始遍历，如果遇到标记点为1就为相交点，如果没遇到就说明两条链表没有相交点 注意事项：1.这题应该用静态链表比较合适，用map容易超时2.再用静态链表的时候定义maxn一定要大一点,因为数组的index值也很大(比如11111,22222)，否则数组会越界，PAT会报错“段错误”3.最后输出的时候要用print(“%05d”)来输出，因为我是用int型来保存地址的嘛，所以在输入00002的时候他会保存为2，那么我在输出的时候就应该在前面补0才行4.静态链表的next结点不是指针 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;//PATA 1032 Sharing//题目大意：给出两条链表,求出两条链表的第一个共用结点const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125;node[maxn];int main()&#123; int s1,s2;//s1和s2分别为第一二条链表的首节点 int N;//N表示一共有N个结点 cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;N; int result = -1; int address,next; char data; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;address&gt;&gt;data&gt;&gt;next; node[address].data = data; node[address].next = next; &#125; for(int i = 0;i &lt; N;i++) &#123; node[i].flag = false; &#125; for(int p = s1;p != -1;) &#123; node[p].flag = true;//flag为true表明在第一条链表上 p = node[p].next; &#125; for(int q = s2;q != -1;) &#123; if(node[q].flag == true) &#123; result = q; break; &#125; q = node[q].next; &#125; if(result != -1) &#123; printf("%05d",result); &#125; else &#123; cout&lt;&lt;result; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1059]]></title>
    <url>%2F2019%2F11%2F02%2FPAT-1059%2F</url>
    <content type="text"><![CDATA[1059 Prime Factors传送门 题目大意：就是分解一个质因数 思路：如果要分解一个质因数，那么最简单的思路就是从2开始相除，直到不能除尽为止，同时记录除每个质因数的次数，最后按题目的要求输出 所以要几个步骤：1.首先列出一个素数表2.从素数表里面依次相除，并记录每个可以相除质数的次数3.打印的时候要注意最后一个不能有*符号(所以我需要用一个num来记录有多少个不同的质数方便最后打印)4.用一个fac的结构体来记录质数和次数 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;//分解质因数的实现const int maxn = 10001;int prime[maxn],pNum = 0;bool p[maxn] = &#123;false&#125;;void setPrime()&#123; for(int i = 2;i &lt; maxn;i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; &#125; for(int j = 0;j &lt; pNum;j++) &#123; if(i * prime[j] &gt; maxn) break; p[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125;&#125;struct factor&#123; int x,cnt;//x记录质因数,cnt记录质因数的个数&#125;fac[10];int num = 0,n;//num为不同质因子的个数void decomposePrimeFactor(int n)&#123; int temp = 0,i = 0,sum = 0; while(n) &#123; while(n % prime[temp] == 0) &#123; fac[i].x = prime[temp]; fac[i].cnt++; n /= prime[temp]; if(n % prime[temp] != 0)&#123; i++; num++; break; &#125; &#125; temp++; if(n == 1) break; &#125;&#125;int main()&#123; setPrime(); int cmp = 0; cin&gt;&gt;n; if(n == 1) &#123; cout&lt;&lt;"1=1"; &#125; else &#123; decomposePrimeFactor(n); cout&lt;&lt;n&lt;&lt;'='; for(int i = 0;i &lt; 10;i++) &#123; if(fac[i].cnt == 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;'*'; &#125; &#125; else if(fac[i].cnt &gt; 1) &#123; if(cmp == num-1) &#123; cout&lt;&lt;fac[i].x&lt;&lt;'^'&lt;&lt;fac[i].cnt; &#125; else &#123; cmp++; cout&lt;&lt;fac[i].x&lt;&lt;'^'&lt;&lt;fac[i].cnt&lt;&lt;'*'; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191007]]></title>
    <url>%2F2019%2F10%2F07%2F20191007%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190926]]></title>
    <url>%2F2019%2F09%2F26%2F20190926%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1003]]></title>
    <url>%2F2019%2F09%2F09%2FPAT-1003%2F</url>
    <content type="text"><![CDATA[1003 Emergency传送门 英文描述:As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:2 4 中文题意给出N个城市，M条无向边。每个城市都有一定数目的救援小组，所有边的边权已知。现在给出起点C1和终点C2，求从起点C1到终点C2的最短路径条数及最短路径上的救援小组数目之和。如果有多条最短路径，则输出数目之和最大的。 思路：把样例输入来举例子吧5 6 0 2分别代表5座城市(对应N)6条道路(对应M)0表示对应的起点是第0号城市(因为城市的编号是从0到N-1)这里我把0到4的五个城市分别从A到E来表示比较方便那么如图所示ABCDE五座城市,起点为A终点为C红色的数字表示每座城市的救援人员人数绿色的数字表示城市与城市之间的道路距离所以我们要求的是在从A到C道路距离最小的情况下,沿途城市一起的救援人数越多越好 所以我们定义一个rescueWorkers和val_distance来存放最后的结果并且令rescueWorkers = INT_MIN,val_distance = INT_MAX方便后面比较结果 定义一个邻接矩阵road[maxn][maxn],其中如果road[i][j]为0表示i和j之间没有道路,如果不为0则表示i和j之间有道路,且值即为图中绿色颜色的数字所代表的距离 再定义一个visit[maxn]来判断城市是够走过定义一个mapcity来存放每个城市的救援人数,其中city[i]表示第i个城市的救援人数(map也可以用一个数组来代替,因为城市是从0到N-1的所以没有影响) 所以我的思路就是用dfs从起点开始来进行搜索,直到到达终点位置然后就继续回溯,直到全部搜索完于是有两种情况1.搜索到C2的时候,当前的distance比之前更新过的val_distance要小这个时候应该重新更新sum为1,因为这是只有一种最小的情况,并且更新val_distance2.搜索到C2的时候,当前的distance和之前更新过的val_distance相等,这时表示当前找到了另一条最短路径,则此时sum++,然后再判断people和rescueWorkers的大小,如果当前的people比rescueWorkers大则重新更新rescueWorkers 几点需要注意的地方:1.在输入邻接表的时候不仅要更新road[i][j],一定也要还更新road[j][i]！！！否则会造成错误2.dfs的思路就是从0开始进行遍历,所以用一个for循环从头开始进行遍历,当visit[i] == 0 &amp;&amp; road[nowVisit][i]不为0的时候进一步dfs3.dfs后一定要令visit[i] = 1,回溯的时候一定要令visit[i] = 04.dfs直接从最初的C1点开始搜索,dfs(C1,city[C1],0)表示从C1开始搜索,最初的人数为city[C1],距离为0开始 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;//P1003 Emergencyconst int maxn = 501;//邻接矩阵最大的数目int N,M,C1,C2,sum = 0;//N表示城市数量,M表示道路的条数,C1表示当前所在城市,C2表示要去的城市int rescueWorkers = INT_MIN;//rescueWorkers来存放最多的救援队人数int val_distance = INT_MAX;int road[maxn][maxn];int visit[maxn];//表示是否访问过map&lt;int,int&gt;city;//定义一个map来存放城市对应的救援队的数目void dfs(int nowVisit,int people,int distance)&#123; if(nowVisit == C2) &#123; if(distance &lt; val_distance) &#123; sum = 1; val_distance = distance; rescueWorkers = people; &#125; else if(distance == val_distance) &#123; sum++; rescueWorkers = max(rescueWorkers,people); &#125; return ; &#125; if(distance &gt; val_distance) return ;//如果现在的距离已经超过最短的距离直接返回 for(int i = 0;i &lt; N;i++) &#123; if(visit[i] == 0 &amp;&amp; road[nowVisit][i] != 0) &#123; visit[i] = 1; dfs(i,(people+city[i]),(distance+road[nowVisit][i])); visit[i] = 0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2; for(int i = 0;i &lt; N;i++) &#123; int temp; cin&gt;&gt;temp; city[i] = temp; &#125; for(int j = 0;j &lt; M;j++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; road[a][b] = c; road[b][a] = c; &#125; dfs(C1,city[C1],0); cout&lt;&lt;sum&lt;&lt;" "&lt;&lt;rescueWorkers; return 0;&#125;]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1449]]></title>
    <url>%2F2019%2F09%2F05%2FluoguOJ-P1449%2F</url>
    <content type="text"><![CDATA[P1449 后缀表达式传送门 题目描述所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。 如：3*(5–2)+7对应的后缀表达式为：3．5．2．-*7．+@。’@’为表达式的结束符号。‘.’为操作数的结束符号。 输入格式输入：后缀表达式 输出格式输出：表达式的值 输入输出样例输入 #13.5.2.-*7.+@ 输出 #116 说明/提示字符串长度，1000内。 思路：从左到右扫描后缀表达式 如果是操作数就压入栈 如果是操作符就连续弹出两个操作数(且后弹出的是第一操作数,先弹出的是第一操作数)然后再进行对应操作符的操作最后再把新生成的操作数压入栈里面,直到后缀表达式扫描完毕那么此时栈只剩下的一个数就是最终的答案 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152stack&lt;int&gt; num;string str;int val = 0;int main()&#123; cin&gt;&gt;str; for(int i = 0;i &lt; str.size();i++) &#123; if(str[i] =='.') &#123; num.push(val); val = 0; continue; &#125; else if(str[i] &lt;= '9' &amp;&amp; str[i] &gt;='0') &#123; val *= 10; val += str[i] - '0' + 0; &#125; else if(str[i] != '@') &#123; int temp1,temp2,temp; temp2 = num.top(); num.pop(); temp1 = num.top(); num.pop(); if(str[i] == '+') &#123; temp = temp1 + temp2; &#125; else if(str[i] == '-') &#123; temp = temp1 - temp2; &#125; else if(str[i] == '*') &#123; temp = temp1 * temp2; &#125; else if(str[i] == '/') &#123; temp = temp1 / temp2; &#125; num.push(temp); &#125; else if(str[i] == '@') &#123; cout&lt;&lt;num.top(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1433]]></title>
    <url>%2F2019%2F09%2F03%2FluoguOJ-P1433%2F</url>
    <content type="text"><![CDATA[P1433 吃奶酪传送门 题目描述房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在(0,0)点处。 输入格式第一行一个数n (n&lt;=15) 接下来每行2个实数，表示第i块奶酪的坐标。 两点之间的距离公式=sqrt((x1-x2)(x1-x2)+(y1-y2)(y1-y2)) 输出格式一个数，表示要跑的最少距离，保留2位小数。 输入输出样例输入 #141 11 -1-1 1-1 -1 输出 #17.41 思路：double一个sum来统计每次dfs到底的时候比较最短距离，如果s比sum要小就更新sum 我觉得这里面最重要的就是用visit[maxn]数组来判断是否走过因为每次用now在dfs里面表示当前第几个点 因为要走过所有的点，所以从哪个点开始进行dfs是无所谓的，所以默认dfs(0,0,0.0)开始没问题 然后double Distance[maxn][maxn]来存放点与点之间的距离 Distance[i][j]表示第i个点和第j个点之间的距离 然后再dfs(i+1,j,s+Distance[now][j]) 这个的意思就是现在位于now点,然后再准备走向下一个点,也就是走向j对应的点 然后就先令visit[j] = 1表示j这个点即将要走到了 那么s就加上一个Distance[now][j],此时继续dfs 那么此时的now就等于j点,如果一直dfs,一直递归到条件不成立,那么就回溯,令visit[j] = 0 因为每一层dfs里面的for循环都是从1一直到n的,所以怎么无论dfs多少次都是会从1开始遍历 如果经过了就不考虑,如果没经过就继续dfs,直至每层dfs为止然后再更新最小的sum值 又因为输出的格式要求要保留两位小数,所以最后就printf(“%0.2f”,sum)得到最后的结果 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 16;int n;double sum = 10000.0;//sum来存放跑动的最少距离double Distance[maxn][maxn];//存放点与点之间的距离double x[maxn],y[maxn];//存放每个点的坐标int visit[maxn];void dfs(int i,int now,double s)//i表示已经走了几个点，now表示当前第几个点，s表示距离&#123; if(s &gt;= sum)//如果发现s已经大于当前最小的sum则直接返回 &#123; return ; &#125; if(i == n)//全部走完的时候 &#123; sum = min(sum,s); return ; &#125; for(int j = 1;j &lt;= n;j++) &#123; if(!visit[j]) &#123; visit[j] = 1;//把即将要走过的这个点设置为走过 dfs(i+1,j,s+Distance[now][j]); visit[j] = 0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; for(int i = 0;i &lt;= n;i++) &#123; for(int j = 0;j &lt;= n;j++) &#123; Distance[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); &#125; &#125; dfs(0,0,0.0); printf("%0.2f",sum); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1403]]></title>
    <url>%2F2019%2F09%2F02%2FluoguOJ-P1403%2F</url>
    <content type="text"><![CDATA[P1403 [AHOI2005]约数研究传送门 题目描述：科学家们在Samuel星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机“Samuel II”的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用“Samuel II”进行数学研究。 小联最近在研究和约数有关的问题，他统计每个正数N的约数的个数，并以f(N)来表示。例如12的约数有1、2、3、4、6、12。因此f(12)=6。下表给出了一些f(N)的取值： f(n)表示n的约数个数，现在给出n，要求求出f(1)到f(n)的总和。 输入格式:输入一行，一个整数n 输出格式:输出一个整数，表示总和 输入输出样例输入 #13输出 #15 说明/提示【数据范围】 20%N&lt;=5000 100%N&lt;=1000000 思路： (数学方法)f(1)到f(n)的和，即为1到n之间因子的和那么1到n之间1的因子总共有n/1个2的因子总共有n/2个3的因子总共有n/3个…依此类推那么1到n之间因子的和即为f(i) = n / i;i从1到n的总和 代码如下：123456789101112int n;int result;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; result += n / i; &#125; cout&lt;&lt;result; return 0;&#125; (非数学方法)(用筛法) 定义一个数组num[maxn]，result = 0；从1到n,int i = 1,然后每隔1就累加一次num[i]++,表示从1到n每个数都拥有的1的个数,然后再从1到n,s加一次ai然后i++递增,同理,i = 2,每隔2就累加一次num[i]++,然后依次类推表示从2到n里面每个数如果含有2就会++一次,然后结束循环之后,s再加一次a[i]依此类推 代码如下：123456789101112int n,a[10000001],s;int main()&#123;cin&gt;&gt;n;for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; &#125;cout&lt;&lt;s;return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1118]]></title>
    <url>%2F2019%2F08%2F31%2FluoguOJ-P1118%2F</url>
    <content type="text"><![CDATA[P1118 [USACO06FEB]数字三角形传送门 题目描述有这么一个游戏： 写出一个1至N的排列ai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少1，直到只剩下一个数字位置。下面是一个例子： 3,1,2,4 4,3,6 7,9 16 最后得到16这样一个数字。 现在想要倒着玩这样一个游戏，如果知道N，知道最后得到的数字的大小sum，请你求出最初序列ai，为1至N的一个排列。若答案有多种可能，则输出字典序最小的那一个。1234567891011121314输入输出样例输入：4 16输出：3 1 2 4说明/提示对于40%的数据，n≤7；对于80%的数据，n≤10；对于100%的数据，n≤12,sum≤12345。 思路：假设n = 5,那么a b c d e依次对应a b c d e a+b b+c c+d d+e a+2b+c b+2c+d c+2d+e a+3b+3c+d b+3c+3d+e a+4b+6c+4d+e此时1到5对应的权值即为位数 1 2 3 4 5权值 1 4 6 4 1 假设n = 8,那么a b c d e f g h依次对应a b c d e f g h a+b b+c c+d d+e e+f f+g g+h a+2b+c b+2c+d c+2d+e d+2e+f e+2f+g f+2g+h a+3b+3c+d b+3c+3d+e c+3d+3e+f d+3e+3f+g e+3f+3g+h a+4b+6c+4d+e b+4c+6d+4e+f c+4d+6e+4f+g d+4e+6f+4g+h a+5b+10c+10d+5e+f b+5c+10d+10e+5f+g c+5d+10e+10f+5g+h a+6b+15c+20d+15e+6f+g b+6c+15d+20e+15f+6g+h a+7b+21c+35d+35e+21f+7g+h 此时1到8对应的权值为位数 1 2 3 4 5 6 7 8权值 1 7 21 35 35 21 7 1 所以这其实就是一个杨辉三角的一个模型那么构建一个杨辉三角的代码如下所示1234c[1][1]=1;//最左上角的数初始化为1for(int i=2;i&lt;=n;i++)//由于这里数组的记录是从1开始记的，所以不用担心越界 for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//每个数都等于它肩上两数之和或者直接套用杨辉三角的通用公式来直接解出来,和上式一样C(n-1,m-1)=(n-1)!/[(m-1)!(n-m)!](其中!表示阶乘，n！=n(n-1)…21) 那么当n为几,sum的和就是n个数乘以杨辉三角第n行分别对应系数得到的结果 然后直接从1开始进行dfs,因为是从1开始储存的,所以得到的结果肯定也是字典序最小的 完整代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;int n,p;//输入必备int a[13];//输出必备int c[13][13];//杨辉三角必备bool b[13];//判重必备void dfs(int dep,int s)&#123; if(s&gt;p)//如果现在累加的数已经超过了给定的数，就返回 return; if(dep&gt;n)//如果已经搜完了n个数，就返回 &#123; if(s==p)//如果答案跟给定的数相等 &#123; cout&lt;&lt;a[1]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;" "&lt;&lt;a[i];//输出 exit(0);//终止程序 &#125; return;//如果没有输出答案，就返回 &#125; for(int i=1;i&lt;=n;i++) &#123; if(b[i]==false)//如果当前这个数没有用过 &#123; b[i]=true;//标记成用过 a[dep]=i;//保存第dep个取的数 dfs(dep+1,s+i*c[n][dep]); b[i]=false;//注意这里要将状态回归，不然TLE &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;p;//输入 c[1][1]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];//生成杨辉三角 dfs(1,0);//开启深搜之旅 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190823]]></title>
    <url>%2F2019%2F08%2F23%2F20190823%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX1/LHvxqQfruTBaOw3cX6jhLaXMnvSdZiitO+Y5ahkfbmtkZjQ8rTxMSSfH4X2zN2kGYZbfK7z5VLZ15qkouPaVD8sJXkDsmcFZiMtOFu9+28cAdYcRoeBfiiQAiGF2M4Czg9iyVyBeXWQLv1ztz9P22/7TgmAJ8+Fg0qxerAZqY717+/P8oW965i5gDcMwV2CNyQZVrjE2m8JOcWySVxo04BsKKg0HwpGKioQGulf4CQoL+sLNpVbsx2w7/ra24fdORQhqPVf8VON05Ywo6/vSjM0OKT28o2EQ80Rc+wes/c0KAEkrqkk97dslygOTUufQpdfkPQeylDvoCzYkPrbYSxDvZwJ8mNae6y8rYIU1qORvGEw2WKNxVcrnUXO45vL60utSIeq/Ara/6L4gULAJhbS7o0dNH9M4Guutk+Snpbo2i7bJHtwohhAYuZvXFdT9dLtBZYyASgWfw9/HVX/+9C1Rauzi99uApZgk+KJTGWQiRDGC+1cxrAIYUSokvFR2oRn19M8VXz5DZtf/uKIkg75vkJVV8rxd9iqp8HkFELLVU1I6IO2ImIAxRsf51HH9MnOrXwD97j0GR8nqYf183R30r1MQkrjFKD+HKE+0G3yGoOS1buSAAT3+dkBa/qaISfKno2T++GdwcEj6RHbaJGPfpurQr/eMCe4pTCTLwM+kA43esrlhOQn26up8d/TE08qWg5v3q4kmuvjsgG+sLLzjXml362nMVhrpYGhq3mmfEpql5EKXo+sYRrMEJdESgMvhjR6Ml5aUJISxDO/B7METJ/dm79Z3JDNd/At6H8VVahn5ybo3V/xdQ/a0wLUZmLCRh8k/OqRPy6rmtuwjFXo3JW4Y7zgZvkiiZir2byAFe7UCg3kYdjHwN0HQCdxq3Bq4ZvAa8PSAsEIPTJECtnCBpKxotAcAQOQbkBQtZky8xy8QI2iwhfaGMOhX6JwxUjS9qhJ4mJqHVXsmkrXIeUu0fRAXk74zF8PrbWyBaTnON4N2E635a8kf7qQuVmLoAstVNJnQEI5ESxOW8pVmpFE8/6c4dkIVQDk/0VH01HMMdW0WXdue095+u+t4mB1B9LFxKDKRa8iqmXApz4frdPY1jb6wRTr1hSkbv1N43sz5q8Bhy/uAuDDz94aclG8yJ0iVVXJj8j1PRLaT47Tu0fo5SD8sqZsG3m3EkvaNB6A6b++sUh9LRHYYBe5bs11NQHwfqtXjiCWxxpKMXf6Ec1I0Ih4l4LRAEXy+XA8IcfvcxhfzDz7CWCiodqsGsFa3NT94m5LhOmSY1sRKegYxrqr3KXIsiVC1ujVGQ7H9n6DuadZvcrnCdCLQcCjRjOrw0Ns6+ZidkIyNqokZrUeTfSrfwjvK8ScaliKkYOHt2WFK09xe8ZRbOaAwZJzP+A3xfAKpV9CWsVEw8+09AMswaaS+WKPJYq7ZwRgo6uJ7yLnVG3cPo8s20Z6amkgUNjTxd+BFT830jHCqVtglo5++wige4KBOUcH+oKSW4m6mWFyn1ZmapeMXG4Bh3qnI4bY8umtz724mgYyu0K+Hz+WY+GwRWslIZxtyFWesH4nyy1xPMN/ixalImq8siab0rCI7A6EldL1zbfZ62E/Coqi/s6DuzFR3GOeWmM4ygTtVQhfcpbsfRTdIeSL/E51oPqF7M0bGn1KgcExro2HsB87KwjMAhsvpEn3e7ySyYlXZIQ4zFTueOqFB7z0iNvWsRGeVLoD10pGJBbDFYMRnMG9sFQ/KhpiifIy/HBFCLWKQh3YKhNnvyjcXTVS9TSOVPXAwCgAHLZeNqEX0TdyZp6jOyGytS/K0BrDBlSWfV/EJUeuGfm9F1I4ZA0Y9H1diyb/qVNopk4G8CP6IT2Vjc08r16547IGdBPkcu4QozG+S36DxU4vqUsMNMleK97z8dgNdycZiFQRYi3RlArOxzEBWQujSDrjCaTQ3yH/LOMvxvCnGqChcQk5C51HqIuuy1+wjGJIcdj3+EdlFxRIfUdG3sxR7UcWeBawYKJrE6FzB4bXZiXgbKPCdHYP8gY7S7e1ZcfL7MRLz+si+ykgqGnZkrKikITVrhfQImZdGn6DDM/SipIu8FNyV7gG4bxuCjmlYUDmyxmvvfqvPX2Nl3gbcIdDpa5NSGoT4Hnxqv+uXJJN/Z2L64wmomGVGE9hqimc8wTRaRS0L/va/YB8hSdNUtxZjdSJTSoZcCvTdULsyYmEV9uP9jatapq25ruZz/SeS0p55ZQ8HUDQ/fFByEnWvJ2VyXiuPudri4wii6IsFYq9cjmwYX8S3f+jp6/AaeFccrmtlJr/V2SRcdfKPjrvkJpT3vqwz9ohwnMbiHT5KuqnA4P+CnSDYos4Pg5vYt+sWsppmCAStkd32WU/KzoYudSYULiv5z4Tg7ckgmvenlyBycGEZ6/go68kFvGnVLUhIMX/oxxMi15Jz6I9tW5a2GFdQ5wFLe1DAesbSdrm/ZKqHonbnBQ4R2KIo/ncvu/qfzsM2sxCnLatlxvmNs/iJzaleWJh5raBLnkvD38bRlWt42mDQzwag8FrNhaCc0HuAo2R9eCTK/JwFvBz/lVanZy4ZPWummc1m79iTGGWoJSWV1dki93+RORRlWTgIZNRw1HpIhR3rUh0Yd4MEQulehGSsFMEkr/gczGR9jyQCmSHAq94bZpEqvEXEZWdyAAsrucA1FGu8kcVtxP0VU1KAVkEoU8Els/b6kDrjtWazKrduCPvMiWG5EGaa+ED+w8kGIo48Nnrfj/jBhmH0WtjN5aJFtvZZkMKyz3oVYwJ9Fb1mPFfeI/E7Ay11BtHNQUjkMR8e0orgwC2CuS4WO5cM+EaLRejOuExYxkLniJ0AljgEBcvR/ozEZYl9sW/eV84JCJH+QKnGDWED5aerRIqLVSHi6cPJbZ4KgQjvxbr6boTyc8VCxQMUIlZLTuzPAcU0zT+pCOv5eTV3z+tHrlatz7hWsuj/+5x7LuwGLIezUdqOMayz7n9/Mx8CZtyHId/dirLF0MvCacWgnlMLXYMO+yB9xkSEcSb+EoSaNCxNg2dEV+mdFP3tMMoE/KND9qRlCs54+lFSdmY52EU0FMxMeJeYhQ7hN/prAmsnoaSvKIauEQg8DcARQ2brcQYZoqdOLjt/vGBhqlPKM5OLHPZLFKxDYKg/pOuxUAS2SFDbrpyPLlBqZANm6E1IC5yf3cK6KWinrdaCGp8VeLhwDgm3iMoQPVWTjH3jwWl62x9mSiK1n2EATRoNzb9woF4qUoMO1bazyRIGyF17AhQ9qWI50Fl2j6b5bt233wU8XCpDr+v3LZsYArNnFFjpgPbswmW9OY9z0UxDai6DP/fRC7OApeL54gsahDsSD3ZGFXcr6nF6IFPoJ081a/hkHjC0Ipz98TabS08hzBAEqGGZCeUFhHFTQ4mBoEQt8wwTsuqOG05U7kUmDQidPSFre/qS7kOARKwGXM3dXmBGqfsm8O+XVwcBkKUuoGWL0KeAH6nkqZ8J2VMaQZZjhK+toHgHefcTNILvAHRwTi8Xg7zen6nPpB89N2lT9UN59CySWLQU63rYKnaXj35/Mtms3SiUZ0r6EQRE8+rBcHT1c5bx5OahZUvFHrMAKoBXC6jXgZsr829Ht49iRaGJFT+L+t9xrOLP/0mdeevENlnr8Y8fCkLEtGWkKo6je1G/w+KOEheN2BkiNzRwxPnXwCIOeCMEgFUWOX5DjWEHCA5dhbhd0XHyeLDv3+CyvyrK5uuuScC2bA4d/qaaJyUf5B4lkcN4P8AWkIZVMGlBIxLb36kJEr7AcOZcAB6RlLSPrQngZAu2Kk0PgdhjxJEe0Uavju431RgWf53GJaI3vyhuPC3zkwK6t0R5SC01wYnaJlfmt3/0kwRSIZHw6+9i1cjFw8DslnKe00LLGzDPWt0MZpKP7mk6QorYDT47dauX6lMDwhDAsLxiUZo41U6WA301UjpgTeelr9A0jNFTcVLOv3wWLcerjhz1j3A5WhAgxXhUqYsfe74n2HjDAX5U2FtA6PocMXM04f214HUG8tSw+y/7nJPz/0wWCb3klbX+C57HAkp0M2+jKwoHbNLYsRVxeAs0+v8l6YlaNzlEUKNK1pPYyFbU3JjP705Ay41TUbVqaZm4krXCdlvJ2f198gee+7hPPeXt+vQc9QcFxKptf7h9r9hIXUxEZNSS8W3TSuTN2keIr9p9xFY5TtgGF+npg3NgqHMg9HwNHwBBiwzuwRyv82qYy5BmGb/4HqwEQyarG0NzSpCDlInyHhDSOSyVuRwHWgCW3LH1+VTsOPSUlBGSor8x5UBvq7dC06l8mub3kGRtO1DINIDyTYmg/yCupegCWUuICaqsS8iQn5aG5D0jYO5773gEFipCh5oBx9RTaQJ92Qqgonhcph/a9ys/hGu6q1GFKt7hILkrfolZ3H5vc285fWti354I/q55aFuJzpSFlDQkHJ0SRFPB6ytDeWngucLX9oFXVyfElH7+91Z3MXCdVMUXnm7G940QP6Qm4mXVtqrM2wT7Knw85aMQ66OxZAjF92rr/pLsa2pAeaqvBNSfLRtbTPPaz+CN3ZWlCa0Qw1RyDv6HmhkScZGFB/Bwrgib+xn+7q3YeEiuwsbmDkyRqj6rP/9V5h9vpASRS2pQMKcNzaKM469ixGTJGdCa0RZjuNqOvyT4NPV9XuO5fYA68f0VJUhc8+WPTzVtu3cCJLACppd0J1zZg58rQtRhT4/gtA/Cq+axxjiow9Ex5TcthhMg6IP5YPoX/b61zDmE/ILPLaCWEoIg6alnO3/QHShT5IxWY/N0GGZHrhizibQZpVKEP0aqrq1Rx3QZno1eykDpcdHptvxZEAP8FAsNWwhHUk/4slg8QRHf+a79CyeWo3fwVRmsbvLhqlJyfk7b4M4Qhz2ZXJAUEwvv7zsO+VXF03eiJBJyGKfSBPS+mWvqNgGKVHvs49pjgOu/kh/yEDCJFZYBJwjPlpXk/mTnW1J5rwgN0gNiPy2HqkztpBhGYCcZsxJMgvXRN71ncrnJn/iyaUPyLuC46V4URAzvaKN66AMXGWHhcsgMlA6R+5eKzqCJ4oFWDT8AYUpfZsMNcW0EHWbCHv1xZoh2aROygRDWDeczKba5h1Be3ErL+M2XqQRqBQf6+bxzKzhjNeNwmJirwu0JKKln0xoWa219niod5dWNhGz/gdcxm7N92OLP0A1YcduJdTO+ccQlD5Ncf8Pvc+tnBT8zh1+wFDypTkophGDqiuGXD3PgPrzTxzX460pc0k8hhR/eejwEnSI2+qUGsQhFmQvFLlXZz5xJ7vOA7Y8ANs3aynHqJk2ezqnukNYK9c6Hm+HWNiuwu22/chBKk/3u8UdX63VV2OiYEkggkFgJofff9hS6gkphm6N5KLMXlY0h0PDO2uLCUt7CZvRLUQoOWRHVF/KDNtHcfDKePg0KVRik2Mb6Q4BDDewHI1psqsmCgOMRp+ptN7tlWNENyJeNbkP9EV3tCdxt8r1YTkAxyazWfb5jsibEm2UpqUx5fzlYs9eM+XXuW8OE6BfK8nHULD2Vt22Ab2aON3oHcRK7l+9+CTYZH/BqsozNwawSWHHG6H6mXAjuQfV/o7umU66B11E2ssmQd2DMkNp4tnZXiO1WENHbboCyB2VPn7Cb1+BbqAHD8Y0YRYK1efLiicnGtS7sgn68oz9SEMBOg8yXEls19gE9OEr3WvDoM5qhWYP6xdOuW3NvsprASel4J683nAm1gtdSKdbyKTOAOhxKo50OTQBcBCNbFWG866qgqpQjvqrTGsEbelCoyVb6Lpk/iiF+9r7OE0XS+J4fcwoBTCOWSWadpIO/AWwtn9xcbcel9kntF4isK41sjsc29xd0pMn4d2Ge65l7hLOSoGDNLAZv2BMmPIiR/Glmc+vEmjQqIqr5+F+l/jZW3S+KrQ9qyJ+L0mM9u/7I9bOJbDTuDDJu35K4vg9TE9C+7JcQhSvUiIiVApbOY+0X7MBMmgahpWsVjfvTeoRNJaG8GaKt6hAzXwfkPYXm1b3f19EOeVDiNaT0jSolGxOUphJrzaUK2Gp0LvS6w4L1KI1KGh06Z3LPcCivnyCC0fpq/91qMD0TmnpUuYM3Sqb6nU/u1u2/DGvtWq/dLh+J50Y47jlfk2zXPBUsQErGEBfwKWdLBRCzMLIxymCWVsiQAr90ZyJmDWCJavbZ2KNS5lLsK/V4KsWiUl3wquDdTyQ4nfGyAOks/jJ5efLOexaQEw2ntUEPmSUULViv8IdJMbwMWLDFRCA8yC+be/4cQ+WRADBoExo9D3CrxA+/2zHJurdgwDvOReSOq8TtER78ECBeNZFnzkAKlmJ530kR8qHl6MSXwQ3DtOG4HbxK1wUe6gblRZe5zD4essRW6fwMuGSxLrM2AunXXAkxK/yVXJ/BH0dSovFep32slESZnWUvpSGc/hBphaImu5ojiDEBeDmS4mjZXW8sVBjBZsO8f/tQK+3EWlu8+QaZ1FoTh3MIDNfzTpkbhWApTyQ/5SiK9mYZgqpBT3mtzp8ZAjEweX40EQnfvvWYOpL3/xjza2GEh5XZVppJIlJ2h/HRhGINXCb39fCx6d2d267RTO6XZVsaRKVlBJJE7yMvTajOOkc5BT+WeyRjs1uSE8WZ5iLstJpRkhuM3SPtZA5c1mX0mwstF55/z+YlfJ8AQd+cMxolPVEig+X3UfTbIeKZL2i92wWQNToZakpyYDLexfvife64fG5g739nM6EOCgjDDXCdfewLbGPE5cgULUPep1vklmk2HwLW60vVuw6zfTOJTH6CBUqNiLZjui6RC1OSgga9t481fvmUmVWZEvKReyzABzNOmEL0pYaQEKeF+YrqmNZYAm85T2v9ywmYV93jOgI4ImwPBQ+oYx5l1j2ArAMPrGuFbBFdcDv9+TilTbfKPLJEpWx2DYro1sTPxFRh5MD1QIXI0sqwjF43ueHjkFn3fk00SO2z5BulMngKhvoq87Fu7pvAZPlOkcIjUbq+sOEq9LIaovFOO58FPpgyVUtiitkggOKfneIDlvZ3eha11ug5+Q2sYipZiRFNvD1w3IHEGCfoED1bMSz0hdO04SA/BwYYvgEJv/sA/Ire0MOB058npyO9ZM9RlFo7wyGOoHesqlMVtGS9RDO7HMtQX/om78C96S8q8IW6/CpEO5lREYV9iSTomStHxtndCrJvPn4ydASWKlsnnBHnWvlTvbnVsmpULwhISQ2AhxF8SxvY/uoFu80RwAuFN45TBoZlaww8Iclx3y9Ih7guRFOaiT7hoZG3QtqRFxfN+DcGgYvgUr+sxjZd9nDanpIqHLoLdvnCt92FJDjXguyiJeLfhnjZaoLYD9lqje5k2Aqwf6VyzBlSa0IKPjQkSJP52C/dfBYObl0eDqZTDtBAAEGVX9EmJrlAa2gRPeSq8Ei50NhjVBdIfn3ASaFiSeN2fWsEXZBw/X3gxS5z38TydfxRPaKQOR7mSZKD+PZeJIVibJ0o9wJmF+/JWD0hY1ohfAEKOn2XD+RFd2pevqP24aBVb5hs0Kyc8rOlEP1SnOP/RdMtaWI5wKL7PPst+XXgqF3qMzbD8mwhBbyj95bsGe2lPDhytzCXgSj3GO25A6SVSb3SJ4dQwld83VuKUcX6gV2l8jCjKXwxP3cG/bwDOKAdxQAc9S15Cq01Iwc4oOHrEEuTWVnjSac/gD1srgeT7mvxQty9+JPnlApm3wVJ+mBZtf2+uTBJyScGNYKTYC4WT28g6M16HJWJXLQUoU1rFcd8xE83XN/kUf8Dq0FutaZUtou05GcTPH+iKzfZkZz9+lLau7Z97aqoaQ+gnCEW1eORPP5rUOfHilogXD+pk814Mv7rf6+0ReBBwPCiMLQ2yDP6tqEN3ZFscMdu4aBG527tir6KfucOp9VR2ARccX6CWA3aWiudvPC5Nim4yN3dcZEMQDoSdWbdqB44v7VPw7ECilBzyTZ39hb4Oyi32OfzQA82LOoHgaMRaO2NZob2h9hSwR97uEjrWmS1Gnprw5pLxMTFYordVnZwbH6xyjVm6oSSF0ofxtquZfR2UYpD+Onww4f6vKsXON4BhRBPxfPHxkCavq+sqtThR4jkIzbbF+OEtn2UTgK0x/I0LP22dePxh+Z13U+Noq1VpwrdYiU00kNZ7z4N5fmgJGYnFEBvAkp/10U8ByJ+xXK02IgWAmPkvJ/QiJIc5Q3y4BiYs3hoO7EbIxzVyqhd7uXx0/zkIx0DG4glyMYymyy6uLOVlSpCTRac9qOFateqyG8Wmmkt2EG+ZoJ2EWNh0sgpEfFOeFuaJXG2Wvo7pAvUUkniQeBP98PzzvrcLJIwVUAhu6ESEzcAM79xzMwPP2X8HhLW7BT5u08PjYwUBcXe31cjiTkvYE1FzKRxE4Y3Y1oZ7z59FD5JlNjQTFtYgSBLnGa/DLz+A0aWXIHp7CDSD4RoSzQMkcTv6QeqbauQr4l9smAONguW3sK355SczWDbI1VKrq6PKnWfIKm7FEqHqpPCzhzKzbB37vuwUA2RwBiKt/CkbHwzyPcxlMCVB3rW5eL53Hgsx8F3F+oFeo/zh1bWL4rmIUDhCkjbq/B7v4januOKdVdqPEptAnjLCsjficKuYOw85+389JyFfB7MI2Z4mpmjoGHKTaNw4rIQ+eRQTB1VLXKGG4gKuKGBBsLZzvIrMMTMrpp2tFOl59nLIsLhVxNa8sMU+hhw+BWKO2pvkoQcIN3xYttsfMJdNtaHTi7J7HIfV9ryK0BQg4pmB27kYwpyoMTJknjjorS5kGJDe5bbzLSqQ8CTi8Ezc32ee]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190816]]></title>
    <url>%2F2019%2F08%2F16%2F20190816%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190810]]></title>
    <url>%2F2019%2F08%2F10%2F20190810%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+W34WzzoC4JFd7rU5BpgzJDXc/5ug6dH4EMPCrN48gIE3HzB/VOGs/N91uNh+gJ0/8X6oxLZT8HQUUnDqdb6MFxKXyvdOSaGEYFg33vsS/S/CK4JAMYmXO1r4D9Hso1zX9sLH0ScYc5ErrwVauw0FnT5GdM1mM7zv8MOVB1H7x78zVwJ2pkzZ58ko7WK5OSkRDkKbAKH57rHgwsTpV/G28PdWHf3jFA9VHXwRnNXqbzZ133wsEXFiCG4LDq96uw7cJj15+WAJptzRsUN/UBAtiCwPW5f0mU5hGQW8slkJtBIn+IHEJnJj5BejjRMS4A9ZRlysEh4s87cYnlGsaskDUGl9tgbQ89uk2P7xwsMPisQ87wcDE8JS/EK8l1iUBEEWeLe3VL3PX3lcrcau6guKfjcI2e9+WmbMsA0reUPhqmhgijMv0sWm/WPdU1ESZAIe/2qp+vNJ7RcsH3A7HSxYpL5Pd6+7hhDoZOMBY/Yy/xVgBKf73LHPSlo79hfnGPs8LUtmlqUL6kCpcAXjqdF7iCd/qU+LKdm7drqBAkyiK6womsGFO4sJQM/lPGCuhBCAxtt/RPjhHt1TArvMyx1kxE67OShw/MXykyo/PpEeVjLMwRcqudrF6K8N5k9GGb2neemKQprxH0VYGH23WuhilcsEw/PatEWmA2E+ijAUX8ys961aG+259iZqBS4GP6txhyhv67uIGTHTwTrzmXAumN9Yn/MZfqnH1VTEgLo7xZV9iHo8EIR17etOAiItWLZsP9wi6TVKOh8uQp5Og6xdRjTwiTcIyJ7P0d/RxFWU5/sW3gpy+fmO4fh4ZKhpcrUW0TIGfHnMk2e66mOTERsZVQGmzbN0DQnwEFWTMT0Adu1rqT85FV/lI5TQX1jlnuN7heSua0+LELjdkzL/Jt9RZO7J2xYXlAEWtrOQTGuQOBDZcpOYKnLR4JThmx5Dcl1eKYF2FshtLXiPQyguI65LxkEefa4OJ4riwlVUSZfgKXjWvoo3DOajaZIu7lgsmkHonPjTgC5zV2wa6JH+tqwUg1hKgRBk+Jh1ICoaOD0+T3cNjtWuthgdOBKcGLGvzEPzNaKjHT9WpudbTKUipqYpQsU2yPCUigUmHawv/v1Vufk3uJ96pP/BnSvkI/jCH5+I/TVmUbFiihgbSmXYWZuhv3eenVbGCdkWzNFESKPEc7SS9PEmEwtOx/hPRLvYzczv+JJpTEGEDOcL+8haEowKA2jCCJ9nK4G67O1epX+ROqTv0CTKiw1/iM6rqc54+uLv2P7fGbhyT25X7xGII/YQIDqeT7ans3Ntfa+rzcOiAotmbO3etfbelH2HKTdZ86HUCXT6bklFTL2vpAI5Mrjc5K57TevsnqkXr116Pmkb8xj4g5NGIfAs4zHG1iEHrDicObLGYNgs01m0cIk8LY5UrVwJVT/lhH7AXnlGuZYxYR5LhBI6bhp8Unoliy6HS+1JAHEKEap+7t4eG3aj8eCIJC2o9YnZU/x4+hID6YKGkvHT3Fpb1OEC0ps14mMAX2bW6XO3FUwceeDaizAv31QP6sKdY7eLEaKEifSm2SmQ1Y8XshRmaPymXA+uy0tJrYbHhuMb98g+8RXP6o0RZnVkZKKYhh0gQrThN/iblWcjYURd9mYLJTDQeGHxy5wS4dNO5WuWOobCagwgND8yA1YXPcN3sYD4eWEbt/zK7i4VZMczOf4ofPwmR/GU6jD+fkX6263aKqXiEyfvSD4QQSXn9IkhPJpdxGobQMLtdmYjC/3kac6NIwCuGb+PX6L6G7muiYXkKpVZXpR2d2tbeBVRs5acNQs16bnOzc38gnK0pGDljkjmO2f7qe7RShoSqRrMv0KGuR5Y8EurfQTO718ShD5P4rCQ7HkjVrB84NLhlOydofObR1+9+bjSq/ZzCSAH9o5wORaFXiN6WxYkMkp/ZhcBeqd8Vrk+c+t/fUpNXImkDdVdjsw6Oe+X9uRzHtqqbc67dvFTQpQzbrubMNr4M+7f/TxWM6KNCGciyCwvoLGNOWdi9hBKHSFUDU+ls44WfeTG8BoJNG4S9nqq1SNR+aYEFjrxG/Wor7p//zTcaDALweAvCm2umkJYuXrT5vrdt314AKw7JJ1JxeTiYK3F0UpAo5KS3CO1VNVLx3OEr940jlJ4V7x0B9cpwyJcRKPq1CwBQmuunlUlP9zGfKvwrvf0Ob+wetth2FXjfjRT+QnADL9MQV3mc3uqOfO5RbAcNT7HJqtZN1lOVJjdJg52A/oxgqe/9RmcBGcjnOVlEQ/9HiVrVjxWbPOJv+S61aFmDMLP20GOsM4l9+Wf/xLTQhBh7b4LujKEJVTWYbEphoS98OLQ+Dwv5jPfBm8KKkdZ9MjJUU8XEL/2Cy54Qvn4vUpvW/2ugTiSVwoAA0skQq3tabsL1uRks1x1GadaBAVr87Tkcr/Qdxe3LLdODimiiuT0HtPHmIV6n6jkZlBxxo9cFiMFYDNOaB9lwW7pTb06Qth1xQbVvweOnYkO8PfFITCY/9a78XL9B60XLUfJQK6d2AhM3dTZxHYAOcE7WsrcBtD85kGgPtQDBGpNDj/QtfKlcnXxh9jgmTWvoS4PC2c5ks1V4AL5GS+WvbAszlbUONLAeTVxd+PEwK5mukldXc4+oAM9kTYZgtHqWtcjGCJDqEztGXGApQfzT3dJZoxJoWdZh+8tnsl0MmhFsK+IWXt3sgjhckWjbWD5xN6Gs30+UdbgROOQqMSZz7tLFigWu5MgcznCAqRHUU/tcqc5+dt9Y3LWMHNDd4Ua26qbcXSpwRltPmxbtRwmjIKLlVcpBiliZcQK4JlQzL/hVibz05hikowIdW6DqRYpetJID2zfF2bc2CBNH/kS8jInileQDljU1ozUUnAu+JvAn3qt6C7RssxWonm0R0ck1qjlSlfku77SDKtUKf8xBrPRqqcZK+uUatqd1b4/AePPSm4kvD50Ir6OvRwSNWNugijwEOLmUEO5fbnYpbHz6OOCF0J42LiK/glFx5gxdHbqr3KiWMZxiOUUu+XrmdOq90+Uc0TZc9bEKZQLKJL02YVHZKNAEUaR+0uAL+UreoTznqAh8zQTwcsEecv2CNuJFQrVP5cjVbHGclvxeEDPgCSnMmPP3RZAB6LM2fxDKFeUb14SgbFxkr6PaZ4HBD6lIX79ONK1BmDMJB4bcfzJRjczRsBhKuSYgl57EoDwnDP550An9OR8Ni+fjIu6CFc0BIAjnjOavmDBd5BcKt30IiwByaH8mW3CT3C49lOYuKubxMrIIRATxKIlHxps3JgncYJ26kvvld0rNEbPLwFcvCMwqAD8LTtES9n8UPn/A5eimFQLNXhoDMMrfcQUjaklmd0gkjc8NJxjNw/DGDdWPLf9/KCkwNnpgJfTFUhxB0Hex9yq/AIJvALC29hrV780vYX2huUbfDWNr8lCohMx/nYG3hGAIkWfmnhvJwfzDvR1/aRg9YORfj6zYj+ybqXNUBjFeOa2TQlpgVKJtd2HS/sC5yDZaMkxjtI2uDYrcTuPR16qYK2iQ52dhTTqVVLyI2XiiPtB77WAJiEdTTaz8QcKvl/jDMgPqv5t4IOYc8QevCAnMMbQ5eCWEFA56KAPch26+yrl907u3j57t5QV9PCiN2uW6P2gERzvx8pZT3RF691BwIRnxIpZxuEA7mLDYUjUee+G5VIjbNPABMnS1bVccijF70jywfHBPZ9NH+uXyeXVpTUEAajgxRp0K3w9QW3X1E+bpR9TSOn8KseI8RuG0zcgzQvkJnIFO5SOpf11tkDeeBTnoD7ZON8mzBoA2E4w8p6FlEm7jZnnqVZ1A7q6PYOWY2xX0YSgDvaPuFEXAyKKrs49CDPkV3btMQFdTeHA4yB0y5ff84NG6ImZACbB9J/lXUYeglCMTIKGeXsmpy9NSYyemC1x4lf++lmnTOgr5ltrlCRURqORRM7o3k9kgr9HMY8aFXSISihoZ6JaV2a02IY/qASEXx80v5qG66m/Ctm/zXFSLTsMgjqLSRSHsHHOSPj3Y9cUsKXjfIu4l8l9bQeNPwGXTH4KoBpH0UCdXdPLTQRGjneXZ5OeSobnqMkNxqhPNtAjTBKJhXOnQbG9jAtLbsbcymCZQ9wRgB4jA3oFnKQ7PCHZaDQwtcaulUKPlNr4+0NFHnl512WMLz6NKTF+TEiv+7A2baMfgo7GgvHUBJ6wG+Z/w8UvbwDBraVKtCFEa7kuteFZ9kInawKejSBNTRouMZ3w42NhxX7WS6PCUJPL4RlFoZWcsfg0ki9qg7jPrYJ3Jr2rmYkwlBn91IIjx95+NU7x4LsdpTF+1vMH0osVaZ3JEUGyvLJLvK3bDAlPHP0uOHNUtHsBvqDBlnPKC3L6REe0jDtDrK8xxZt5NzCZataeR8S0Yl7fY2maBAeKvxEDuif4Mk6qHwolTOzTLGBC2jkyjWLSCGDKnOA67df2BOa8tzqa+n6w4Tz3B0kN2KD7kDqsOEQ5mqjCuvc6ynyN0Rn7pnuhtFT4ardQMxZKK1lD/0Ph5aXw7IQSGrrLikk7GxjCdKhTligThQhcDSqXmqLkPPqghUceAiWH2eQ4EXhVo7eb+15JT+ZHgMkCTtT9Ssnn5YuVygKiDj7x6HBwZl5b98W/5qe+uPPHUBRfCaTprxqLobya4NWJ+vZmTuOxngkQT4kJtmuTomuQblSBMmAsYI+ucEQ/ZdNCCVo6LxRqfwrBWPObzESUBgkU/TNcrwK5WjdpqJpD6CS9UIfMB38hqfDlW7zdbGpZy/OIGWHZ2Z/mZ7mixHCdUJ73QqvESnycbXJjCoQAgZPY1jCMg9phuQU7TytB2rmQNyRkl+aTOOGNl3PeFb/6O+ATOEttIj5NoCtpe26NwgmvloyoWJKgTIarou8adL2D5yvJv0g27ulujzXO6DkMqGQQ9+s4ErkTPiY1KqkkYGEfcjUDMjrbLHlgLwOWUPY+juEV3EHYCuEdlRyGttxpIWHSbVH4iSmC0dOgF+58knTo6lK66IYAw0N35dw7IjjuH4TXvaYyxVZfyw1C4H0fMupdvTwrX8ad7ULnQv/Vsi3/TlSndbLNoUhAPaN9ZbXXE1+qQbgr4s3wRhguF1qtuy8UtKiOd/G6JIVBna1uK3d70vEd1B43xUeIuJUCwqrA5m49uE97n6bf3TA0EKcU5W3SzT2SkE2+RcMlRZGQOZMD2hlMcVeE0pw7uN7kUGY7PLYfYPZRbreiUH9bsa49+gmcHb4Ia31CcMBv8st+VvWsUJKyUs7hlXQQLM/ql0LliCQs6Td1y7sSHazuhLRLtDY/icUn4k1V7fYOjuXXlCPqHp0godsOMChpeJX9aXXL/6N+jx3oSzQk0hvKByDuU3xhXTz9a8Jzn0IemvhTOgXNz7Vbx9Asb+xELup2muEArN22adkTm3zdcHGqzm8iGHhlwF8IJkb4i2jqk8xjOQMsktX0D9CXIRetUZbxTOwetU9jTW8OwSZ9nRwUawpSvHK0PvSXhKbmuH4T7k5yT1smRjB173G1MIiNrI47dvcuheruphd+p4pPUM6Gke36HJat8HEFimpJwH5hzzwLrf72+OpuvO5IQAYraT0Vay3yABxDUTjbG8bXGycUVJKft7LwQf2wNDxsblyaE0GsJ5jYdbS208GSnXSG8cLxz+Q+ESkH6eT9VX/FFub6krfUhP4BaKCdAoRFoUrzPKKyb5VZyjJ5eGxo0iqVOTTuFEGzNIPwyg4Au9TP4Lw0AvU1m8U1FLeJNexfauzzdHrz8SfmrYyHkD2V/ENh6IrK4NaZZq9eSNEpdxaJ6LYxhl18LMLxAiv3B3ul/vLS5o+IUEjHowTtd51r5z6UrCrTmScWUS+CzGzyGWL1tvgCyksFrC2MonvxhgQv/hbubuRyQQ2NKnn+znghisl5ps5kvwWRAQURsDQObHeuvnMVoic1XeCi8RDgxDLFkDcrMdDtcviVXSmDNKbd7pgYcJwL+CCRCSqx+s2jZTA+zFPquEUNcAdWDJ1JYAEsSK6sC4E+mdfOjlwLtUFlGXq9D0L4GuSC6HM0HWJj53Tg28VkZxigYjQZpDGQYOk2KGAPksX7zLCsVFOrBiVqog65lwAzlDbq1H5ynLjRNnEiZNgsOxsSdbh0/L0S4ugTITGRPiiQ9Seu5BLXCTML/czxCfUmWJjBabAgIsWkQk9k5FFEZKE2QGL/asMl6yxKkKA/caEfvSIvUlrXPP3+crRTNaNiHFVFSDE31Yt4V/a0KQSbb2ddJ8zG+5T7YfF/tEMBPfiwGCRCg8hxL7WTDIil2wZdR7F9zdTPjlsmxgrjHl8H2cf1RvUpSc2hEr2QwPohJLOUxfzY7sOwEPs3sj9yGzmtKb40abbnmWvzaW0L2Nv6VH75cC+PrUZfqdbFesDSJ639VnoOl3774ZPxqCDfqnzJctm1+i8TLPtrcGKOPH/LTgvrVebZeDEWTthkr/mjAwnHMw2IzcdKsLcN/ro1eIcE+ttZ3hOpKtdOBaWFCz/hL72EPLFKT6hmtVL0l+F4gGbNjFKTEtXG9zQ0xh9Eaw9+TXz+jIsbOaFxE2tCxDxvLlaoswePTzjqWGHrnk7FoX0ZZzUyc9WUVVP+U8zsg9t2mBUtbfCu2aQz+IV6ghDirXorD79Z1m/m8jyJW0lAHxjqT6UpMg+tgSRZTfUZsnVIyiIOz5H784rsvlWTkF97NSDZqCqWjjL5zr6bnHv0kI+XPCDjAboDVe3yyF15+7CMXVOoDQf53wpSWyDmBDDjwFCd7c3IJhd46HofAk62ks8FcqdL+6kdDfU6gwueleQ8mNb9+mfjxzqwIm4RZY/sXDkHd+ElfQHfdD1qYis59PfdMxMxGpWKF2nv7KzWABr6yLSeSTWNASfz3JO5X4zbUgbmd+Qye/25lXhMHWVdDbHPQvx0GN35ion9ILL8/xEawfTh1cdPFaE22TesXmVudPSEbM5SKGIqls9Rr3NHYLjksbi4ocGXW71sVdmxDJpsLWuu1kQAAwHvxCEE5nIf2OEDAzP2lywwdvPSqaXzD7c14SvMeJvd/eZix+EzDU1NljQ6jVyoPkhMDHs0Wiuddh7OCcDdPUAQsrM3sX99pKoaFzcRoSOubGNgTzvOZIthUEaysLGNjmTI2wic8lmF78s8Ulp5YBn+PVlNM3IuoKxiPbwcucFpBlCvvqZ3LoJczCHciF6tQ6ceN6vNNKOvEzfEwVTq9DxqitgnYFZd6weMWQZo6eUCdeB5UbuAnDjX63diHXDBqf7ie43PEqd1zSLFIU8mvR21AqHlj3u/WyejOdJ7d7lgo4SK6BU/ETxjLOu09s6XB3fKMZP6AH2QZ9qEheJByL3x/PLAqqceS32kXQWOpS1r+S4p7WNwc0S4TQ2JbmEJvWYcFlKaDm1VIk+fMpk1yQSHwUp0JHGD2/IRlbGu30oT637+j9RqdBHyVRhSdmjV8pzjv6dW0pLnew1hlW3GJKR7hbWuXgO1C6W9S2luLkQldYW0C6wXeZk9Gp6mX7gZh9TkerDrRK7/hW3rtZVileGZyOOnf6OFxnbQWvvAsd1Weuga3LPfjq4mOsuQYIjP7g1g5yEHYGUcyjSKgykK3Z41ZwxlAN0V5fn3eKVt4aNcmS/B2KnjM08X3M0xIIoYVDJa105DA3p4D/okQ9vUrbQuc8W8ywWyoUXRnNkjOyS63QG9Rh6gPxu9D58RqWg5tbLsthN4xuBwn8WPPnAgnoBFdd8spDvLCpdDMp6x9kS2NkdEeJ0irdRC23UxCjMRy2ghS7O8JE3BeKSY6duXjjjPvvtCAWVgMeDSQTsdTxzZh3meTHoyFEG2HD6oym/DG2HAU2yhXTLjb0b2f8LjSK+d2YtsURAYlGUgmeiS7fsGvfldP81twUj1T2N6XqvxsKLYwq0bFC2aIcj03IyVmcJEjdMfqIqOQ2582troWmBvbH6YnD8NwMGan+Aql+bcw+8vX4DJ3228jXSFVyEIRoEwC9DB37SNWQ8T/P11te1gTdAJmxRv0nbq9HDJ+UT7d88u+44UDiopBBY1vl4awApp3wIdbfoSeI2NBYHRXMBuvFXJBMWtQvxFpeigg+HkCJfUV/BJGDgee9X81I5kBeldl6U0p29VvG0b7cvFjHbDu/pTTxB6IXkyRaGs5CBYnTeAhMPTowBlLVJCiAkpB4yf7ru8IEEOZ+5j0KBTs9yGehFIRfkpJBKbB/aW4jHtnU2EbwKcySDbmTBykmToJ3LTECaimiArsSm2i+ql8aBzTZNKaQsukpTtxVDMtG1tiA41iwOH0BxBjrTwUblfEvx5+01tqTInn3SA0Qu3H8dqxVeOv04uWDEV0WBVBRcJKZAZ2EaSmmDF/9hFie6d31ny78B88MDd8lQ+O0oAHnbDmnl8ui61dBjZh8M+5YfMnQgzoA+ohXLIO9FcBh7T2IYG/lWQu0oSpzu6+Pax+snQFbT4cpCiGIW+IAT37nbwp/i535ASuJU17xVBwZlukofzZq7cnkI/ZVOxqELNvr3E5J8jIOB25+1lTNPM5c91EyL8S+1RMmJOrl3eNiahyoci1uOnMPM8iDSEtA5sLMRFkhTa22p2oeSxOSeo/o55FnWopAo3RWGYvVGZFy7EZ3Zzck+SvOVw7hDkKcokeXHGvzak56c9EAkOEY2rjXRzn8Icw1qXzZFXdfQDh6OAmSROehFVFh8c125/goAWbCJX0Hm3TEWyuiOyFWay6hoWV1NUFbd33/WG+dWnesNWmZKFI1dwrngeUi0YXy1TAcT8MYb8O5BEZRK/fTKtdgSrn5M8NlEFkwqE39mUEag48sxZb2JtWqhlJ76iUzKS0lLf5RdL0sdM1t46xrfODnGceK0bHjq0u12uDruEqDt0sGczFkvqX5xOQ9cCAwHpnGlp7+PeqotcujzDmVCZ35iMfCBoUoXfr1uPCJfzuAAnAwGijZRSbBD2Byt/CTAgNYAiwWrTBJjycBBSfGq1dygwOIzBIrt4Vv/O37HzsYyKfC6mVISJLEfGrY6B8MeBJIp2s/mgrt97r1Pn8uxVd201LKw/xOZDs//nOyCzeCEREH27owteor7DRSG4etZr3L6qDbD5TU3rLpDyeV96jwjzAySD1FwvJyI11PxkzWIz/gJXFeDmMF7eF+G8jT68YjOQR8pOAQLKZB0kmJCT1DyUUovvOhmF/oe75noKwBdHsRzQMMOpgmnQwaNdHGBfDn2Q8uoPN69abVfpSzBFyeJq2sjswkxKuIqvxMF6eWk7JQCNLycuiBvDhjcPVziTvnR/9w49MI3e3oyWU37FZSDlTH5ZrfbFT0tfit2VCk7FG7F5jWCvo2fMynQax1rWiPFG+QAA92pIepRWGAWMigXo8dqZv22L5NR6rFGSth7T13UkN/6IkrrbhdkcoS4ZqoMLZSdT8w3fBqIA7/PN4R3kGQpY+z5VM5rm5N8FyCYSaS3VC6aOI3VHJplTU02rs/fRhJwgE8czJHGXudJU0mY5NRSlnM/pWhrzvW1xeFm1ITg1HIKRabYK9+A3K6mkJ7gDCCVG/kO9XLWu8FWjA3HaX2SQnFbdwA1KCMvF1EJa4g6c3Fi3k7nuPbYgbo0Ui2UocufzaK1R8j7OmziQzmbW7ufyE2XhYngWdUFBJdyyNsb0BjFTXG1X2YpgmtWbn8QWS4qEBIuTqC2zVSfVRaaIu0jmHtGIWyDwbVo36d/wJ/AUFZCFuLLUqf+has6JLYx2gF5pzssazVo9N7YT1/jPFW0M1vdvEEOloJ72kD+P5lKU4qkVblYWb0+Tl7UTjFLAZQRvdCgh8PzCQlLoFeVk2W1ZCqQop17iW27mynRmzlqDXsnDV4ogG0jQ+wL7qhzBTHcx5TVW85CdLbq6ZX+pClufCngcCepkxI/UiltoSzbLlUy4Z5S8EAua4/CkfyXdnGdcNz4FHcvioGoZqrdgob0eNi63jRym6tREzkky9JSVK1NmN1k8L06AK6W/aMb+PhDjqLfeQzKq8p4emwFThK9K/vqsNghCcRMt5/tx/vvlpCmRM4xNG+SCTgdZHXmKbCJ5e436BwmxCt7NuzRKEZFXSblku1BvqqwHE23pERIFGzQVAV3kNcqaHYSh7oyfw7wmso5Hs8pGBCGS+de5yyBLMA+FO9mcQ7x7BbaiWT2jxy3a5IFUUPajwgOY2yljUwl5aAzYP9+DRCIHVmSUVfJUuXt8grP3/2GWWRDfshG5SZQ6Flxzpas/z9TGZepNQBdqMEBrQFQHXbnCBkYS9tzb87AGa5LD0BqBTzyhjnDv3sY2B2mgFo4qyYntiNGAUqzTIGKkHIdgc88a/ugNff2YI2Xaqr7xH4B1+Vl+7UyHxPwHKMNW3ZpOXSRyWSblOTUiTSgpNIvaRqUazLX90jPRaLN+2zeastxV4c7vOGlLFOxxFB5BWs9NKS61DT1/iV6pMRbbHR8ddIeB/y2K/hFHI57FxUEOdp3ZYMHSxaHJ0CZyKO2+lm06x/33xTJQbW8ZSm7daTH3cJyVuqbico9R6uXRmnQvazw55ysBA1fNhnzznkOi1OL00yLQ2UbYi5Eggxve1ebU8t1M4wmLkqFQa2OcW4A1c2mjoUItd/tg4bn9RoAEQ3jVC2zVHAaSNc7tCk3cIRlG2PBFJQZ+51Ecw1Idyk9P/IMylopQp8yCKpmokEC5nhsS5BUQPNkMkT4KDzTi1UdkLXnsylZwQwQkB3ZWA91dVFOBH+X4+aI7Pmeci4e9fyiXooXMBpa+v52er8cqCobYpS8GGIz8cTkV36oPvEzV2pPYnkis5xfTxYM+BTEVPt06L2nZHQzILojb+gjwzySIv6nKhe+xIgbmU/7DyDTl/UzAhJnQgHH9DoKi+rvRHsXG98SNN9TTDWh9qMJqbvlQT5gSixrhmIn1I0EpN4+1x+ApFdhtF33ypfOUrqxtZBX18NwlyANXvV0F01ZeYVBJR/PeSpshfbFHdeNSLrV0wdvjGtIQujxNoPk12R6z0731Jg8RgsXwKYrgyFgiJytwMADjD06XdJY04ZMLwch7bJPuRD6t1DQysPCZGQDO4Rgvn7u4AQ6q8+SW2BXBKkx/jSmSwSkRbTbtNuOMr87LQRsSYmBxwpRobxsXpPcoP+i5KvTE0bSL50gVIush/ns7+uSBiBNzotaW0V0E6IL6cU2n25ZK2rNtl+0EayoGVlLLp1yb+ifIJZg8eJx7jQwWjK+O9ZmQDT6FPMRsW1AUK0rGLmnICpi6Kr/ND/pmJHJC9b8LRUmmX1Ms5norG8XxSJfMkPDaqJHl2yonJ8GpjVFGYBXL5i0xasMtV5EKGT8LNzbaQtTpc1FuRet2jV8wJn8pSaW6zP5uL72P/rxachxjggwvWlEdPxLPnqgQct+WKMplhmt00mRRGdi3dKQ4fFAoXeJ3yKilTQYDXyuG2Y3pDyTxLp+2jNxA39yvDVqSP57UfMeKOYeZ7YiARLcprPNu7kDJL5gYvtwzvVb3/7DY6NpMwsBHo1V8sKvME01rLDIDeMypPWMUyn0SJvpHOXBvzC61Gty5srxDl7eipcgf3fdqtxmreOOgTU/mj49P8i3D72zd9WGJU2F7k/axas0xqREK9Z/S/IdhEd8noHzexxUL/P6GrIFwAWQlXbP/kSq4UhOh3ltVLuNQX/dWDQG7uZxPJd13K9V3CZXKUiowJ5EOQMREyDghIoSbY6EwnVGRMWa83TKtN9a+5XkdYvCHHWkyMTC7dDcZa4mvEmr5Ld+SUF4c96U5NFMTBhz972gj1Tvxf5yZ2Y7oT/kxtIvXG7/8SHcvhOzQNYbbstMu8NHG+zNgx+G92I2qrkjoHgXdWZ2xVbmUlEN+ipP77H1j55q8d9t4tqpFFd2OG9m7ykPTc4lGbUN5AShGhaYtoKOD3Hfip8nSn3JTXDqJVGFYjA48I5irWI+kcHpgpjmNlFDA5iA9e7Wal69ffDnINX+UbSqgVuNImL/fckJ4nb8bWa5hX5FEEO75naf8EOzS14MCObnjjuhVdPgdRsG92kzeCGXYi+ay0EGDjmCdxoXs1uA2iqp8+qOvyKtyIHJVzF6BqMMnpfzkPLJdTG9x4zCa0Yqafd7BrQiNT8JXTjgPWh9yijve0bQPq5Ec0am5gNsAbiRoyGfzqAz9Ycy1e0bCd8OVsmUk3ixCEf6FW1So7ml25J/PB0fCw/ByiT6819tXAFYFuyZ82V3pmWBVIUGSI3paIzeTpS9+yXoXta6flQSvcyYBQwHJCG8J16Wrgu7CCJHxQ1JH9m2pIUZVqvBMrDbOl4VTaGEVB+MXMXvYPdHUp1elAv3iEcm6VVY1ehwB+DMjrL1DkVM6QU6WOWmwffP7nkecC61l/kWoKEq3AoLJNU5v+pdtXrIq9szYwAismjH43x7ekFG0fnwPme69Z+9T6y7FgEcSMocia5x/hxruLgkAG3aoUnWZQKOrM2hGGzNXAic/IlSjfjQihU344vAzMqsYGA9TvJABoRPNlmtu+E9f44ivD+Oi8EukyKVYlDnPtGoKPTOvskSCD0H48Aw3y2k1LatrrHrd2R7dpGmz40sw24g80wbaQTGJxyy9JQUQ9FCPqzrQxRMgkaULwYMaBegn3ipNNVx5Fhw9icuCDV5Z6k8k7H08skjXjcvL/gJJggOfd40T8kQCoGnI49SIjPtCPlSle+MWX6Hm2UjNaz1hW/kJywoLIMK5aVGolKn89NA==]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190727]]></title>
    <url>%2F2019%2F07%2F27%2F20190727%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190724]]></title>
    <url>%2F2019%2F07%2F24%2F20190724%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+iXZQ3rQdVgvfUc1cR+RsW6YnltWj6G+i4wjKrv/OepuHsiKeebReF5Xu8BO9h4Gq7XPE7V7MqCI74TKG9KKM2pdKHBEuu6ePMdXu45LjNrS5vb2qcuQYLE/iSwrgB2OB0JmQU+el2VU4kdmBY+cu+axjh4paeTEkL9qCLqOGjQ9fh+cONNdfyJvXYMBiCHBOSQcD0aFWHpIYxMci2qA96bfWDjcl1LXLMkTyoCSGUU+5RHIjieQA9Qw6NOIvDcPQOFdQ2Gf4XNcbUMNa9xcHo+z/gB6KvVNx+jgxYBi3okxHFc1OPfRTvXmwwG75cn2SNBdlEJUUlgcCuvXJXzDLGA8XqxqV2bi6ineD0tQy4hy0yYsp7ZdQ7YtFImT8f26FQkiCWsHC+xRZZllBCzCzxDpjhaYfK7gZhdJI9xn7HiLR2CQz0p/+2m9UA4V54rp5QQ9dxKPFwDaP8OZf+Mxnz2XaMDS6gDxnUX6Pl+sbHR3YXghZMCQuIuk7X1vZBMZ8oHmMDs/zUCQrCCRUB7Tdx8N6e5djsRjJI1L6EquYBVnLEl7E+kSn4z07Zp1MUzel9vGdOMTNzhWwWQw8yTneCwrjMAzlAoD0Z4D9tQj8IKLtBKsUKiIuYUzYMXCfVRnxckLgtNvjzXFVuhkzyR7rYlYQDK6y0iTzygJtyGyzVb4zgJHkOlqLK0HzWLbT2dm0l1JU5RHzWNkxasVOSy0rTjG42shAzEmt57NQAqOP3wuhxIouIYUfoSf9XkyfaDh0BVpoek1I0pq1PmutMhwFYjUh0SL5PQqR7TUnjYIsplcLQoBoRJcKJWsFPAKRApUwhuBvHuGV48Lo2LSZ2khfaDZxbjkdOKbfn1t2YTdSs2A6FJiJ7ZuTfjHr6y0X3/KLA1fMf26nf0YF2czBdOTf67UOjIt5XBDHLQH0ujq3Wl2L7CNVoGkBFiI8qUVx/3HxnW5PflyWWEeFt6yLiuAF0GRIubWWheNO7+eTCCIed1WxrtuMsJAloDdm0F2OxRISG9drFNwRuEGaCJiCQUIPEBELRo8D1SDnzRykaQVPDZOpOVAqcymnJYUcelhZ9/KD7fUxU0+PTp8j/VmITmlNi15QUUuh0nExwrocJONu92mylBGwq9900ivFIgKZYmRDz+kiUpikb6MvebmXqiX9W4PopDbQyG+cZ9JEuS8RnhuDj7iSDuLE8NHJMurkahb+JPfZkx/vu08tOAk2VtiuJj5rYmwXynwiuplOVM9JQTax/606bB3l+3dDuNKkPL6oC/f0tI+ptYJNkT7A+taLyOdXEBWIwkI8S16sTpQwnUVYVNRgHCj1GV8VRR1CX3NOZIrqD9+z6r/vRTLqTG3AtFK97TG5nvKRIgp1Y26MeyOAGM5RHKCdhwM/AzyLaBllZ8CwVMPeSHvUGlKrrS1qmFpGXjNUElvfdjabZMDMdFZoSOwMlfYTURW0W34504koRfakftf2uXXWgf+XfGyfaZDnNv23NJxiIixrV+BURSltJylWZA7RNbKdsY5dYJrQkj4DlKLXbSq3I9np2arh3bAfNXcz8A1gjvaL9nuE+wcCJIJYISbPYVbNmKFf36kILaxPQdMXeu5edTNH/K8SqFd7SBXw6tPGpwurVMOc3MMQE7z1TcrdxyqrgdpZIOV232scXPAGakHy7gXB1kg94W/1guwUQ6IACQjfaxpcteKJPBxzq7hGuk6BVz8BbJ3D0k+lRMJjvjsGvR32qljOjNdJDxNe7ZjOYtfS6aStsVANgWOf0mA2gV+8opWbezOAYXFf1LsTEdMtOOhe+Z+YwAqghEnjbJjkVKtHJ2LwSYz7i5q+J2PpmkPtM07K0fzshkOrMFNSdbiuZy3xigY/isvL35UTMTlWILmEo1s7jz1AZWagR6WCYP0/ymHBdE0Ba2m65SXZ7aE87l3MrIBH+qpt/19/x7xcK+sBwcxQUTbAwmWon1EoGe97/OtbFyiWfKqTrqggpht45NQvqTQup9/PS+zWrLDVj804/fBltECpdUuI8A8n3q1nmVd7Clu54mDnjdVrG2jGsW3weiV3dQ54lEgK+cBxnaRGW9BI4J8MsK2MJlCW8ktzXQkMdcW818efoRLuTI7UdSEYhoyUpTPPJJH8bSalYh4xbumBpfuokDkZP80800JkvXcqntNTKlC35Hjyx18ueA4YCfLcD0iP5v8he0amb6ofaPFR+0EL3d/8uSQvrRReM6s7d7oInhSr6FooMq8XGQC47SyaYgs0ETvLM5nNx8cZjA8Nd6OaJDm87t7NyIRT/oMtWeyDi4g5B3/yguplPIm1rrhKA/iqcaQ5Paenb/FwK4bU7yyQom8w1P5Avb438p109Lu7aH5U+8Ks6YBO8WAiJ8jrshmUD/55etmlw6lgcrlPPNu0krwUut3EMI4znnaQLacD9eoHbbhlKNbWVWCSNrFBvYkLji7xUcPSoTQbIxRt/xnTbJt7Ke/yaL1w2CCFdGsq/4C4PbPhfz1riqdnGZeLJtP3zimgx7sDpVgU8Ne11iTjmZ77dkaXmI8QOQ2gELuDfDBSC8Vg06Uy6aRowssMm1q4ng7MOdRoziuwmVcAojoZNJI+24OuyhICvgiOjhb69Ul6VaMoIos2doUCMqU6QlaeCXN2Nh+3fo5yvQlOF4hSzWe9ZV8PIgPD5OjXrwmr/iyL2uDyvxGEQvs6dNbUkqb4F+oJ3rajL8JHeYUJ0K/AiHEE5yPTL1++dwVEqSe5wU5ay4kTcu6K9p+g60jIZ8hAS3ZPkil0HNLMbpX3lAFVxuRfJg8h+NLoXdCGo6yBnh8l3InwBtfl4l0MpoPbdGXTIA/xCJaPgi3CKuJWmBe9CjdIOY4fHJWZm0F2foowPDY6u+wtszI/LaoUOvsZXp22zC0z8g64AlCtbZ21bFBc9YfyuAVv5X9ti83e1kbx5WTVYU+x46fibd/fl85Rm1ENxZWI2v6YFy2IZ4TDyd/ZYpFvEWN3tXdP1ARBGcVztiHxA9vUTFuLjBDojaa4g+BaEsKAPkR0NuDPmRcjeq9IYtAKuzZEad/ljfuqErkOoX/ZZGT0i3UDn4y/2r8sr9C3DTetdkXxtsbOXzPYtpYUObo1+UXN+VwW745qpDHC3jBknE36c/PQJFLdfwuiNB5NNY5s8Bd9bia8kclSQ5gOKRyXhgKPc3ndw/271dpPOohdUvAtQQuNBqGPHjUljiLLHsLKt/d+NY1W/fMYSFC3FYNzC2Nawwgu2Uo9Wn9/jWfzgDsF2RBnl00tWkJq5z1zyKRZosux3Lt67Mcoowpp6yCHl4S6Cz88j7L6LvlWrF7IQWud4f0u4A3clR7RiodZXw506nfwdKOLa0xCZop4Un0Cm/s+3Xpf8ZEavOplIHOzyYRSQfxfCwVH/THyRw9HI6p0ACV1PBYDGnm1mVufYldnn6OkaeE8F2Bm8/NBDlSBVFDhABVQliJGJN5XLCF1fd7c8hetjO0jkXvH80x2H6waDgWG7HU3Iwsv+gXMkhLXKX6bWxaQaTsKPCaRdXSDoItzZMxN16OL0HWuXqjdWolyDohQlM30OXddGtuc67Ib60qGG0fSouNrYpIYo2UsJvFqSpFCzITg91I86qNEe8JKYbfs0sAJkX+VNd8BnrDqOfHYW5Ded3KHSfTN2xd3LnIRPvXO33fyE/Yf8JsvUs2zHl4sPoRIrImLBulnew0GDBmzI9Ro2Fb/fqexNaMgfsB6cEtYpXKv3hLtnGoBtJ/4x5D2NU767zrMyp23uD9mtYH/8ccpWBBPFxHEaizcqbJyxQF+GFw7nzPovkFXhZmEMPB+yfWj4hXG2TrSfe80o1vMC2YHHPD6ZC5mjubLhKix9bIEohUBoxevadhWW7Fdrdo8LF/2VEgZPbVfaBI+/XCsnGGPOfgvVyAh1CY9U2ANw7RyZhOiw2dCuz1yk0m2Jx7VDmszbEYl+TRepUNo4kc4L99GIN+NCqUdYf3omSYSTYQzZeDwAs3oK0JdJUr3un8R3bt7SL2VsW5Hch30TbMb5b4veDMXDIER3aRQgYAqf0DspEzCOBZ37svtMil0jnU2Ab33wZfNQehq4SS1zGxxRvb3oxdolRiYAzYnN4fTWwLmW/kqnv1HnviVIq7AJcwLjeo68NpUkXmGJXndh4oEJmH3ABCckeZbJ31aOqdOSMQZ1KPnJKlm5QAAs+UdvTxZRj8uUHSCLkbjF8DXdLarOSXUyOGRzq2nBvjvWQSKeE8+M3MmJO9YklwS7PZG1mTzAAJnaXZvIYMvGgdbu0Zkr8s5AfS1zlArC/Gk+psu1fczKPC1Is/bEDa3A4eCPpo8FV8E8EZU4o+td3MHSH8W7GJKeIMMvSYDky7i9FtStV+kLku5pSb8QZJ98N/DLmDw47yChILFx4eIfYPikUONsY7YMlLK20dlshLP+oJDECUfGXAeR1PIOtNqZytrt834I6qzU7Oi7N4Qp+3Q8ce3zo2Yf+k35G57UC69botrupvTCLLclfK7zrgKXA2dnB0ch/LNoLX6WAEq/nrWyVRLV0Yd6J8ViwzUeN9PCoirPb4CJpxMDyVhZxMxN9CI3lWOHWzHFf0WFKwJ3GfpswQGHUlJCOiN4NdNasqQ2RU9qchxngZnf6AJer8GhNypsFcM1qTBw4QVJsh6Z+MN8U9XFT9RSVEowQsww36VsEPuRZIzSz625ulSbEN3ykWtvU1i5+ictWCmJGNpwmPsy7Ef8iVaeLvs/94Ab6+G3DoCssmn4g5HjU5Ql8o+JC8x3YJ7AB9rehPMyOMPXfuXPm/9zSYaS8Gq8XZYz8lvFMpy8NuIXdpf6Dwkh16TrfUDnTydfGZSQJT6tk5zBr1UDd3BVflKr0DEzC4nIVYJARL+8GVM3b6dSVB+DDtqFrN2suYZDWhS8jMaeSsx/MAr3lLIAl094UdookbK9tcbfDng6+97py/4AQ7PzqNuTtJ4ctCzxvcPGU3BfSsA7tW+x/IRlHmSZB/EDOnJIePLxibUxvNILdI586QQrvAb1yAl46xrvEhh0ycriCq4mTYpb00ZYcT7qlsH7UhvTQpUAwne1K51xPGRMXRbXwfaMwkVJ3rVZYD3R7H8l7aujcshOnTltoPnxLvW+73z60tJn3An1HmPQ8p138ceLnMl1XBRDTRFO01MW5CmYrTRioNl092nCFTs9RWWrD/12wZc2mF1iwOeHOPEVeyxbMJ6XznBcvkWwrJfT6MGwalWfTbKBumrfEN8aok0y2HNSD8ORPN5PiSgObGvshcfJtBKanAZ4VsYSUGBgenRyatj08oUpaV+ZnelwfBpz1QEE1QXSCfVTNUquKcTctLci2Jv8RGGqtxcdKu72EMSXRQK7srprmL6jhyrxT7BpMXLL8Ns+8EUkYz6YL3NiVIJAK183hh2tQu+KY6OuSOAxI8AraUN4tVk/UIdk34BbbjnzOM9RpVsVza1FMQVB2Q7MHEKs96/btSJrzCwhlmnNqzPQ/Qm8cz8MH5gM3+/CZRAYiCRHjk+dY9UgjzLEpC0MLGzj2ZzNDqBcoOZIA6Q9Sj/5zel3bVbMtjpz6FykZvUNtD6jsE5k39IGmhtVdJBhibI6GjYrvMJfyZUlkuj2KFu4qEr+KAq69ci85aBLetc99UWdf5R0G2Js5bWpmGkmGlKKB6I+wE7B7MT8UZGqY+Q4iq6IXFSAISfXCS1gwir3jLMZ9CzZlDT0FeyKbgLukXRYxoKX2/7xOkW4P2U/J7BQRHqe7JNZS3oXnVghg2UhgrVjE6NUMQ1CwGoqPic/IwCehr1qvbrWguZMBMdT42jiPe9jrfbyFbXBuF/gNmRp6WSdMBi3gh1Bhd7GML/j0cOQIkEYB9FfmQbBTuCcznSIuGAymLUBamK+zr2HdZJuGHUWkE3z4meRjpC97n77pKLArCmDpzaTmlgPZdXSpFK1zN0jgI3v3nqXs8Alxj8Co/374GFVey5AuldCREsW3ah2naHfxOjXeZIEKoFBzpu/AgYlnMtuqnqNdA6XZkR385PTdPRgdQJC8z8DpYTwW32kYUi04fd23jTVHzdZeDeZL6fh2wgdRI8qcXnE8nGwFr87p4rwivgSCwiZ0+up9CwwGi+cb/iJq6R/GTpb3s3S4uM3no0l26PPPe+ZoPKfRnuGuUpwm7FxsZsiCvFmM+yQsP1rTis8+7UixysNxkzgQUDFzPmApz0WFoKdOpNkoD4/giFsAyz2vCv/ggeYKOCOovZx2BFB83NLl14QziEhIxCWUX8RlEQCz9/p5HNWBKSRMQDx9+e/KLcgI8zkz9wdFqMj9BATzJbMFmwNIMlZZRKJyIh2yGwFjp+TsYknKz5MNU9L7IAU0z3QPNxoyZBeVPs24wCE30/0LjOUpG/w2GHzaE+LondC53p4SvE8tIVNqyC9BjktQc85wthrf8KvDcYN4JDP7hhYtiXtHrFp/KgmhfVM6BbRIr5NHu1DfHZ8G4K9o4+fVllvjQJo2vIOFvDa5Th9zPgkZouKKQrhWK9UpxWFN4cDC1b4WcL9v/LjnaxKJKHlFOYEjFG9zMPvbgqRSZ1V7VlG2gP14TtoXhHAVl/21LYBKMuLoI8RK7p71+DyEpqlyGLUI5RYbm8JJnvVfhFAf0cj+PnpY1IsFV/xM2M0umK2h1OllTJ+C9AmquA3KMuzqywMDRBN0eJtzJ6FJ4Lk2zReYj9l5OB2ItYEw/Tdq+WDBFzW8yKttpQ/0vCZLswXy5/tfrR10H7HLGQ67FFga3h3XaFTztCOWDg2S07GvhNT8ztDQ5W9KN7H4nQEKhoCf7Sqgxdj1KgxUGI8rLIQqcv4nvcboaVJU8gofJk31cOZIqQ5yg+efelO1IZZthLAmKh41rcrVuEriV3vwrciK/ifHEsmAADkWVQg7S1kxA2/XY5he6uyUoe8M90zHvtkywRccvFw2ksvnEXKIg47RghYiODCeLJ5g9Kanf2+g77sWXSkQCa4S6p87JzXliQ3MwcOHimA1D3P2jyRR1h3+LrKGR4qJzSepENuzBQ0Xs2/DIBE7IPKQ5o8aXmKyFaVU6DCF5lwyuKrFHlxmGe6L1ZhV1vHH31Jq2GdRhvvfXUO7R4nUZ9qUDVVANyQj/nR1GHgCtwscCb9TuI2peX8uEp0IvUO2R1Moe9u2dQcgZVVcaBG2dvpmh1+FeL/2I396jBMAGuxabzq9Yg6NX2yFTNUp6RqGdhZh7oNgAng2OOA6ikC9HtB+JgO8qMFMtld51m8yP8pIBRotw6I1KzvSkO0oDqFjV0TR6I6BpDAWsOGmo1XDYXHnxmYkxnXJyyBwZoclPh8TZyuS3OJhagfxI9oaiUnEuYDIZYvPj8Jh2OJahXDDdsALbHIQ/NHNTVFDmU38XIMH2oUN2mLSsN3R+DdZkkq3ZwHqL4nLhuZAh/vdyHI/J5cnWnfCP7g1CHBilSUD7mFozfj3WGV+/uIf+XhkFlkMiMQI+iCyDVOc68AGOIVO0fp79q6HadXVwRY97z+HVI1PjuQlTG/3BGM3OuNVfSqqwkPU9lS1zxwrFCNHgjgYyH1wBkVB9sGx/SIKXqhXjyGQ4TRVwhagRzwYN9kFrrmEfbkdDHfG6A5gjg+nwNhXeuHCKsZ50lawaUZbqA9qqdOAQvphHQHpGzVIUJXBg6oiFdjUFVxzqAs6UpphLv7q1zBGKpi+YKBSa8YltZ70R2AYA7YakeXRRKfrDshEj+ClBkb5yluEgkHe/F8gg+PMWxv+Sc79DJ3on6ARL4ZqynPDyahMXPt47uEvowd8nA+01czoip/gsqJjyYm3M+ktlQC/4EgnIX8yq86Z865yQJrZH4+9AkAU9daED01GUefHWncBOlRjTStSFToo7nv4VctaEiqqH9upCzEHNN4wtcgELpqkHLaJR0cPvht9A4UZwj35g3EzolUaqViEerLUSweZFfOWAocI6y5zFsKZe1WZ7EgeFcLtQ36+3up6lX4D2n/s+vyY/a4qcA+iSzIiiyVrkRHgNB98fDOXhMQJEJOAf2fQIVIWoXCu6APZwC0pNU+/Drm6nALPtxwbS6/CcmHbD8Djvh/2YJZK8N4yd+ao+R4/cCpl3k/zZgM3yfOPmu4aPWkxnMJa31vjbMs3W9C3JjNPZmjjyNF7WGGlO0SAd8c59lj9PhChbKrEpqr8n8rKIn6z6UUATnIqDmpB4Fcet+QFKfk1NNzRLyosf030h5fRXdkbI7QbcpuqTO0b1HbkVzqS4lsVyRpiMj0ZJ7ZF3DwSPv8BXiVNMn51B4MioLvp/9PQROZec3U9vWpRf7iXPd1n4pPtQ5KtfKa8VBZ5XGUjT8RpWUlF/ik1HxoY/g+NCTMXfZGwWkjsdpQZdzsWjLmprDoOubVbUVuZXvUwD3TrXyI712fpEidTJ9uopaAktHdGzitbqnMNMeNNPBnzfboZI6ocr2ZsXc4uRD+GGRISbarf0MxwW2Q1GvpmH0AtUZIYhWuBHAaEaEL5TNUmLu/xSK9AtfB1/a9jFyaFZwpM3vddwVFyHCdDIoyFexQ2kbFC2cU6tk1mhs4Lhx6ijAcKg9kDo+mLE5syCBpn0MgblGri5phaEQAkaApfLaZ8LMXTTywbnGJ6kBnQQfy4Md3trXOk7gB7Bfy5Z5FlcEhe8gfXhodgD6dYuRz0lyDobYMNBFGdnsFPWmrEl5rvAbRpT0lkSfi3M52kPGblXcv4BJYpSQNnyDyjJKLURz5Ep6Dq7snsgPWtk1JW7Wq/r93NRzvteTSQsK6qsZ8UIK04xglHZzXepYITvFkkVrUbZzoPzfFb5Hdc/PrHriahfHL3ppH6I2VTHCksyQG+lhKykOS/gpDsnN5r3X7aflShLVhFAMkWuEataofyT5HldGrhhM5yeBnSQ71c/juYWWVdcMrEVz/6bWTjsFW3X/tMgbY0p86e++ECQUE/4xsKvy50dT6/pffRZS1elwgnHF4z9aFCsyvKClaXmLfnGjLSGSk3ha/EGVmunGUoNAym59k9YsfDZb2aPyykIbej3CO9UFa4p1LI0EwPi/cJwOpoX0HUY1ONKyxP+huczi1cLrqbwJI9DdMVCx5sUhQrod0eLWGrfSQ9CfklYxWnLGXjiNP09sSYDgtxWtTGUjqYn2INSmdKE3PIPGG39oP8B+1YpJVhIuG2Gx5UkMdRB9NOPMzVIwtlkVKC9+gkMS5nLWEoHbp8UAcFzGPGsL4X7ri4vz3SepngbiowAy2wpNGgS/Qx0+VP5OGlgpQBq7JCBoTK7hwmWe4qnD+Mw452Nv/sM6vFCYYqmzpYuud8ua00GQUeDUjy/Srb4ETw5DWV8b23AMR/uVcurfQDvPeojbvTaNWkGoCn4lBcupVboOQPCHTxeOTXQFSucCQUIqbEwHPsxsqhOGUMuBz7MQygrstfjYQyqkQ9Z0ylxnQ5SfofyOCeCQCPlMuzh8zTGW1lva7C515HLmOCayGv5pIX3T5EH7J5JmlJCOlQl75XeI4pIVcGE0iDyYOKXBQe6qE6/kU+ho6EobrdNvBjiw4s38a4kPS4ldOA+nzMGfqwwEjYhf6kgxPwFCQub9QcfWfKlJJTNRIBtdSvfTmEBwfyG58SoRorx1BnstSsFcENPinqWN5u6dRBn19aL0PaeLE+wISgvG7g1tOhPzcMjnNOB9X2uShVY/q2hHrUQtoylytnqQJf7Cg]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1168]]></title>
    <url>%2F2019%2F07%2F10%2FluoguOJ-P1168%2F</url>
    <content type="text"><![CDATA[P1168 中位数传送门 这题主要的思路 1.因为这题的数据很大,常规思路就是我每隔两个就sort一下,然后再找出中位数 显然这样做重复的次数会很多,一定会TLE,所以需要转换思路* 2.所以应该从输入的时候一开始就进行插入操作,输入1个插入1个,然后以插入的方式直接有序的插入进去 然后插入3个之后则第2个即是前三个的中位数,然后依次类推。* 3.然后考虑插入操作应该怎么插入,很容易就能想到用二分查找的方式查找到X附近的位置然后进行插入 因为是进行的插入操作所以应该用upper_bound()(或者lower_bound())进行二分查找,然后再进行插入* 自己遇到的坑: 我以为要输入完之后再全部进行输出,但是其实可以一边输入一边进行插入操作 从而降低了时间复杂度。 代码如下：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;//P1168 中位数int N;//N表示整个序列的长度vector&lt;int&gt; val;//定义一个数来存放int main()&#123; cin&gt;&gt;N; for(int i = 1,x;i &lt;= N;i++)//直接用一个变量x就可以代替数组 &#123; cin&gt;&gt;x; //val.insert(val.begin()+(upper_bound(val.begin(),val.end(),x)- val.begin()),x); val.insert(lower_bound(val.begin(),val.end(),x),x);//上式等价的写法,val.begin()被抵消了 if(i % 2 == 1) cout&lt;&lt;val[(i-1)/2]&lt;&lt;endl;//因为存入vector中下标是从0开始的,所以要用i-1,(i-1)/2即是排序好的奇数个数中的中位数 &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1325]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1325%2F</url>
    <content type="text"><![CDATA[P1325 雷达安装传送门 题目描述1234567描述：假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围d。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。数据使用笛卡尔坐标系，定义海岸线为x轴。在x轴上方为海洋，下方为陆地。样例1如图所示 ！样例12345678输入输出格式输入格式：第一行包括2个整数n和d，n是岛屿数目，d是雷达扫描范围。接下来n行为岛屿坐标。输出格式：一个整数表示最少需要的雷达数目，若不可能覆盖所有岛屿，输出“-1”。 12345678输入输出样例输入样例#1： 3 21 2-3 12 1输出样例#1： 2 这题我的思路过程 这题遇到的坑 1.雷达的范围,以及坐标值最好都要用double来确定精度,否则int和double混用来进行计算的时候往往会出现问题* 2.这题的思路刚开始有问题,刚开始我是把所有岛屿的横坐标作参照进行排序,但其实这样会漏掉很多种情况,虽然也是基于贪心的思想, 但是这样子会把横坐标小但是纵坐标很高的情况排到左边,于是就会产生误差* 正确的思路应该是:因为已经知道每个岛屿的坐标和雷达的范围,所以以每个岛屿为圆心以雷达的半径作圆交于X轴都能够得到两个坐标 此时这两个坐标即是雷达所在位置的两个极值,此时按一般的思路从左往右从小到大进行排序, 把所有确定雷达的右坐标从小到大进行排序,首先确定第一个雷达的位置为确定第一个岛屿的右坐标,num++, 然后以这个右坐标为基准,因为贪心的思想,我在两个极值(a,b)之间虽然我放在a或者ab之间的某点都能够覆盖这个岛屿, 但是我如果把这个雷达放在最右边的b点的时候能够覆盖更多的岛屿,所以我放在最右边的b点, 判断这个b点是否大于第二个点最左边的a点,如果可以的话说明这个雷达能够覆盖第二个点,说明就不需要再新加雷达了 然后依次类推,如果这第一个的b点小于某一个点最左边的a点,说明覆盖不到,所以需要新加雷达站,num++ 所以再以这个点的b点为基准来进行判断,然后依次类推,就可以算出雷达站最少的数目了。‘* 3.第三个坑就是雷达站怎么也覆盖不到的情况,即岛屿的纵坐标y恒大于雷达的范围d,那么不管怎么样 都覆盖不到该岛屿,即返回-1 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;//P1325 雷达安装const int maxn = 1010;int num = 0;//存放雷达数int N;//N表示岛屿的数目double d;//d表示雷达的范围struct Node&#123; double x,y;//x,y分别代表岛屿的横坐标和纵坐标&#125;;Node radar[maxn];//定义一个结构体数组来存放岛屿的横纵坐标Node coordinate[maxn];//定义一个结构体数组来存放确定半径之后每个岛屿左右雷达的坐标值double cmp(Node a,Node b)//待会sort的时候以每个岛屿确定的最右边的雷达坐标来从小到大进行排序&#123; return a.y &lt; b.y;&#125;double rightradar(Node a)//已经确定最右边的岛屿,算最右边雷达的X坐标&#123; return a.x + pow((d*d-a.y*a.y),0.5);&#125;double leftradar(Node a)//已经确定最右边的岛屿,算最左边雷达的X坐标&#123; return a.x - pow((d*d-a.y*a.y),0.5);&#125;bool val(Node x)//判断岛屿是否超出了雷达站的范围&#123; if(x.y &gt; d) &#123; return false; &#125; return true;&#125;int main()&#123; //输入数据 cin&gt;&gt;N&gt;&gt;d; for(int i = 0;i &lt; N;i++) &#123; cin&gt;&gt;radar[i].x&gt;&gt;radar[i].y; &#125; for(int i = 0;i &lt; N;i++) &#123; if(!val(radar[i])) &#123; cout&lt;&lt;-1; return 0; &#125; &#125; for(int i = 0;i &lt; N;i++)//计算每个岛屿的左右雷达坐标的极值,并存放到结构体数组中 &#123; coordinate[i].x = leftradar(radar[i]); coordinate[i].y = rightradar(radar[i]); &#125; sort(coordinate,coordinate+N,cmp);//以每个雷达站的右坐标为标准从左往右进行排序 double temp = coordinate[0].y;//先计算第一个雷达站 num = 1; for(int i = 1;i &lt; N;i++)//然后根据第一个雷达站的坐标为基础来进行进一步的计算 &#123; if(temp &gt;= coordinate[i].x) &#123; continue; &#125; else &#123; temp = coordinate[i].y; num++; &#125; &#125; cout&lt;&lt;num;//输出结果 return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1182]]></title>
    <url>%2F2019%2F07%2F09%2FluoguOJ-P1182%2F</url>
    <content type="text"><![CDATA[P1182 数列分段`Section II`传送门 题目 输入输出 分析这题是要求最小段的最大值，很明显是要用二分思想。 又因为这题求的是数列分段，那么我们可以使用贪心的策略去求每一个值分成k段 如果k小于等于m，说明我们每一个区间对应的最大值还可以减小，否则，每一个区间对应的最大值应该增加 那么问题来了，我应该怎么进行二分？ 我们应该把每个区间的最大值进行二分 把二分的左边界设置成为区间里面的最小的那个值，把二分的右边界设置成为数组中所有值的和 然后如果以mid的值来分割数组的话，如果能分的组数小于等于m，说明区间的最大值太大了，应该减小令L = mid 否则能分的组数大于m，说明这个时候区间的最大值太小了，使得分的组数超过了m，这个时候应该减小区间的最大值令R = mid 注意点为什么要设置二分的左边界为数组中值的最大的那个点？ 因为如果直接把L设置成从0开始 n=5,m=5,Ai={5,5,5,5,5} 那么如果把0作为区间的最大值来判断，因为我们是用贪心的思想去求解的 区间最大值为0的情况应该不存在，但是我们用贪心的judge判断会继续分成5组，但事实上，不存在分法，因为没有一个区间的最大值能够小于等于0，这样就不符合题意了 同理右端点也是，不能设置成很大的数，而是要设置成数组的所有和才行 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;//P1182 数列分段 Section IItypedef long long LL;const int N = 1e5+10;int n,m;LL a[N];bool judge(LL mid,LL *a)&#123; int sum = 0,ans = 0; for(int i = 1;i &lt;= n;i++) &#123; if(sum + a[i] &gt; mid) &#123; sum = 0; ans++; &#125; sum += a[i]; &#125; if(sum != 0) ans++; if(ans &lt;= m) return true; else return false;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); LL l = 0,r = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a[i]); r += a[i]; l = max(a[i],l); &#125; while(l &lt; r) &#123; LL mid = l + r &gt;&gt; 1; if(judge(mid,a)) r = mid; else l = mid + 1; &#125; printf("%lld",l); return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190706]]></title>
    <url>%2F2019%2F07%2F06%2F20190706%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+3wT7ypgSpFB8bIm4eafN3zvG+gGBJMudhXrGKCIJP12mEH9lXrEUk4JizoZWAoMMUDo10EnO95m+s/bFGoUWjRVXC8JQNB/G7jw4o3HjmagVVNaAaALTVer+udJOQqX+7ZeunZhqvPZ+3esWXc4ZjOREPAYfLoVXqMVvpUBnxBiTKT+vlTrL7xw08CXGX56fMiYjfUDSv7c+SGoFRMrAAfyKYEYpbWyGpP2SjOP3nRPuzRh/gcNhQgFykDD5zMz3/183ewGrxLgDvbsXoTwTVj1D6n7N9+20YKKk+GbHkGlehFbB4ZQFT6i6MssvKgKruHxssfMdPQRXtY4mMT1fjlptgLdEQk+nUko8nGiaruBrb38JgMzEliWdRHWJxC3+zaNRjUNVX00KGU5FQfH+LCVLc3+hvZFY+ov/dCfoK0vX5YeSc437x4VCgPLW9uMGnQeGUF/9SyBNNjCgU1SHdxLYDUXFik/1kx6zGB9NJT84p3byjz1/htGxI4YTtQiQY5UBvosKRP+LqJjF+p/8UhnHKewaSIwRZWvt2xdqaYPBjZMT9IFw8PJxcG/4yHBFucThiPYFuvuH4ETTsG0MbpRXufl1lg1NTUyXY43NhMGuKdo9iuvyBgUxC8PdyXV5nK/stZLjdKJXV8A1vAFYSCkxJ1XC2lm4cYEem5HZbNdIK4D4uNANdlvd3o8baSEc+ATrWGTm/qcfIfrtDvFOGTFmPuz9ce16+cDNPl/yz/ccsIwP8pr8OwFeln3IPhUpQ4CK1LUGzTyx+6iucr3SrAd40YgVrrr3tgUTtFjcs29zLKADKmpzMp9b2UBc83i0wMY+wmi7Sc0kx/tU3mYtxYlRtaEqjxDBKBa5KuFQeutfG8OQo7pUSTcLBKJNxs836v4o8OsfMvH4vLbolQB5m+1nitNcVc8U7WcBJhq86zbOJgNzjJHszvDSnr71+hv/7RUVmmFckr8AeYS8fVPff9TjYR0f39yLR081CUa9cwNbd8TEi3Hy9RwNe9sbbC0RC7BKaE0zCrGKQ399+dGBz7isnm98C3bbCIgMm5jwhXa6McnkLYVGDRsSfaqUIvk31Fhj149wwtfGd91GmDKunenaV2LDMwwAD6at9kxmte95KViUvG+uMTpFuKM0O6BLIEED7G0euYfmS2NGybIE7KHA5P+h7XDxwoV6zM2clGW5V9jU+2ai5PVDJf4HwD6E/cscTKqH20Y2DxY3ApS5zpRJi/oidbuAGAbjHNAf/zs/hOPFfz6+NYkFa6+eif0HjlUYMbgly6Kj03ovEnZGTHu01pBHLTScfXuTEcTi1PTyyf6oM1pQufAvqfPoLBIZuFJP3Olp1gSBqz3OudmDjKhxJcFajXG5hrTAwDH6yVWUZxCfLM/URVcBKPd3w+OcwAKgNWSy/1i6CB0+3p1+GEgamLXSX6u1dRQi12771/pMS0CKyVmbXUh2ZAxsoqtvorGFSQjpb5puESK3DuCK20G7lhHOl2QIgKHzP/njrbUMDoJ0ZXU3KErSIgY9CYmWUkEvzPRWcUadYBRjTIbG/JK+N522nqH/I8RkfyB7rYv9Q2WhsnJQVEUHTpuxMIaQyUpzlkqXCBCInlT3S8dsXYvyKq0QLuBhnDzeiKlfWhpYkLkaUWI8lB9x5G6PH0knaDN8/aaE0XhrddnkyVxMj+mRdzeoP1tnGfIxWAd8zD13dBRGYteNqGZT6QmrLdbtBrHZORriUYMrYzVlSvDBte6H4VbBL4kTPHIb6bYaXk5MhMDLhZQWdWoxP6SO8UEmi4nyuZs012sRPL9tfXCFiG08B4we/tUUQKaCuaqYBIqMnllLdaQkxKsXfbQZkayPu5OPwOpSa9IiQ+x3sF+1AlaYvoXDZ8FGi+iRr23A83Sh2L1DppWjrx8QSHbH/Xq6NhkWF4RpzggsRz3Xz2GmXOyMvQ7lB+oDyjk0oB6byZ+CNuHCD+fa1q7Dy6auwcM+yDNUPnprALk9pD/44Woi0Sgn1CjoSX2ulxCpDxkgxIVEiDsr6cRpq7gGphsKrQ72UahmONhdz0Wc+sFgFr0KNorGYKt/hi//ygTAumxVaQs1HarkfCYbOaV9xZDxe9DiwLpY/M6XCrV9wpepxDdbi4Da02bHORo9VWs3F8wjZnSNxyteBfBn7oUM+kBkqE8IhyBc9mPe6O1muUjnX0C5vcndo5cZFv1hCbtkDjDflb+dcNQsga6O4RYqMtRHF/Hn8JGKBt2gPlyceDLdeTyXHyifDwm+iCD/sN/TWSiPH5wUhQevFXJr4H2vZLXAINCb9xVcgRjkOwYWif2A5nM/X8N8Bs6SSULkOPQLF89obMiTSIIG2inybtO7VZnnv1V/Y//YkXxO0y1mTLnXQ9BKcH0/vSfNCt4erNNXR3Yja/ldltqcCdyz0VnlZsQxeIMeXs33aYMGMMydoV44f1J8deNgUCkf1go/iWY0H/yk6GPdnnj1N8VbU/LbaTsx1nMzdtiDuvN3xoV2WueAfPTQhNFWKUcLYscylQRL1ou06oUxd5fPLMMGELKaf7VYm8S8z+jy61BZMMKAD3Kwp6+EwaMvz0+hgOlxVWKZ99Rrl2uuFmWGc2Qnmm4yZTUJORH/TuxrZsyFarkPeja64OQlLNSHKo7TPHBOv2Fyq+zDLvGYQLU4BWno5eVz6O+0K4WDj7NLlQl9Hs945Ud0UXErQFr22rsIOijiiWvirnkqUzyjBAdbgzdKMHAf7To3ivpjoDkrDVnvD/onbbNfBGT+7D+++2KaXzz87diaFB6OwdBxYv/s5bjNEqSLVPMit6jm0ZrwPrG986vhOY3UMc8GPWvszWFeP9vyEzFPRjn/SvFGqXIZ+3+TNLXTOrp6vwrkGpUXO6YKpFxWAsKJRGbpRa+zKAmjplSjlCCL5KS1CYdMJV6RFj+brujS4ohQhS/Qiz1HwrBBqMEv9Qosr9LzU6042k+hVGybQf5Umjo6Xs/b+lZ3oDk80hktdw/pNkTGViX8Ck027069VUD5Tydc/kPITQbKlSYZBqyoXyxqxYG8Z65fHq2Ct6/VX+k9GXxP8adpmX8Y+0qpgDcX8QPSZyss7658GD5ADKmtdraU72R2Ma5k2x0qS7q4qq9wubWYLMMwWslHt3MaqnTs2gK9lfParYeZTcq4sA88mfTpWaa8+afKWiR4+xjZjoRqmh03BaO1mD04m3YVh4XccWgzxrURDeOv3C4q1rJIreCcqkV/YKhbL6VUNDEpYsYbvMBLveJWKj4tLGba1lNHK3R93NwobgFnwRPlnh2pO24SvB2oTqYW6G7To15LGH6kSbTnd+KHQ09wc+kPS/7MvYy0kLPA+xzc6bf/8XQGtpcWTGbBaW79qiUbeiM0u2K0KAwUJtwi6ylii65yqOtg++IwtP08F8bbQCfTBU7rryJ22afRvnsTGZf1S/U0sRuTgvCvHQMOcAnlngZyFtuifteVEFFfdPqvXcoRc28LwntOdeScW8PATCl6zyiYlr4epnFztpl2kAbEt6AKZgFbNTDUbFVtj4PcUGlZVpWiSpAYNlAmBlXkfFveMXFgabm/ZVZvQomAWFRwTz55Hp0Z7mGl2BqN7GX1WNrnizxuXlP8SKpDP1ZkVKm7y1y16eSmdUHuY5kuXd8bzr9pgNJEWOnjZnsWW2fIWwW0iRhVjDfAlBkt4diM3RCGWLZvtRSqQw9K/bSdVIN+SG9vU67BtsDGSbDkxSsS3xNYAPOCLTz+kutl9GJRMGYoiyA+FjpIjJWajYjAiy5QWU9nm29gc/PjnemoqLuCGHrYwNWLcg/CCbsxr3YoZbwEZV8WaQt0ZX5ejGHWZas+2Z0OavHnRzofe75kz3ucuftjmfOBwLl97ohbNrqbZoF749Jkna8rJwrdU9mT6lHKro5MXv7am67rg6Lc5qg8ycmoAaN0RDlGBYC3UKpMtQZB7n/OotPmEolNHJMlU3K4OZAq/eHmYl2/Xb4SkYfWPMkkt1lX7HaFEPVUi0sFruU+hztEnbFPiZkexSRbU0Sl8i3V3oyMKkTfSYMLIKDg0031R8katVo5gf35FJPg0qEOabIt8y6T5yW4f5yZh27b65isXO10ReJVP2TKQzP3ZGZxXlUdEBbXKUyY0IJI0ugeq+A1zltbAzRDshMLv6kDgJEumzkPfH9uplEAhp8qVac4wOih6yjXi58gPLnU9jOX2JZQTD8vZLvzc/+/Cz1EUmmirp8XN5IZGhRzqzW7oxqa6dqH+211sWRnXyhIJK5sXKQsmN+9E253FKFznjSHLwg5lswr9qBjmIbOF1obm0rfVoB6orF23CTDTwQke72NOTzx6+gZLzX0fPylCYsnpPP84aZkph7egU47XQjwKLLA3Me42elHm5859GAgHZfvUk5pXe8UAqK/tX3z71C9qHal+UNyKOuxplmWDsQBUSVqrDTmOvubge8VbW86lwh8Et8xndnp/UBlCBTtu+N4Itwcanh8Z3T+TlheheeCSGZTql0AJ/Ru6tUlWIsnzwW49R/DkQ5Ok83u1apBacwZjMKlcxbe303+TVvWf1QqfRV9px3XJu/f/3SXpD9zvKaUG0WOmsj1lKQuj9777XyCnrvxEWBuFCeYxt6gmD+kwFma8UJ6mZHlQRWXUy8y0Jgc9RbI1cYe8aRE8LA+qR4YTrpe8Bdr1eVaaetUEdlhCvv3Nr/W1qD+GnJKlIYKKbBfmIdr8Y/c4qxnpb32pt6MPqQ3/me4J0Ptt5v3lg2NF4dck7ebhCJJnQDHcPaqvsjzF7PoH/8S0clyb/wMwHC664nWXK8vRizHjS253+Y/FAT/ARtdDvKe3avYWq7NxkWNlwlSGj+Hnoyv398E9ud6MXhDCHTRVxXng+F3Ycv/1K13JvyIJol1xOG2pUL22f4CEnKtqf53RuzUTrWH5X5ml2GJ/FoYIRaEKYFx+GbF8htPLjERktlTiemHHoMJqz6KyqelDNxJDIyQiWcmeedufBNOX67oIU7WxX2t77fBwtTNcnZ4VobQEDpVpQY1Qf1a80PdTv81J9CWxSlfqt0QzDPQSo6wJa22yCf1nkb/hZzTOiy+kEQj04SCvAHfm/EYeeC6P99NAq1jWNYdvg5PpSQGDLAtfuvRoiyLPigAAcrSVJr6/giEitiH1M3iTv9cza8TGeM4NR2N7RgkwKvWblpcBpWPY98bipAnBwn97LdKRBjf3/azwH96suqMbQKBo8gDQ1KIEJCTkeBXQdW5+kT38CJl7CbwAwg0L8vc8QPqIvPE1Xmz8v6Fmx1tZIdJkc6W4p/fYROQHoM/rLAquXMKbLhRDnB1RGmqTqSyAMEdaD3PFsF5zzuiMWv0eyqf4Gjq4zgajXgPZJ4Slq11UYGKzHlmVszXEOlP7g6XK6eWm6PLxNr5Ry995mbyLoEVJz+l++ljAKGUY2ARZyCsPklPdoP6woNso38PQVK1GARG9QjPx6LkhAHoHEPawdH70pmAlEFWEYrMUEnh6Y/aT4e6qIs/hffdjMIVidsxMGxQPvAUwi2ijazcp0wYlWFQdddNLuva6GPIh/6FwB2015bV70B0HCoL7wNHgZfy5u2/NHLfkodrGFqY5gJJo2yJqOsn7ugiJiNeNqIg0xCv4577DBX0CC/JtgbizVGsswahtXywJhqG/iFPg4HKLDJgGBpK1z6QnC9UyJgwbjsKvYut8tRH9RfDPDOhmh4B9UVNfZEGPEVyw8CmUFc3dlXUJ3F+WwKLwZyqXRzJxDN3v3fvqEEyUQzMQxSqvlKRjnoIti9jhjtEy+pQMiDszOhFiRoe536nKeUAH3+NltUMttiecN+vBqMDiFUVO4gMqMsULXD10b1UWb/K4FqwPKKY9A+EBTsI3KhFTHZnMJaJHpYGW0s0EmzA5VFlKOOlyXP/eVb7k6MWzg091EiP+4QGbg8G3tnNYiI6M4mqlfRLEkdRFzxTwsmYRF4nOQB+nhFzL5eLBzmPG4Q0LHDDwj9LzViRwvXb0cFYrH0SszRf6TiXkvooOxLtfwA56+a7n6QjD0nX83DqOB43RVREsPwi0S168svZ/H4cvmEJgryUcZphp5HY971/tg58Pvn/GJlGTzcrdbQPzgGjPlxpk9KmYCvbfcxCGooudKuoJVUh4YoG6W/49yPu8witFwltZHYlm6RM+Yr2cpg/FqMD5rkh/NDq3Iy0OUvqFkUlgzEbdmSt515Yi7yBpt3Z7NeOnxguYy4SD1ZUEHBP7hQ8N0Q5pX4e0LUDfTcUCSMWRk16BQYFUohnTTEA522bGwoGW/SKlWSqKTDbs36T7Zy9fSM6/PwlQN1FLjPr0EeWFiYpgkypGHJzLFIvvoKgZ5DN0Upxqgl5IS0DaH9qOZzfjfhkFucuEkouRCud1kpjdp+idkNeeqSUO5OQn02/lUbXa00IFLZJwVvQOOMepjsoJGILXmIzNbLnUloigjRzI2XS4D6xEA5qYQVVlvDipxmrQy84dZ2z1X/WUJPlQgQLQ3tyNg0XLMDViE5eaSP5/hYgNYJLcJ5WsqEeojlSq+8Yi1MjyuhuE1GixBVAQ0aV7n8h0dH+Qu6Zo/R3lkA6U4pTftF9mFaAvSMXY4I0m3suCyiEs61vbP0TBEHNOQeHvk9by15zZ0AkW/ohBeriYBRvF6+qHcUb/gMZYsUCbu4ELImtOgkeXU7KR88/gHG7zRILReL93EHxKkO6K1VyU0GOkiOVclTwIAgSvrE/44G2VJEs8AZgGEDN2ybSOdV3yaouaSkhaJ4aOWtyawmEN+R1S78KeKBw3H5DpI+p4saqHEyLolLyjS9SC5Z5O3ldnuY/k5kkD4ChTIc4wOP5Zw9sDIwVfgWM3sP9HRkJRTPhc/glAhPlgiJG3EKNuBOT6rFgByAy8u3WxlZw3wJly5I34qA+QFlZ2VSZICOog3lqm2GKoLWOi5+SF+gflXbssE1T1fWjRYtziUymlogDdwPrM/Af0Bxo4P9ehsmpkuEQV+ZMDJgSDBhHbdRWIyZcZ2gahPDK66moRlKwBGBwj0lt6dDsZCDpenzNEN7GoTqZ5BzuVxBdBXknlPOjSxdnLukZXr7sqH0PrRvIO7lpB+3RqChZ2elVM9DVy0oVFQ69dgvh1UUsB6OQ1SKCfkcpgO7GOv0Z99Gk4Rhr5UpSz/+W+E+uvI9In8ZvWHL/mxCSqNy6FICw6uDxm4EhnVJRKNQ3lfnjSbTHnLIhHBkAyC9VQg8w38VjVlNLlPwsLG6XTX+AXKAFJIscDidtnCEou+/wwih/CnTRiVyjrxflJ3Ay1agsh3nOfqn6LVpMI2Kveu43FkFH5kyhzLweb8r6Ct7Efcdvt0sqmYGQepy4GjwjD4D/uQVG2oL3uAG0yqauKdr+Xei0lE6v1RPxv+XkQ+b8+TErfYCxqnXcXM5p0g19fza5TDOGt1jB6LCa/UhuU+g9duSu5EQt39nUaD7TjOUlRNAoyH2SRNrMQCJL+XScuzY/1zmfnrGGxzajKNonXp/MyGNWxqAX/y1cauwuSPMWLBdsTZ8ves5Wl336vH1LcoHzn5FDzgWyJ7pbUrZg6ygPdfTUCnLUqWqnmMaoBsa5/UddcLkqJNIPU7rSgUwJjYOcHZQvPa6Z16QXujC5D7rqfXwolPEWYxLxyYGZW7c5j5BlaA2oPErAtWsAiyqodxXtIpFe1aGwaH+Dq0GNCi7lJ9YgJGJ+xMcaq6OGFSZFTzCWF8vUKSqipdW7ri0d2WdKQ7aaFdP7JmEYxqoAxTCk/DD8kufK0tUwufe3pJB2SPuF+9RLTXFREBTxKF2BtQZEbxqR17XDG1iq+Puk+/yXagW7OvnW2hhExUsfbVTbdwEWWFeAKJDnDOjoBhETu67x2A1HU6SL2C1lY8hFzykg8Kxa1P9c2L5/cOGWQj54kwCGgBFygY0q/llaroZEq30Z97RfruQIg2edcj+oE2GjYa4S7tD5BZUyLNegAkRIFPu1NRB3xg2QxCqzOscKl1J0SZk50Z1TVauTyIfatmZoVbdrHQwNf0h/27jMLtyeVwnhJUM4oXUa1D16sv7agBfa/ZfHcZI9Fd/aZjS+BZ3TVfEDxPeENwpniZ0Vn46AWRLLA9v2ZlALAWTkZw0xeM86UPdBBfCkbo2UjUhE4Id+d1dcdRgU/yw2Mj68BaHTekiXkHV0IPSFMjbAtFccTNhoZsywDkjRSsKCj9jLF/DMT/onsMisQyG6zYJ97TCcRHVW1VoMZj4xxgSvtTKb25JXAoTTBuaoKUR6d8LLJLD9PU/ocMt7Mr9MAWuAYxW7orN0niGdxoc8m5b/Va0WA7AfN2InQ/9g8BoMi9+/m+ODUzuVzCoYzraQykNxOuYC5L2j4h7omwpy9uBzWaSpNFA6+jxYexGkbS1ZHMCZNvEBz7xvwOinq2AaG5PxvYES5SiBjDDCYUrNXZdnhKpxyVyLJmbSD4QYsA9dOKphzDgIZut5Y60R1DMzMz+6sQR3CB6zxdCtn8sD0gVcDGXJkHCSvjsSNKU92Lj2Y1nwQGz1O+oFTrDzGk986dmCtBjjtRWrJ7z5iNKVqHSH3pqk6D/bxMhtkn1MlxTRzfIkEMu3EvYMdpybkQWFS6s2GUQNFd9XLvX/5swboQSFNWOqt44dap89YJt+cEVeErWDzzyFW/BB2q9r2hIuKOdWHLUT/nYN5LCSXxtoMrsC2kvJrQTOgIjGutQXgFU5xaAuX/n1591rCU1tUrSJP83Ikkwe1ZIkVkABoWHnkEPTFAhA9klQHYOPX6PVI8mA1ociAyTK8THt8koAbszHvK+v0C2JDS4D5BmzGUbOO14bMKxZak2Q2a/CpfkWC9EoQpSjaRkeuusjMTS6VgehaBnzRRUXtiIWFf12v5TYhL/hlZud376Yc4AHI3c9PX1D5I86dwH0e4dyDf85pRnnm8EenmThJzfYU1v+EGEYCZBFuHAHbEXIIm1SEOhRojLkSdRwyHPJ9j6ZXeHxCkC1opH0W2GKvXMLg44JzReMfWwLFSgCrsaAt+PJ/1t7CT1OFG2GQU4GqFSIPokoYQSbRnG/GIfAsF8QwXhruAy7Pg3wBP+qdpkXw1q+ZOLtyaV8NZU+RagwYFUkV3Ob1gdCti2J2NNaQ70Y9YAD8PHwyo/yQnxsOsWGJemz2I6ABqAX2J43wXk9aEkJV/M2jTHHJh24wQb8hhpXFeB+4We7G2Amts+8CW5OCy2PdZrB+pFpQLeUaTg6piZKfhojhNrVay/CydyywhB/Af1EKzUyjnvONnC6TziizZQCktPA825/sNzZIG+0nuHosrPIpgAMqYZje+x9jOs1x1rgNk3pjtd7FKjofYgOG6RRIcJVEIDgTNi4JAZuVSGDmDB3OP5Yuum1NO50J1KriljUCYqN9kT6hqQYMlKcrQG1Zg9qeXXPyd2P07QU1F3Xtd+HIRlRrSHB0EeRbV2T/fMqy3VYxB1OQvPFv5tkeSgKvV7hK0R3zb1dtyHdxmQzE7+12Vy6LK03fJlVwx68joamsjWq6+VkI4TTTVFd7thZ+NrUHpMuJwBs0FfYmR9HDQRO00cudISOhVrdtnAaKE0taPS4+vBzXtilMUHoDtRoQDx0oiGUykdryK8nta4PK5mGZBiflbhrZZnAoXt3E2k+JI3r3vwa6fFuOfHvR2PBsA0bIMv6REHJvuaFfTdhzeTNTB1C02FgXbnDPgJFo3BcjAicpf6zfKoDoyinKFjUuT7qzkmmIrnPMSawIj/76dVFSz9WIfp/rfUdqzG8u5dVW4Dr3PRYGhso5j77AeypzZtgqfg73bfFe4R2ggRIoTVGALw55B2/INCYF9lJgQ360WMEFxty1VYz6we6yO2/Oj4FsaywytJRxTlzyzBLiI4shE3a8XbowiV4g2e0W32fpBxgY2NzNudl6XZI5t6jUV7HpUIUUWeIRZuH5X0I9R38+dbJfbg1nIO6ZGK6GQm9YApO/pwRkRKhEhxHSnbod2XK1YmVf7dnKQfdxtKw7QyTIrYpbRAtjQW9g]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190616]]></title>
    <url>%2F2019%2F06%2F16%2F20190616%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-033]]></title>
    <url>%2F2019%2F06%2F09%2FLeetcode-033%2F</url>
    <content type="text"><![CDATA[33. 搜索旋转排序数组题目描述传送门123456789101112131415161718假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路:数组在某个点进行了旋转，那么原来的数组就不是有序的了，所以我们需要遍历数组来找到那个分界点那么问题来了，怎么才能找到那个分界点呢？ 因为题目要求算法的时间复杂度为 O(log n) 级别,所以我们就不能遍历数组来找到那个分界点 而是应该用二分查找的方式来找到那个分界点才能满足时间复杂度的要求 那么怎么用二分查找来获取那个分界点呢？ 答案就是比较low,mid,high三个点的值的大小比较,如果mid &gt; low,说明low到mid之间是有序的所以令low = mid + 1,否则low到mid之间是无序的，令high = mid 最终知道low == high的时候就找到了分界点，然后再比较分界点之间与target的大小然后再分别到两个区间进行二分查找，可以满足要求 代码如下:1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; //System.out.println(left); int split_t = left; left = 0; right = nums.length - 1; if (nums[split_t] &lt;= target &amp;&amp; target &lt;= nums[right]) left = split_t; else right = split_t; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190528]]></title>
    <url>%2F2019%2F05%2F28%2F20190528%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX181M8bOYg2onZH8v4/57fO3GX3OFN0oq1TseaB+GbxG6PnlnL2hF7WIp66YikjLq1t/Czho8W+Rk+BU5FsRHr09XVL4zVsI6Pcl943eC9/ISPKDGkRxazHkOX6xMl+bKYTiOib7RZq9grauGequylkCjTFM8BqcyJreixvcirBa0WRZNH0g8C3oG046M52Ign5jb+umVrmzt0cmfWmTuUqJj+9WeEOpWdHh1je19vk2IqPsD1Ik7dZOVsc2lkJ7IVt6D6IOE9ume9AB5adgwZCicEIV7/hO0SXBX4iEY1VF8bY9jLNQo+1QTqgb9cfMGjyPXakV/N1rrisLePPjeWeh4bgXRej3R8h6kosD8ATb9EzmDzrt886PKaCKdUFPbrRtfJgSnkg7TqBPtf8cOlEXd6oA8s7RFODgepoZsHpFlHIcLY8Cjw150and2dNnUInDU7SI/H5xP4W8oHpc99sDczhaz3wz3iero3A8S7NLyBMvMd9MRNNUnIHhNRRb/hLQU+QcKQBFYOVZQkNafFDJAmGXWL+6a/2PATDF5GADynn28VpcNBVyZ4EBszeQxtA9oqx42C1osJa2+vnt61mE3APsOmk1+jRU2+zKJCxi43rzJ/DdWibbDdQ+wUs6BWUM7Dj5q3LueFwg9s5cHR74u+gLSEzFk6J8zc7B7uY6X0vR+7zLiwErynfxf0KTuNkkTN5HaHhf5KpqzqGOorRZv53FHxj62tDnx3ZCQY5zhJLNClkfrVTy5gceDBI8cyg4p4nlfT7tf5zVBdS34iitNqSWsm4qa4cNQRsJdLfnuNKt5GgkQN+9JwLRj6m0hf/x0qT/Usaw70TuXz7JcWCWe9fiaNQRcLAaU7+0PDP9DaIHdRWtdCtL8ldyrEAuzRW1ok4nLhMgnpOIZmSp2t0Wagty8nfW9N++EDPMpXKGTgmCFZjUJqU+9NUO7HSPMisas/BiKmqD8RyDhYMDIKQh1DI4CP6fb7r0jZjgbxAljwvIwqKEzbb5nlMuoDYjPIqdQkV3LQM4aV6Wmb/pgoOIIWO85iYXn1Pmt8uu4P9YnKdSJjWkTxmH6E8VccQpCF8UO3vgrv2tOyefnWQtQQELwNXYci7zkriJyhXcp/QNCT/Wvg+e3m2rwprpASBJkzhPXn7V9zlGiwOs0o9DrdSQaQzhD1g8gD8ZQV8cRnoAS9tMN66Jfh4SIWc4cje0LxbGlHq802KG03FYxNDunVIsY9bxvz17SrnICrPnkBuTsSE5ByX8uRlyx6XWGAejgyUYV4JtvYLIYP0EtwLTm+a1n7CN/7mPKUvzqQKEqIiKlcIvgkJAe0PUZ7MVLbaofKMerWLYhZ3G6RpY0AWiXWrUlxPuECJTaVpuDZmijY2YpKnk6r26NtLZxNxgiRThHzFsPCSoehAexNTKLeMF+9bhkvBHvOhqm5ZWxlvZUU315qsKKzMtzHQ1uOTgeicYQtQ/Xe6xZ8oG29JQasRNiSu1Yq+mOrsGNhtlP8pfV6fVWqEBRyxjuzWPvF0BNcTzUWfpbJIsIRMWz4gyk8at/wAzRzMRW3rLFpsB3le5yC2764i9C/0We4EfwqO3VAr0sWnRgYYFn6MRG48Qg6cYuKYzDHSpdPaylnoQiF+7n+6ich7o/UqX+uA8P4z8NJouj6xcq9rIfT4XEXk5xYhyJFKZXAM8/XemVzEje9nr+jFb/skxemW3tKCyLIvdJBFD3TOupYf4WAUyectPQitDyXpKuAdZIThcvPDnOOaJqdU/d0hrKf7FQRwUGq/pZAt5v/HQaRfuYl+/MiBKwt1X6GlQqaOneA5n8L8mockN7lrlyYTYYYLkoO048SRq+VpZFFSQ8Maeq4NjDhh5SMvS5KbWkpFwh23o/T4SF/ye9bTGiNfW0EYW0EWHoaUopqR4HFM6JLZ+/C7I4kYjl0kFi3b4PTp8ex+pLQug9jtOGyDD7DaZtHG6g7cBciYJSDKhc9kg9/N8IEsJi2PnhRodWMiV+I/WNVwlqsUR5FkXi+1ywaqxTJajS61uF9bLM3b/EuysygSnfP7/H4jAyI3043uF2yNBoJTn3uWwUxxNhHUVFXURv2CujEGGhPGjITSN+LkB7o65KVusIKo1Enu3ythr1shG4CpHMs15173fq89AxKIGvx45bBbJjLNYquEELc4Smg/e5eI7iqXXcJh5g6ZOMUlwnMqkWnBfnM9/fmVENSax1N7uaQgcKL/dNIaMYXmQ3qeReY2oXzoDUTNwicCvCs/nICkWvIQXBJXmwh1NIyYR6MX0REwdm4GqQQ8RK4rtEUF3eDlWjFqXF1yB/PexInJXLhMI1/2gqZ6nuH1ZR796B2dbrUpaAx1qbzG1v3Ztfa5qhhZSbt1Od0OCxnWyndGc71jRXEexHxnw0CAMK1LrrtAR0oblKHB9VHaSo46psYkXRWnJy+6fZAbAeO2x50OtCOLqA2/cHinyEsMd9e4gJboxHvejJqs2DthRC7xwp3fHQEZpfcyHqFCp4EMbkEsGT21eh3JiVjX/Q79pw7+vWMMlpiumBNqfS5FjfdZUT4OROXtFjmbaPihNtBoYgFzUuQVyiG5tEdeMX7CowBfr7D2uHb6R32EYUtAqZpCGFeSYhxV3QVAj+hdpC1Dhb2In01CXAanzEopCsCf9/m9GvmuFE9MxbY6LqEGILAGDmJfp3kNXnrpDfzftZa+ExyeDw1/sJsrrYfHvavi29yXK91rkl7UDh4MAGpkoHzBfJA6kr9e/XxhUZdSKfDHv+0WkmlNbSqCIjuKIGZR/bY1RqgWAclUZP4F2MKZTmC3d05FJuNr9IAqpw0IUgMtxGic2qM0o1OZciF5efHmssCkowWTMxj7yNgHL3OSO786aP80VTSkEnzwpTR6WqCm7VA08shxDsurQxgrAWbWpC69hr4vr20829bfKIcZ9qNUByo++UR9MS8Nt3upvY7k6oamq4coa/zZHTBgCeqrpf63YRqu6ejKGY2/Yu99IZOQo4QW/Jscnv37xoctkdi0jRaS58OTRfkwKXEv+CsQLtNAgY4phXPHMKtnqOk6srNXSaMhcTFBXI5d1pedW2DPsAFMutHpjb/8n4aXLOiUClPtqt10M1dNIQHmpA4qst3Npu2BW4mmwmBB+Hr16+vlKgOhoZUtJXRSqhBK+jKYe5b0nCCOwQhohfXce9eJUhW3eMvreerLOCUs4mokidOapxA+0oI2aQeEJD7YVhO4g3w0VZ0d5XpvRTieLrqQH/K+fdZxNW/E7ZlQhKuGJhadUQEoM6ljFLP7nmsNnhPr9/XxPvo0C9CobvXpcAczJW2k4G1NDkOilDN0IfC7lwWC8NckY84UUv+KbNNuZcP1SzK4vzBow10BKkEvPabP3fPhHCrhLwHmmcLxHiEP1MlgMb1zgTn/T3IU1nBeTyrvtP7LDz7Uq7t23JMzn0scbCFJkXTvnYBSlNiPsdX3kf6D22C5SxLgJ+5K+28499P26Ph7+8T3+JCI6B7A/l7rDpnqDHTDgnMpYwYo1BJOnkTALoUpUh/PnTMN8gTogiSjdrZjn/98gYOve4iheC06Cs387tNhKyDhECXA8aH6jDaSxowpqhz9DJdXdIpc6yi75KSl13FE+ClEdBOkg85vLy5Vj+ndVOubYQH9HmONn2+reCVoB/qm3jA9XKY4WwARGG9RJtrFo2xItJr2gaN5HIj36B/JcD3uYyVKBWCVITUf38pSiVwOe8bu0rBWtj96PzB8KiWSd2IrkAkPmWFUPKpDDg0NYr/M1tEGQgIA93y0TS5z6zeMFH//vHbabAeWT6D+IDee1Y35YzDvUV1Xc+Ksa436WMOQlG+7gplOf+hItxuv4vwBzxcd9MCnnUwkjAIgz3k5LSqN7o5Zffo06qMWOCew5Bbb7ZzPR6pYayPHbxwdD9H8fVbZBb8W5NT14MTJ0JFBZjbqI6Vvoix2tda+7RYoAKjXm+4rX04RGrFrAQ15UsL4goK1WXszydB4JUvHyNZ1kUnJ8bD3qGYjLjPIDFggr0W8nflgMuuKaVkR4TNBH0fLLOWP0O0fzNB3xEHAZTwdkgcDJ6kp6mxazpuG1WxadbkLu/NTO4WNAhqHOnmHsPHV8N9xmKYmreYqJBxunL4y6I3JWHMGu5IkSP71yPM9ich/dxXfZVsV6BmGv7h6Pmlu0VpV/8VEg9dwRirkzKNGyLBLbYMDLtaXimtpxpM5NIwBMRLvz5NAYpnvE4F8nxEZqmXIK8RHU/JLJtUE/N4iSE8d2kO+kzysGCKRv+UJKcAtQE1ojg0wunBusmZMGdWSvNRzI8vKgIvkIlqEDKUK4OgFKWfeA5M1JmNiTlGh3jigoQcznTp+A0T3nyN2nX4Ytl7MjcN1MjZ7L6NzAXOqlXWw6aC/HczzMnQSBKE0MRqRPPljU/AAQHSmnBnQo3Os/yvMaq+3amnFCvgIgCPk0ZrowIbAw36c3tJTM13jVQOx2dHPvzP1awHe95QfOg+40sCeffVmgvXR2KDkYIOJdfUbWSpvGZictU6G2Q6+CeVH6ohq2D7hGptzaUzqGoem7KrsZgqzdKpkXMT6ncDPdyvR8mRIy2h1yhcqYmXX6sDNYo9a3BcxBI9mJEZQ0UoR91tkbcSklj/a8UrTtogK8o4e1b0vVSQKtwEv+CJiSU4ZFdfzrt3bpbSGTnFYaNt+OngDYonZV2vUR3dWsfWRiNuorY0DE7i8jiEmnB+gb7zrk/7mfhabLFZKD9M+GvI8Pi+GYghIqERxDSswNAtCCrVQwvCbn85oW+Y2as3c1ESlyxlNw/b17xu2wIAHTx5tjhuG86Em4QyqAz63tjGNXgU+e/bbu0iREWBVdrumcYhPaHD8/niauhIaUGsQI85moMdI1zD+ZiDj72rrkxUepIlEZLUYYsAJnQ8gQDEyw45DVpGhbS3QDknfIWKZIrzNs2DuZhT1pkOUn9d6d/zTUNxSABXAPaiE98WqgsT6uBNFLPTmNd7gletUt2r60ECBHaMpp/h+auWpcL2PWTwRGRRLZrzP6BJVFJ1mk6yVK95zPtdNbd+loVactPquVk5+pMmuG/5iw+hcQ3V0pvKbQ3flQJmQMHdfYhTnKzyg5qP/WA9gSuwRE9G9zZrY8EB983FOV83oYeDFVBSaSkFAPJKTV+XHQU1P2j4KCTiRwNaq6qZuiOarGVJea37lHzKfy7hgKjzpOKBDMK2PEHwCmm6BKCGP9EPpw/laMmB0o48j4DGawiWjNM2oXUZ0ygHuoHMDQ0dNFiP2jfRcSLmbc2w7PuheQDfdOkY8EPuHSCythLogiXhmHwTFS0HoEf9l+CzxYCIeEX0sRA9iecqg7dhELusK0SqQFnva8hMmOEiB0Tm57/fIDa8MgS8wFJPh1Pi4Mnx51D7dSjcGrnKxAYX1BeaFPN1ELf7BlJzI5Nd+9w5rDqjJLMM0ghjQLFNSZMQd1IEF39YCh31oeyo1zzvKpKv4r3SSawN2wN/lhzgCZEdZXCYNPf01dELm9fN5MGKmymbpIKGyzJH0PPIGgCrxKfvfLQbArmjGRzg2ovq1H7mVEunMc4q1OMeVbdT+y0BqJrIZ/QlUvrGdYTL4Q/0/389rOXmwVXWS4qmgu1kO3tkf0ERq0WiEduCTlL0CJWxUeJmc6dsIUnJtqhbzz5fqNZyyrJuSaoU0SYt6Sv76SfyUFaa8CVsakOn3bc3S95UUu6UDCwu9cNWE7R0NEn4yXh8S3JbNPp4McZCk2xK5pY/3FR6bAepPoM8Qd2MwHnseo3SW/m4kEZkn08+fnJpjpT8FT9j7OCOVJQIQ/Xg/RSwb4fFiXFv7WgIk5QFfoEaYLRFes/9sQHywJNMci3neggWu0qqr/F6RrRsexUxsM3Rup0w1enc07ukHyOrc1K/Ct47dPkk0UOcWBad6ToXE/64uCq3ZAB5n1mTvvFCiTH+JKTMLp5JEbaeRYdlK/d2/SdjbYgc8csfK66J3iPAxcJvJq0FsOPv2pKbNbH6c5xcVsM9kSA85YgWPlh1JpRhCNglv4VivWdhl6QPprJcjjqyYDkvRf7L+63lJv4SQNPnxjHXfW955Jcirtcv4BFEjZ7ldbS1euKuMkSrhlANXEe93vQ4uwKfAoEHUqi4EkQV/KLN42xTmlAq+O0fH4XOZlFQ/ERhRx3Ke7WfevZKZMS5uC2Y1KDwdXqDDycvdfVZntA7wHEx1L7jEE2utlBq9ZJ5RcKk3m9O6iFeMQZ4TDmnxaIgZtEqlS3W7f8O0GZeGIKNr+WEH4kArtfiPqSiJZIKXG3wBQBcRxxgynaFIxrJ7GAj9960XZ/sIXqfSYb82Xs6ojfN9NFFVoTqgVt0Hp9TXbTX4tC1JR62zijMzdMAVLiUQg42WI6ufz1DVjRWMinE1++RzvxQg1DsG3JA8qnt5qMpjvmwFEtvOE4r8dcNx8f4AysdDEavbc8CP1pzyzqx/FdME/co2iAHXscQK7H9gEp1ZsdPhjPHTo1UIYxx9F8+y1the1erDeErIlz58Mmo5MI1ViBrUZMzDVOY7Xc9EHXTKnokLlNciFQlBlbWZ3uue3YrGM42tUbFifI48LDtUZzQKEh504f2jvmPm71xkwMgHFYsKfWCYUxGfpC1XwpswmT4GBthhwhWTIo+UOKsAM2/Kkll4UgAiiGRVaPssRNHvcBmNTFhBw9Kq45T2HGs5SaqJnVSpXp3V2CEzzYAuQdJQo1OQS0FvMR64ZqJzNdiQuL8aYT6arAjIoTDvrit5OZsCuj16yle6GPJ0x58xJhU7+GIacwycV5XoIKMNWdAggTC5VbM1iKLm8OPMsZTSBkNdKZI5mZyGkbK+6LUFwz1qeAIsksU0lf0MV3CCvZ11UBW5BGeJAoCuxaLqnq0Yey+uw0bpMNtf21tDE5dXipHbTpNgZuyJi7Ty5PSo2OSaUK+0AXYQXCQhQi4LAnG7Czy7WEVdbqLgY4Mbqt67hxC4BrYQcoHRloZgWL5gfwqNoIJBIP1iY8lW5kr0WzEVQe6MHsUUsvmGUyJ1Uys1WmkPnVRRvYduUq0EdvQVN2XNVpeUbw6+8ISuOmeUIvh5UrmfzEEmfCrwzyYuKtpE+QgEq4+W/EfBc5dCJW+ygV9Z5BChpysbqq47srPngUEInB/mFQK2Sj1/UHNd95C0A9L1z39fPxIQwHvzh/CMM05Xo2Dbl1CsuuWFpigiVFsHRe30l4KLsJfBrDueXJKUrDFQ4YVy2HyKSp5u2xRujUDFr0oX2k/mr+jPPKNdDNY3X7OYAup052PGj6/tP1u4m1jI8IlJPnl+Sh7QCqgmJ0wK0XQcUHfWltZuJBRL3n+1TVpmWZb0239ndGeM9As1mjTfO3teIrzPyPWjQqT3Zu0zBfjv3GIkMcaj4bA7aX+p989C/IsOWdIqVbWh5jaMeg3w4ouaZ+9zF3pwvpZFXbDfndn6l/zU57nPoCC8ccYr+EIbKcQHAZSf73TpwhxTHUZRXbToApnoLDmjes/Imbh3U/aTdfyipfXnn7pA4TZz5q62znbQowSnzArj1Z91BrJVR0K7y4OFY7N4pB9yJV8m8pTLJDVHR6VqdmA5KbZKeODufZMhV5rMBudIERScxRf3psh3xh8Pj5RqgFCBGL3uq8ffyZyjXsPkn9bOQXncCstCkkCCgYOBhmfpXUuTgluHmI2gqiBz5x+vAO9ArUi62gNeVZ88cBqkyqm4g5aMnGqyTjZUwOXLZrltxctNQi8+lUps8TH89yyjjTy48sufSshDjeNBitEBguw74wqFGCByKTLu04TL91YlwWLyRGd6BcV4uuWv2FOLBHYA0IQp2GOF8ZVx1q6Y2FXR+bsvHnNz1Mf7vee5psArAY+CjpAkrLKd6vu6xbWPSDGzD85kbD4vcwJQDXhzwr22XlDthbakYJb4tofrfmp0NiXw+BnutCZANXI4Jx5uDtJeXk+ukgu0fbemM5vTlG2GPXDHXADIPEvswBZGEPmpL42hyqByTgyhlv2XrxafUQZINDV8EhF1LW4Ns0NLubO061cJTM+EiuAO8UjH0hhx42WLfMUH7sszMq4R5mDLWcCqFcYrwu5cI8COyfjcQGQjmqPLI4F/EEd3JJiLHAogeaMKkY4QaIYWTJ70w24gnrp0pDZM/7UB4iohYcaP7kaounhpTzkx2WPGepFMD1YkcoQDkXq6dX9/+DWwCjrNpioFi0ewhnmbnuQVKYjro/R8v6rwZHKpDdHj8yuZcA4wLdHFWaLgJN/9YQzpRxUx2mCyMWcB+zY/10JSfYzRoaAEb1+N4tbEogK3Hv/CxI3q7kDNbLRzgcI5vs36ok2FYMYD6vRiuASu9NyVSoZfTisT4xqSxyn9n9P6UnyV3kpk9Q0y13hkRDSLo1AhLJRD4uAnt0x/p2wRlpZp4sC2hYS/tnXJPcmdPHGEBgCZ9HRHB4d2ktJ9JMwm2W+ErHpRbmPPTYFJ9RT98LaqLhwFKGQYw08M0dRXrLwQX+gxCgeJxgKe7ZLJG7U/EQr1CX9Dthb3NZ8X3zEdLPEDGkPwE4zjxPulSMburKCPVsaDXp/8zN3yiLR5sWXDY/uwz2JP3+ika+jL5m/jMf1jmo/YgJ+9I3rMKcEbkHACU+2I8hR4IC+fwtv1OwuOAAjcI0W75rEJIz5FiY45WV7tDuDKwSqOc/KKVbVZwVWsIYY2Fw0pG3idDFxEKNwOqPk3lTUufj4rG2h7LJHrWHdC0zVaHENbYlSDrjY+wLOIEcBz6klckcmxm+M1tl/FtLv+k/wrAZLCX03In6W/IwVmayXXRpq+XXfKJHtc+dhBciGcAy1uwPeoFJQcgHX9xbDjtq4Zg8kO1D/1G0pRwV5ly7gGDl/UXqrh2wUGT4cjOPzMzRgwiT4JpuOpdgA5Wvyi23BXqw5DS73NJ7e4pTOG3HjjcE4k+4RwfF5Wo08fK3otPkDTfUN99lM7xuqky1sfnmQwrxOTUW8eKP/TVUvlEWKLtqehT1/TZYulGh183z2TeXTHhqReg+6pgL0O753mMw50+iSDUOVLn6QrNjoe1LI0tbvOkQjpLRF4Xff5pfZNTMBiwjWQ2024DkGw/0CekaH96LqWSF6v0W7ehsC9vgoKSKA3gE5l9YGGIfJk2Vhsm4Q3emeACb7+klE/fYGTINfz0wRwWADlXOrknTqNKd6/Bdwnaxu2PR2iMQRz1w1msKCHrj8raJ+QVns+kpZqFK5SEBFA7O9qi/cyIUCixNCvqZgG5fGV0h1R5AKiMfxz+27Ga8DyCtB9yFgg2cMhOCFysQaiiGtBU+r9WlNszOZL3X8EGrvYwEaKoeK0NdVT59Zyk5wbzp6YPvogC6MzDrGOORlDcdWUjw/5FWlP0EBewXl+d7Pc30hkwRaMD2nDax2qSAPneqrn8qd7UsrYzGfnPLi9NYdCHGgVundPBMAdxad9+BdPTEjcSfkFa3A1A2KysIrEGCCMatxnij42XWRqGj2nmC4qYxxRVpj0WwoEq9suddnwsxOUK33RddKWInb3R66hgzkXvQU9iMqwljj0HmNFY7qOtTxiytfki6Ws05XmHqq/DcGLEmcK9pjiAaUNGG6K61zoxgBzr6CGihxGZndQUVVKxJ/xjUdHPhFyoX9wBHNMg9qIqHaHqaS2bwG7EMal8kMsYN7mDkOyXbVh0vEHb1mSIF7+MVZ7sXyUqcD7nVDAEJRQtxD2+KGEVyr+4xLMLRq2EhSB8YJUIN5Fvn5xqRD4PHBRwHNpoKgNpBZY7bZsTINjVB3oWGkUV78yIEFGy3B9ddIf5r74vVmgfPj/0KSJRhQg8PjEncpQSEW4LfVkNbD3CqOlFuQlB2BE+qHI3qKlq7O469zH0KHTxzExhKQ6HQUjMB7SqvcKdBk2h3AJFaJnIcRgTbkX4Ya0s+Jt539l4G3Duzl8q1bO6fY0hgb7ZUi4OYt5H0ochKuLRmkShy9p5MsmvnpaKI+wnjhymVZ8ikb8DVuo+F98IMBOpU1BmwHYxqlt+qgzSmBiBISjmiyS88XiL7st2oHfu2h7mObV6kNenOD/ICfkBTu4nt3B5tvTmFz7p0fbvn7vJG0xXIy/lyhLDG8D9KLf0xg0tfeW3Sx74ATesVqxAb2jf61/obIf6X7P7AeqsOWtr+4mrWJMKZoEod3IG1OYWLDRJRRglregApDPyt+GywFnHhTNvViIW65XxYQFotZrRfGW9MDBoPTH+BiLyPXNeRKwrcLele1tIQPZq/ASv0u33iqsr8zJRhENAgpXy5P+wcxa6UJX2t0peH4B48b68pDZ/Wd4ZwoU9bEMI7lsjL7F/1QeQdGeEDUzdDxCfcwcNKmjCJX/mOU4qB/SBa+eEWhDWUQnDv4zREpdF/1TuoIFTFMp27dzss2fcnK4NAFWz72L8q2Z04SVKG/3ea0l982a6V2eKInKvfXhCnEvAwZvGeJovsndhx/fAjwkIz9R+ILGwJztjPBOg6oQJtD2KNIAli4sr5ugQFNrp88wfBJqH4bi+HO54vqfABNfLw4pfYJmCvatSfTYzx1bgi444aosDvrC3hiIkCH07uvbQLqrPDDKTvf18La1Z5lPRCFbCbm8LbcZtbhkpGyG9nJCujN3juzhxjflq4IQfL79a8Wrb2i2ZbDhDPGzTZd++pOekrO03Bcxjhb8mK4xHvnYHxOxNjMignsPaIX+R9F0LPaPWoIS3xNar9p4umcUg+XV3xt5sDDbglPRsRNTPv2QsKPb96GyNeapmVmk/ML7Rd1l9VkRbErO/ogTTJZZSeDiMBl/SzfKGFlpucu+XPiL+iwd3YI5pdv2IOsyiSS1UrhiuRPCIA6PmgIFTmJ4DxB0SFf+AlgtNf69n1pk6jviYOsYmeM06xCHQfBQjEIYbbfB7F61MsLwJlNtDVRJ+t3O4JmhKCB21CY2bdrY6xKHGyjsJ0ne4pvIeftrdSCnzIg5TraZjM26+FBvN/AjhED4YvOiOqo/UWDIPOqc3eTNawgXKHA8tdzz/uVlz3qEkADC5DSAxW9YkAPdkMerHlDKdcfkNHP0yGBYzYyE+xhCDRjEebYVicOnUSJbmAv8UHAt+AtjiSCag71ANT2Z1qFg+VWrrqr73kH5sqvqoTc1PniSreTgnc24s92k2hA1XPzw1nQA+jszV9wSm4u+lValBzKoSV0qo0c6GS2J2d+hAcWmPkYX8N0E0QU58pF46GOz0tBpzuSlBTrw1DFLTPDodKeQYPpezQuIBLegB82eZ9YoHWFkRanO1ZgleRhVcl40xvNStT9N4PtFnVbe9eiWEOzKJStVlLe4HGalbfGu98WRs3/W/RXsoOB6KjCt3vLKd8ERcdnnnEPrQf43OoTYMxK9DLJE0pL21xUVT3EfMo65inIlrQT9w1alatDyJebYPwIjZmFNE3k34v2VHmjUx/eS+VAk1RuDRDVe9SRPJU59R/p2SE3y4QZWAvQo5/bkV1w+DrV+9BJMgNaba5jJ/gYkHr4a+08WGleqAFyFiRZrWTuFr8yc/pQy7nNXG8WnUeZ8ho1iAuGIO6/jM9M4vweatFyx9hig1/RedbpfxhI9mPufLdCphpOskJ5QS2OSK5U8rKBHmjYAnPlp4WLTLpe/eExSr2d7o9tf520keJX7GkuCFCYnLkB6T5MwMg0o10dec8N5lin5HhFctYQ5IaEwTHMgUJ7UCbnFvhTLrSa/z37Bs3olUAvTFfSWoTlaYEQxHeWI147eK/tB/59ceaZbryjfzPgqR98dnUP44Pat3Ny/m2AvyQYfxl4kZnaDG/n9zacqG+sOwDRSNvRu3RzfVDyUjXH4B2hgjgJ1zo1YbaOUEDRi07AunyPtJ8za2NDVFtkU4rZFp9om0tpQHNTy6q5tB0Yko/8dH87pueCGzV+pe0Y1bvs5B7kYNBbfe31Uj/fmPAtDyKZrCp+hQ7avw2+OACgq6f+94AjN/CT0etodpftdhxQVbyJS1rjP0CLRAdvXyFDDvUw1XJK9YzjTHHJrtNzODmdL2x3dowS4HtZjk/TAR9cfnYAEhOtRGjYtR9sLmDNDD7TJE6W9vK//qG9qzp0EIz7Jp5dnCl+xzrqsPDDorEkcyIL1W6fECrulXCB39aVk648wGNxUYzxg6VXxFcv6G5ouZGpIBUkIFL9aezG6R/3iOoEDD9rytyztfZNuADvZoooVWDwx8EQrJ7j2XMbx3LQIJe49O8MLDX4GGlpbW7UZ8NmkGoXUDgqtJfxX38yjLlZASVGMU8WK9B/ibefNBqQRC68NTCSXGZ56murZT66Fio792DIEuTw615Lxm6IPGMK+EY0mWRvcSMyTg+VqDbsNLsKEqslFo4ZAsRozCZYLkIZXjtu7WpKSpKwLPTZLhLGbqymszKla+sqXZkTWxp06M83Mk7BKRjN2bBONRgHse2Aa89eXtwGivfletwD0Y+sp96C/kzd0dpL0woN7j1c/HGn+llSlRaawt4E32rAZazTWvFPiEjUggcXs/poxfhS44+aIHQIdAMiBZKQw9JJ18QewcTUVwiQ6LhGqVbUJMUThl8Yk4gtnhEYwBCoIi42Nwi+/00Hfn4OrtjpPzVG8fUMxr8yybhZwLGgXisn0Vb0uTbDhJORUtEgohW8PDIZ9trbwUTvS0ZHyHbab8T+Uw9PQsKn7W7XgKWfHcbHcfKpESBDRIgifs+BIx7mjnLjGPZ5Io23Cy3VYSPR8sarMeklZLF6Hkn7SV71xMAOXSyfH0dQgX6VGw/VZtPAabqd9VQaGXX+R59EKLifk4GDwk3EPvXWcS7UDzMASzS2Q2iqUipBWiFjknkHgqGEb00yK1KDMldyhUzdsc068DTyyPvtG2QKScnBJOW43XmXsdaqpYQoYRKUk88UGIhw5pt6nxKHDMl/xuQXt7LehoGl4ZTjhu30d+0599fW8Pty/95ymXF2jtNhBepIOeqnXgU7ffiP8rfn9elRxkzdvaqJ35acKI3j0XPn9j+nrGWG5I9hR87Y3A7jS1RcUMZ98cCWDH4IMC/3Y2rLto5h1Kji5bZXHzjiaovl3gtn1DgpDhlTfRE6ncK7y7yPLz2veTexzHRLh4CuFjI5aDQByx9FsEjDAlxMHowMdxqra6kvvc+NssfwfDUp1LP4tpImUyB8iSwKJFxF0DeM7rih6sj/nJfL62dyJZAglM1ESsWdi6nx1IMhNn7nfOrO9qnrJmoKiftDZ6yiFG1n8MiOMU4jkIuAbPNpHnbiFFel9MVxBar9V0g8+5nQNcx36Trmy1+/BqG6Yxlm1s7F1TA5VOy7znAkzrfL5mjP5geqm9ItB/6TWLmSRevzNJgQxB3Jf9REFebtXuHsoZ16IjjafbMdnbys6t8z/ilFtJzXJz5on83QrE+ELDBQMMTkGcoZbGtB2ExhLyIqt9UsK+VYCxp3LjFEtByAWchTRqtWcyyXJGuioSYFXZzAtS2jbQMXBdJPilU52Ti+3ull7A8Suq5AtU8hKBp1auHfyg/CAtTfV+Oetf0XS9f0PhzrjoKP07kvfGfbgtqzxR7ImvuPGGilvc0Daz9vbgxWEIUh9HqScSq4b51qbSIYjP+t3DtweHRkXNe5BNkD2H7U+opkSGnd+2sBDjXQgdq6ytnw6pnRSdrGlvzXLWidGg+FTBZkwzYmR1j0cnHPapcF3z2HZ6g0Fy7MOAiBpjIczT6Uns58GfJWJNcYzohbNQwdjDaBGupRyvyxD+pxRtNhkcvCIBEx6nHwi0U5k4U7quW37UEfopPNdcghf4bQ0QKa3tVr7hp04Ixg/AWX9ICM54qyPey2Gde3BtfAVTIX/J0Pf3WT5QRBB/tejVR5T5hYCQ1RXYbxHCmNoomIol5JODCswMo6KBEZhDXAgsLdFKmmJar1G6bAp/tU/859RWYTNhl1IibjubtpoDuH6E5DYDmq3jCi+qdOYNF87lZASHXBtijdJYqDDl/3dzJkHfC0TwM4vJvp5+YZmkUMTNacfx0v3SS+dBDCmBV8/WjeKSbfkyUaQCFaghaJBpo5jive9VKHsPwO6vdvC2+t/uXtrewZua2BH1RzTfy9kMeRAtMUviwRrD78zLx/jkNklzUDSaH9eH/eGWzX/28IKVO0TWRHLmecrHvLqBOOs/hwdsR9M4pIwn2V8fwu2x6in2N0bCsdM+40+ICUrivKlpsopVzrUgGY027y4P/5wmTjYPblSqfmaGhJZVx0w1HLG/nMpgO0CS9FRspaXYL0hKS6dX8hpJh09ckr70TDT8fYxD2Y1SbUxQTYeor01e1NEk13pShU/28rn0g5iKLrnLuHeT1wGadhjspJlWtszmjOAV70RRK+jH26EK7dV12GHZCbxFzfpXR7M1Nf36833kxIsrHtyBAZ7w/ejcw19/K8XMQngb+Mwz7smrzfjXoxI5oIYyeBy9kM94ZcwHYVKbi8wuhV5+JgfbyRsg8E8Wz+yaw7xjhxsM0WQHFGrUaozWp/PxxYVgIpxOb+Ml0lL7hWdbC0Tzeq2bK3dyf7Mo3KVpXyK3auAlYZhmY/5D4TuKT0m/31pJ3qzmJm3Xstp2NfwdVhU1tWtH6bVU4PPNRnvRQnHGHWRwVti1xZ/jMGsDkMGuf4NSLabg8Z51E63vvN82AjSDLDb8fxFBI9/Pgd1DlCxaOiF3XGTkcp5i+oRI23CUr2yccH6BZFeXZn64vqr2xkLa0rQMlG/8yFDgdjIp33/WmZ8/m7zHcrL3+FX1ZBai20iaOmhSKG9ViPC1FjIoCisHgYNfanLxMaQVYPJVj+PvXwlTQRV9Fws6/cNsvrDQP1u6xlDLY7/kGOJAjTQ/KDo6PjcnYteoB1jTFSdYqFHLTwhbbwTYaOM1BicS0/Kbou9AEOj1gGHUZp7UlO91RjPPdNSs+HRN1/coBpO0JuEzz9fXN6BJyOZt2ewg4KcE7moEKWJeF2ZxwJhQKA31pTOZgb0aAeEVe8TKVR9DFcwgZESWZzRceJLuNGOU73tnfmhvGHCtzLv/DPARlkMLt3gklXA8y5cuPyxCO+Z/kpRBtJnwppE0Ikse1w7SgoJgIJFSpeVMG4br5fiqqtnic4mkl8AnTrhDgJAmaWMJCULFEHK70WBavpbG+kg3zzp7WVSkrid27GVst+pwSWfcLiSAFvsME3NrUY4MNs3uNexNiOXD42Jg0kfn15tO+or4oQcdLJeJFbJ5UHG8NtauwvgDixvobg/BQ1rXv/ookvkvsaWkjrkpVJWAHY027FhVOwAt0ECRPrdlmjLcOj33/xmX8rmwewFosZbB7V4v3voL4iKOTtPH1qixKLh4WYUa5sLp1VsqzDgbN84+V+xJ5TNTzWzYH5jdLwrEgv7i0YKKGl9cbSniQBH3bfUO01DY79q0WCNuVVYOWI5BoGOkqUlbUfwcXSSTRj1rFvaLrlVXVDkmNI2HWfcLB8uw0f2UnyXMJUIM8AAyuT6UfpX0miT7EWEc27h2AvI+peAlZLchnkEI3StaGXT9fiTpyda2UwvmHVLJSiXXNp3p54LR4pv16KFAyrZ7VB1oyi9D3dhgB5jT6o/a6BWjBH6OCFxsooOr+vjuDv063EXGsvTtNbubptt4dcycvh5CqAmsuGpyJSjDYjrXul9fv0Uy7jfNhUfNhLWMrDAnh6M7YilvXjfk/+doLU4NimH10KYqHsioIMZudyktlx9M2DgMYWjVImhkjreHak5PiRc7aB6PV9GTHGzeTNMRelNH8HlVa4XxsYTNkZ7nWJIbv+KmJNZmw7NpaihUaBEuI4EvNnLidDzWnZMFRlM5YhbJrEVHAoTyCPJeQooAeJfaD9IuvTiWFUdxLWvCPJurAxajLyXgxc7HYCTQOgf3AWUfzE8HC+OyX77j7KbgDBYiOiqWubWQ93n/TDEO0W9tVnHZblG5sUuW/woHMx4UwkFIvw6KNv29iInhoMa89osCnc7zj9kLUl/hnwPsyp8wVdlxmM+KdO6PuQMXtsic4bDsjES1EBrGLL19RcYhzoBxzKvFJaY9TAaR8QaMq5E8mBhYNGx7QLLPTQoh81oFU8CZIFpU5US/kLQofDHCW0UW7qIRHlEa337AzzJfumRumyEQZt2QzZYR9MCc/SU1Q648AVLTZIaVdkW/ueM35qV/MBEprX5l7c03S+N3qnYWvBvkYHOycwMQcrH0wdc+E1deu20m89rC9WahvfoCyd9U+XevXCTMEkwQFvFN0kZx1LZsPdYVEb/g3TfgYzEDDV5P+yElY+jUIebW+sGs6Xg2QCAeRxKLB69LpenDhH3eK4vsbNdqpz7f44p4M2ldttxqYV0cPlfuREHA7+8BqzYlmH+VfLmuMxCAGaTCz9I0tJ9H5dvKz4fbWGmlLzQKApUD4Zi5z+YNj+MocQZb7r89FuTlKotB7XJuRS8opdtdozi/zfa8NSj5yDSlVnppWb/3OCzVlZMen14dn2MVNUMhGH7wzbiKEZh1NitaMoP+cFIhQj8iPSsCT2BzpEjAlmgjc+Mg0fVHqjbwK0yUwsJXYXOgIRuh3LiR7N7n6VHTWBf45MVck5ZH/G0Ly5q73xcUQONWuXIUHvXXvCulUl7L2FHts0QjWYWILdIRmNd8LPOq0qsyrxlqzrdAM4e2RlbCItdjWhzrC8fa66F9oP2fDF+kOJ4x8B/1jcfSw0hrCPMPUVQKFcGSU7tE7sYPjmjDwG10fOn47QNuolR84dWztfCXq4tlNzze3tfKX98H08pK7m3AOAqotO3ZCGkr2WQQCHB3Snvc/n+BYnOdYStEdklOziG4JeLdoi1bChOt30bF66VoF9K/TJ8pJqJhJNftc2AenyaytMm3Hh9hYZAhoKrfKOVhQS4zDK5in00tUErLQsRJ/Aw1BUtsnieeo1vBlBkV/D/MWiG9U+efc4/WNO9I+SiCwgNFVuoTFDb524LVwhxv5dycY4mIK4QUKiMaFatEYwUwSaA+rkx0x7aCZwyama5Ufz3yn4fTD4y8H4Zt+LZ7WJNHXOQWT9EQjc/+af3tzsY2wNzPMmC6qI8KiS+/5SZCAizCEkINT1Relkhuuhs7LX5yHgius5E24OxjEZzRtRO9GB7KVZSNMXVNhIcf9c6vquT5xwqS1mlPgdTgAMz4aDk/D/vC1tUrrvbgCXzv0MFMChSR01g+QmM6LgsZTZN3PtKoCnSlhCSiW7Z15oXGJzEFIKFf6Ej3tVArgqI/dvGEEgwM9Q38HybII/g6Wkj5aBM6+x8YALCT1yKZfLuDCrEgGQn0DlT1px0de+fkG4xMEJI83nRQYmtktv+Gyw8KkB01ceX2efUNUjnD+GLoImPNCOOlIJSxZGVTMPf8932lVIQJQg3UIphMKhnL/cZmISSl+I3TZwHhQIeMhZt9fa9TCPwdHKRKz3Af51sYFEua3HVG+KBbzOA3f+2R0evj7Gs0LymoT8CGDm9Xmt9gv4DKLcsKLoFIcEG919A09OUIzY/+qu2HNp+rIXx5Sf1kSHdk6g1fxVzTmtSEjCBVhS9nQs9B6sYQ/9Uu6h3x40YtxgLoUTPN5GM99u+3LLLi0/buBHVfOIfoTVbXsyuF1w+qTfvJV9fdK2ktpkvRImK+SBC5xSyN50T3hkRcFpFDFBMX9vqihCYREZQ8JMP1O+Id4WIXLcVlFkSWMjcRdt2NP/izhKUSB+0ILw7zSeK1D9c40dGfig02KaqWBXDN9fW81hOJe+YFS87D8bj6nylz7YLmtsgziNKUmVzLOPEGMInkwLFWzel7ZMTW1xrZ8Y4zEcbpoRq28Po1OWBeDfptqkO91QYmg7DMlTbfXLokwfn681BZhSZLlSL9S8EEYAWtd3l/Tcn6XkgpsLNNvVGBKajsGx0F6owsYEsoe8pM2i8SXJokerVlxu6W4SWJ+aftgan8A3mc+EgmGJU0rmkU8rVAIo4v9jCXEB+BnpCsBAlSU/Pk55NgR7sdL/nlq2p7/HAl2EMRCPuhjhPLixKkiET3WGLp+tyvq8Dcqopf0ywTzquf9aJ/JTkwcmlYsf1ZPQ375NYY3/Q4EeEO8cp8S6+cnuh6YWrj3+NX1VWNEuth24xjH5bicXFLF38dQiz5ioxf4bkfpQuXrjyqrOqJdN3sEXlV9BHF3v4TJGqsArOohFmnCctkoRFv2pKucEXBtVdYH39+SHk6YQs0DtiDoxDk8aeT5RjrO5hbJHUjeMpD93hzM9gxhN3M2eprpUwBLd17BskR0n7eCRg7tjnvwTRQtdsJmsyLxD8qmv1cootIES57okNdWQyhVh7BILIfN5COTW6/W7iPr4RZy6CIvkkXzPxArWTY/UBkpmONlP7zKmSXLKgppoZKV4ZGsWOltR3PlkbJIfStISY7aXWzWwZhxZ0o2yPhYeGjwUrx7tkTS/YBMnEsG+Kg5ipywam0/ki+xWW3UCoX9Fi8/1BQwWPGYEUKeRmTbE27MvcHX/bI28Xh7KxPCmUQjZf1R0K4OGYQ+qkm/Kl3u/avg9WZgc07iExDf+vPMI3I4mSnOw5Nu6/vi2LGPLUNN7Po1XlNSzZjtBhYWQzkham9XbpGwzxMj4U6q/GCImeVohMjFbawf88RqngkRHINfnNUvNh82WguYAszt2XctuHiCgN/VVEU7ynq6StS4juTXIzU288y1a9vWho0UR0JcEGeK/H71Mz5crWYMTe73b/ZoFr4dfyhqIF1tmTRfRg9oeBvPo4ax6V7DICRPKeVF12J2++mDn5G17zEtRbLtayHm+uTMjqL327//Dk/cF7XepFH9X3AeWizl2KYQDpRlKPYU+PQoymBQFyjp/ycOKbc80+cSOwWqZ0iX39kq8m6TeQneSqXKS55EE6QPPZcLqWbyF8MHANmDXExi6UfBPoop0prIaNWzMZwtbffXxFNI8a5ND1/4xaEExuo0KVOvS/4P5S5nBoYCMmMOBSjzkUkimGsZkwaAFj5s+3ZjO8tVV+u46+9qovFzrBLtys8UtxqinMcAf4o/XPrX9JPT0piAqEximfP18K8P2bdy1kd2abyTgHbygb12s6bTait/P9t9ipnan25fzQu7wDjRU1VbT2zj7LVpIvXgDmpfokQ9NGgJLO0p7UmpXcNcsNK9VGE3rfxuFiGj7mJXxuLLJOaYMwqkoqPxzAGC5NjXaeR+JqSQLg81aShZN//pHg4c/Y4cbh8MkLGdw8h+WnJlzJvaqpWHbu1KRr6+iLJvpKm5C6U6b6c23Ejf3stW2B44MJfnRu94MKhUUkbx+be9SyLMUgtzop59khMKP06Taz6gizfkaY8+voh7ikBEF7OghoWB9zcn/gU8ReHL8ANE3l+9FDg4Ejr47rwWrI++ZtvZLMKJ8Uac/HuOLyTKCSssciL2WT/JKYpGivHpo4aOv1uSpEr1/QjgU3HHJlcfpzF40NLEsb7lVQ9Zu76APQOBJqztdpKdAVUaKzNUx+YNq+ogS46F2O1aqtBHK8jgAVFyE1dQBSm1IGI4GW3xxWHU04btI7821ZKF2sq9mrbdYvArYCC0IZIVfti7CevaF4rpdJ3uwprkonk2vbX2xYeh4nHA2gO7gcIA9sD3CpbqKbY8w8MVTCb3UgpzlP5zTui86osKseCmrXCTgjv+JN/oTez3JT3aitxe0bB+FydZhOQQOsHvFCURYuuGv3jnS0fUQVyGBjkmlK1SXDqMiY/bLkZa1k2xbacvQzzJekmNvT4kocbDfCp7oqEozVmEns76B00YGwzpHE9SOleeJ0fvMhEdtNxLaXKtsklGE1fYNx+at5HJhdVldDuHNvjAdL3VyeIfaSM/iJJXsB9eBu2igH7Q/WZeLWEejFBMMmfHfLSriOB21cDkslZ45n0jBVWloGxJ/htCj28JF7QwOIxmoIgQdmc9h9U18clC2Vq5N+UFkulPu/A2RXGDA9H99j5739JOEl8IeHwi18e8JC+Dqpn5OL14XVXdffN/h0i3/04HL7vnX2MUm0IUMyjsNrEttsnYPlWXgCfyptKn7cjHVqlWg667iqSLhvj08gzQ2RLIjqNJN8OnVvtKUdaNXAiUrAdejZ9Kl4N0VBfuOftriSlBn85aTl1vAmC8dLH5Fxk+hZ3C3lV8EcGygpcjwSeFL8gr0x0uImliOGOkQXvvBcggG5GK7uutvB8cd3NHT19JBwbFiSr8vVMu89P90R7pxoBtYnlneksFBDICpkaWZnefMpOwuIqVnTe/WHckq/HlGPpPl0FPPAlfsOMr58O2f3SYZW5QqhN3nx4mf4Xh2bvQD7t1vKv4ztVmcjkS9bzKl3f1vEe46dWbi/RVtFLDpHtTAdZVtLsFdx78PhLVCtvx9qHntr4IBYAZzPTRbsA5RPXyr+bOQoaY8xoseOmGI1PlSX6Z9U6ZC79ffJ/ApvjVGVrYyNNeKFE4MmZ/tDgC/mYZUO3DJMYzesVbk6OPq5y6j3ca1cUW7H3SDF5Pzt+gLjjt1GvQSMfLGnivnjVrYlxnYHpIFzGfF9g+eF11NIokHljEO+jCuWZ+JeiuxmqOCVZLBJGRoXzMOngqALO3msI/smh+YRI9Bi4v89/VLAQyl5kLHVjUKVK56Z6nh8Ssg8KO/FKf3RhyMpp7xkwUuawqsLi6YPuN51tQqMWXlQbZwuk9vqBJgF4urPA0qgthp8/i6mtBxUI35RXyPkEWVqNKTmdXZ7zhehr3dXBRndVkazIj+HSDmvlRGkQSc0FMgafVGC0PHpFUV82jCF8e0Ut+2CcQXbzDk9NLxeD9XXboEjuhROlheJ0R2TBbO5Ul3qFLXAKTRMkiooU98BrY+UT3QlK0iJrCnU/HAiMa7JqkflV/SnN1mlT1M182nUpbvCWU04S3TeGFRBjVwFGIE+VHlx9gAj3hK591DnhLHfm6mri/5vUPH/H4lKvn2ZQ4GXPGd4byeqAiLluo/NVM7+6ElIuhcUulyT3qu82kZYtbQNdRFMjzlYth9T1yOk354dNNJVdsdm5WjUSPejNcB/5+0uQpwXfJAhFlkWjPNl0L6fdgKY5qKTGK9TRMYsCoUSH9mv7GmH7gzvY/yc8/QvnrpNpDpkgnNd/rgDrDxue7gXy5i+G2YTkGOLHFvcsLHi4Fqdn8qc46gZ6pH2YuJvYxqubdyK6X7b79odTKVOJ/zrsfJ0b62KEDH8oMLD+TgWzJp7THBV4F8XFQnI6mMmQCSrBxG+ibvtla2RueG5JWPSZjb04TUD75IontqoxidGQXFlhsMDcgc9O8neiaQa4cjy0v06Kjje79lm4Lsvzx5TfY7Ljy26C4D+meOSOVEc3rdqp0dJiAFzkveE+Q3QauFYl3iMV/5espP6dcoJDgwuyzPcBoltII9By1Lb9cMG7wMsAB/YJ25QBBUcieZ6MQB/8gBWJsfb21gGtbS6/1iHnzd12bV7W25yZYnOdY4bkCTgkQsadpNx0aftd1sKoYd5K/5S6GPbNJINsnijk1g1hiZttbwK/Rudkvm+dGiGWqdwwFtKDppCkC0TpGw1lZw83qJmbEHARN6RTbZhRva/L+qX1yDvmM28hwBzLWjwrlg9Yp9vcp//d/C+q3axR+9D1ZFzaE48BpXUTWA67XXmE1cm2FbtsiXByhHEP+NcX6azWq+xhKcmP7XUrjeOvht3+jFU9Ao/NX4WNQ+nojHoZC2FCYFaF/fUfs5ehKl/NJBID6Y1csckms49xnyArpu5TEoJIlxFThEftPZjQREE1qrD8Ue6cETNwhkPDOpPQ6MDeFGyvYKjDwQmDPs8kox7lRJ9WZCXy/gX91vVPdptITn7YnoK3RkbPRpdCi+5BZRWpWqN2fD3Vmucnjx4Zy1SCQHGlOYi2GYz2M7V5taaCh24Pd8eh7Gji3DsQfVLXYsaF05M0Zl+Ai7f8j9ul65DUBValWlzzyNd2dPg2cNgvHRC0tl7JT8ZRZ4wQO6Uf0Jw3njypKGW5FOQrzyqMCjrwd3A63W+Mgm88x1aPKHzNuW39Psj4LyeqTjUzaMwgjxDaQRo9gdsgcadneDTFoUtvREnbkPQYNavoMF0bj46eejaZFe0S5S3vxrmiuiNeZA923biIxMZ1oN9wJEZToZFlDWOi9BrC0CKX/tCuW2uZBrDBrhL9qcgGbnBOiloBMktCWUXVDfm16/EosT4bCAB022eqcY1sOVcv/+1KJqdOoi6GB8rLELPqlAmjigYsLVBK57wF1OXhpRkFOUVGFCG5FZ2BE/Sh4imUCK86FHRBaZpMK1s2SG49R+htl3TKnCPIAqCpL56LnUcKQFVq0+f0KvwoxXoR4MWL+xgcKAxMy9Jhve2KekK0fjuT6Jbjdkx6RABWCm8aHzH+BTMeK6ZGn5EznoxKOFFQz8XcSXz4bqvVNU1O9SiNyE5wIAbfR9HfNZSVey4uadeujyrIZw+uR4v1+/2SoI7XiBMKDkFeT+W4ampZZmiaJvmTA2HZvZ2InYuVybHA5LGXu67XeTqKkK1HLJS5i+6Xp/LDVt4zz2mhQrTuDOQpZ7Nt/HC6q4MV5rATCNYxZz+LtmGOjdKoRH5GWJC+g0awWxsVf/ueSS+xnZl4H1FNNPxudM8Ijbxi2aYDOalq+L24DOIploglto0MZyJzlF0gP9lGw/1vDuDHzC62ckMxSkE9RsIpPHSNmyhT+crD4/EcI1kRm0MvK0ZMlrw/29kBfRh6bvwxzDklDhl8g42+xXGOzxtm/b89fX+6pYZq/nGBkLvmJw0F+j0LJVXkFdMR2ksDGHdPOPm4ZIyXtwXQuBHpx6MmizBKGQ+cl0O4bCJK5BBarpa7tX+r79DuRu4iyRc0NqsxdXuvrxQF2kZ5l+0Hwd9iwq6/Up1xaQQhi/F8A1PR662csfExLtdiuQ7FvVuBM3EG+a5MbwH9N6GL8z3IPhFblU9BNZmbb4VPdvQvtsv6wgVbJIaxD0I4fVJMbJriIxyUvML2cMdLX8gsy3XK94xeWCYx+zlgec44UP3Y7tHYmC/YKzH/ihFuG8Eho+GB0CIQ+y2YDZdlkIgdmn56U46huMdit2MZw9sS0wqFzmzeLjUsS1/3muzrdW/hGUap7evchPFsZRGDmGS+VW6l9yqujTc+as9cLfBCAr7K6SADr8/rzshKD1nVpejLi8/8+CwJStd/6UPK8fA+f3SQerja73GJugPwGFSq8W8/RYKNkb6RjOjJWIadktMJ7aRWvyx8aMLJzAZVRlW/9k7OkAiNUqrueJYc7Cm8BMwAuVtSxuBBfkKfPKbOXj4jTiseObtkA8qgiF3ro0DUl8FZemVWBg/XJ5wbEScQ4xlHa65o1Rae04k2v3Tn09K2U5nyE3CzRuhFR7CiLLiChUmPVHLIEQfwecTG8Q9bTvDvKsbxSazkChXdgGUNypYXGvTgMzHfSW/SqBW0jkVfI8oEhM5oJxjVwBKkSrbjmvdAJj0yyOhXtEhixvb9lP59bnb3Us8TwGhWGJSMGbbbad89L8dRIT/+It73G6H1cUDB59LO9dWZhW6LeiepcH1K/giofXYrO9Zo1bpz2fEMz8sWaDE4fF18IgULtWXEGv8sbuVY3NMkYPkVbNfJqGz1k4QFYSRSSiVv+W3kx7bbDwz1wTaLNkwVK3n1VcvNBA48XwL1qnxYaQA3JmCcjmPXx7HcSoyrZhiWdJ/SrMFGEv9ZKFAexYd5BBSaTshfIsKy3QwCoWWuxMWD6csuqNA187/yO0wuTmffzzw6PII0iNubTP3ipdyO8qSUK4naWtNJZchquWp7d/6Pt0CCGJ5BzG0LVAUvOMw+7Sl6EQWw7iggTK3gYC21THLUVncMwhosazpsgg5dHh/OBnYST5XmJziALfqeam2MbPaquOQRmC+UhvZf08HLcmgoK/No9BQ+3Mvb2GubbS1BruW0PPHyJE0bwOfUQ/wRWI8Jsp4o7TfIPgUjvEgq7SESQ1VNMZOTFYXXsFNfDYXWZFQoZhScpmJvLFr6IrgipKaiWdJClxQUpQkFHgZX65NZTnC9VHAGi7RJunARHbPMDU2ZNmJBP3GimXOf/g6gHFb9cbGxjHM08oiayUa+QlpqBspRMt/5wIjCCGYHQoQ82iAG1pYH7QpLxghct6+fXhuAoNocIeHLMlUVNKQrVjVBVrhIvI4FFYIs+Cxy2xmBtvYeBHGAfWARlYYJxsLz69OER/CbIexz8YddktHuLRltxVII1pKImPh3kZuoIkrkeQTc6x/ujFKAO83aCYh6u0EEepFm0k5z7iwnUP9fQE9J7plnOJG/3CowtHNFldOBRSxl1nT3PouZUlugKOFbOQgtv/Znoi4PDhvF1+oFv9uTSAvfGyvk8Rc5xKQ2TiVfaw9KqZ3Gv1ENwHfwCmM0B78gAW7R0X97q2b/V2NHCZfZ1V+xXQiRy3WjoCtuIbTqfu3ezUDvB5szU7VH9Riw8Qn7PybLZn5qOQD5mtROjPWikTShSiOgmPDM3hQL56MU1sPej8GY39VOouYEzIVidk0G1S3H/W3yIxcSLl+CJGtR/79MGUJOc9VDqzd6qOksf/g8BXYzsV35EQOz0w3uLrFr0vbGXQzos6mE1V2UGikxSQxOkCbyXrj+4AunRzXyyayRdY2JyhKgPH39golotvttlzeRkjEDpUAaFFdhJ/uX1YojxtLaEXfONebrJc4zRobtk1jyEsUbhHn8wmbFhqn2PgXVlRWS3xNqe0Tv1d+M6p6Z5kZk4Mh1o0XeQiRG6gH5EhaWc0Xu461POzfp/cazYEMpY7TvIiVOKflX21NTBSyx/Q5QEGouP52jK0uCOd8wY6AGNuLJ9+EqRx6yQ47t/ivCbfhGJdAA/0fb41eKhXOFOL0AzWIcwZsjhPuMQIumhr3oUj2jUB6HcoQkylsYGAfYJzrdQGJG9k9lj2lEq2KEB4LqO7VMD1P/VwdJS0JXtfeh/zmNsyTl/ZuN568s8qy4f6Sj/6QJyJcuj3YUMU9g3GN9DQ24wCzypbaLCpBY9LlIbeSDPmPd/C3FA4vXtlZ3czD6q1pJha2dWNNkS+V7Sf5XZjXwBldPhTrHruG5UFuA72e5m4rAyrXbsawJV5FV4+ySFCJKwlD7tBFLYPQwoesjDR3lfjVBUkH4fNCnfVcz9NwUX72ZEWHVba4izeAIHkLXhfqH6MLFU/lR5kjrBQJkWLFp8ULyIPoEq10HcOPGdsKNoX5bkDQXLEmQH0kCP+10nOK+SXwM+IRyIMbOsTs8aWxM+6ADtRbjECykuJeeFDauPkp3uQQ/7yf2lcEhWJgWmvSxVCG5Oixee929PjPUTe+xkyOZ8y9+LVkfTKNN/tfmrEmPkS+K7qVXqOJdlVuc6VN2huwpbLE9P3ZaBkopj58B1/I2osvKJMnDthRPGU1FiG7kjWytWiqCYKmUhpSe6Ryo6bXzJqsBWy7sMbsFi+68riUd71Ciba25O+ObD6U4r2SwrtidYYhETcEVDncQ6nTmMWyrkdYyh3lRZTbvWUfXhZeDQokHlTT65G+YVh9HuMozOlh98jXNJTE4Q7j8zPEDcA+MffstHavP0nLdCprhKWLm2Dq7tBzyHcqLNcwaKLLFxO6tI7D8TaHcrw6hslxGOo0TfbKIpblRd7fF1JnHMNbEHk5DvOOIuzZHrIEIudNIlWKnc9mKpEAspce38irROEq8e84IzBqsUczxSEHRRE6+NPYgdwxUtLLAQnLKE/TNFdQ9Bgk48DmUOeQXgEIOgj4Aj7fX/qsYGwHhAZ1kwPit5I7NuXBdnC3EV41NshsWyOCjXZxktU8DfhaNeTurjftdDQRcWzgQ67SH93xZvX8Ass0YXlLFK5PfsoCU9OfJ8nrt0yHbSYP10+ORAYNHG0nXU3ftqgkNgRXRv0+W5wq7QfN4/rgAkCOHfSGBCul04fEzLu/NxFF81YGfC5okomPkHF4+9pspvgFz1uMXO9dWS5JBD0aR5nQ/fi8XmtaNVRVSe7Q3OI/sEPzVT+Lwwkcp13JDVU4Qm82W9atc/OOoRN5JiEoqusRC0borw4/oD1dfcB/9ZYjkY5+I0nXU8w7U/MkPF/1AiPa60X8G7wWecLJjomWYRgxu7zPjTGcKHhf72boM18gLjMLscwIvezwKSjfkG4qH2gGYuKrp+5l8sttAQpysY8VHguf/yaJE8F12OpZ2jOG/yL9ixf3ebboe9nTlDpQrgk88SpOOkwIPKL+9jDeb+DnPCVZJWVF+qFbw2vuIFOujXAxI71Ef+1BKcq28dA1OOOyZZSgVwOhwL43tTJbXvHAPc32TCmjLqdiDqddM7e+CDyaJtRAp313AJsMyQSjlnT7lPOB7hfIhez7LnO46T0nKsOg5mgh309LJnNtzA+QaohbzMuS4MJm8Nvz+iKgtmvh8kp05jR6WVeefdfA2uUt1X8GIv93KOBwrhHzXvyB8IsK8LOeVE1MLLQ0UZbsiX33XTlQToe+2glJNv4ERmVgFYPLMcJnkorRslR6ahjzx3KtEOXjHle6/zms3NYreRLdUJHX65SFDtGirTh9d115DVaPTBi0a8peLQaUkmFl63wCZt2zC+IKps/vrBfjMeSsqmHU2fDg1q6M8jDwGBZMNMktiomjSjnYtZ1BezkiZE8A3mqQlix9LcCnWgd/dd5dWNVkbe7xB/JT4HOMpXwhoQJI2soyMq8Wb/2XeL83ouu1cB6LJgcXsAd9A0T2IaOzyXt5Lvmwo4FkLAQ3G7MT3aQQMl4LwGQwmbIVLTLfbT0senMUPWcE7ueeuywaomOyy84ejNe81+gpEBgeKB8gh7uQUXBvJdkQBIexBM8lyIC196xNJE2JhnJJUMtCyJDZ2iQmrBX95Nxe8MW1Dm7oNgpKvoNWU8OwjE0T3pfwWQHNxDuZ+ilxU4/tHTdw8r0GS1/BUREPDqpV/mD2DlzAOoo0qtY1+aE1YwkoSeZIhVGiZheZAj7KFjg+NHIelx9wDNfYuU4X12vhdzdJixmLbBnoOZ8UWPMOKiSWNoGKkIituBd0RYAfA9ltADDP38s9eRC7OACyxzW6ldsmZS5nABQX3nB1kDIYxdrS2KnhUld1Q9rb7OssF8iTBtE/p9PSYPyiR3E+alxR0926JBvHijPkhQAnmpch8+J9eBgvXQBeSLj4Nv6bNKRmFBscHCRpV8IfqVcwKRiVSGOhjmdKGt5bx5VRIdLPZkbrgxtlKyzizweyQe3kPPPMJYSObX2uAST8RsTTW8aHXKJeroW2nongL3p6/vsf4OEmk238oeQCyYbtG26UI6FLStMkvKfzHUNakptCOJQgKTfxZLjLNCb4+l0osX7yBbHYYVXOL9JXPsuDh2s0RoWnXsfpQKCFPrPOqWguIN+H4chiaWi1ufnqW0XEYrCC6pYnn0Ux9lMBS1m7qF5+HHc8ZEOqOPzZT7d9B8ZxVXj06csgfBOxkdQrYOUcrQi4Csq+22PT21PJlpHUMqj5hTq4mVlsYaKv5IWM8AvBE8/2IEXYoU9Hn7kFaDkCHEr8t6x3rsqj+NlZ2dQ88Y6TAOnXTuruHz2VOtmR0d49kNK2mm6oaTCKXKV7/WAI6GDA5p5PfRF0XBNhFthsL4VNmA0zuEpd1+qzXoWPdyYEqTByNUJLYoF3EgaLIvnkdTrom+mgRN1tLwUpvNWwDUNRLfD2qbKKr9GPOHFCSAdovZCHcibNEHrbBNWwpttfxgYF6vnuAXIOByiwexWas1ARx93EZWW8gkJ2hsnwSZ45tkYiItfTVmzlP1no0YgsSGdRER2mr7ghcHHxN9+1YYWAk/oMMf6z6OCRaLgycYEyEXr2y5+MRytdi2Gb+KIPxfXH/uM2Wqno1oYinFT/wudjgM83gKkysxyhBtI7X2gLZG8aTOu0zOEElRI/0UI4t1/4RIrrcaaX3H4R570U75B/DIAAALhTse246t9F08f/yIQKt+ltDOQ0MlE8FVkynWwHUQMkL/0MvnTPhy0NkMtVmOg26n4YrHnsIjeH6Jehr8aWU+MmVucHRcIcdnV4AlJ/AeK6dZHyPPnBlLZZiTkfpuFUFjEOpbunhJ7FNmEEAXCNYYuQgeGe8xDYHHDuoFkTtvEG/XvbwByMSZxTITq0zory8tseYAVzt8dXNQFCBcU0vckKdFAA4NH4epfu6+7sAAbZXG1iwFW57HzPH035yexFApFnWq8584gwtw6E85QrhiaiUrSyfr11vfLy7C1ZawoDy9YjvJ8NRGY9NwT5NroS/VoC0ovFTYaLH9+6tASpi6U+mL2IP/G1hvviwiP/ds5E9t+9elbfKzQK1KcY8y68FYNgRZq5NdgD18KXjnbudiVxG1o42ZVcIM4zo2HhPXgf6YjWP3jYQ6w90da+rt8AQ+6rQMsz/J4BGmxYjZwhzOTxfNZz6yvstHKRuhoLF53jkU7m+faPAmhzwvxPgjxVxNLLYn05BcKxn765Xt0e7qCk51m/RBvAAWungVTjlWjGBzP+JCFCOCZ4lXfjIqTQR5qSjRO+5Zl2/5onwmCfXTcRANbxDmIIGKwdFpQ+AfqbAuXYzTXggd3a3AQsczazBleuZpo9JAf9l6rbLknt87b4x/WggI0lbI3iuiiJwSBd+wtie5FjAdcDJ9+HsJg==]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1141]]></title>
    <url>%2F2019%2F05%2F24%2FluoguOJ-P1141-dfs%2F</url>
    <content type="text"><![CDATA[P1141 01迷宫传送门题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式：第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来mm行，每行22个用空格分隔的正整数i,j对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式：m行，对于每个询问输出相应答案。 输入输出样例：1234567891011121314151617181920212223242526272829303132输入样例#1： 2 201101 12 2输出样例#1： 44--------------------------------------------------输入样例#2： 8 410010011011001001001001101011011100010000001101100101000000000101 28 66 24 3输出样例#2： 2519125 思路：定义一个数组val来存放迷宫，定义一个数组cmp来判断是否走过1.这道题一眼看上去就是一个深搜，把01用二维数组存下下来，搜索每一个格子然后判断合理情况，如果遇到不相同的格子就记录然后每遇到一个点就重新memset一下cmp重新开始噼里啪啦一顿dfs交上去，TLE了三个点只有70分 2.这样做问题出在哪里呢？我把测试数据看了一下，发现很恶心，n和m分别取到了1000和100000，那显然，memset是很耗时间的于是我想到把cmp数组的标记改为layer，代表所搜索的格子所在的不同联通块。这样，每一次去数新一个格子所能联通的块数就只要更新layer，节省了很大一块时间(这样就不用每次memset一次cmp数组我觉得这样的做法很巧妙)成功过掉了第二个点也就是n=1000, m=10000的点 3.但是还有两个点TLE，说明还要需要改进的地方需要我去思考苦苦思索，是与否有其他优化方法，果然，有一条很明显的但是一早就被我忽略了： 同一个联通块所在的格子，能到达的格子数都是相同的。这样一看，怎么记忆化就已经很明显了，我们已经用cmp数组标记过了当前搜索的格子所在的联通块，用layer表示，那么我们只要再开一个record数组，将已经遍历过的联通块对应的格子数记录下来，那么搜索到相应联通块里的其它格子时，就不用再搜索了，这是一步很大的优化，最终我提交了修改过的代码，100分ac 自己遇到的坑：第一个坑: OJ上要求的是直接输入一串数而不是一个数字一个数字输入的我觉得这个挺坑的，我就懒得换了，直接char一个数组去接受，然后再int一个全局数组去修改对应的值，这样做其实挺傻的，还有可以改进的地方~(但是我懒啊)~第二个坑: OJ要求的输出是输入数据之后全部输出，所以就还要再定义一个sum数组去存放数据，最后再全部输出。 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int maxm = 100010;int num = 0;int layer = 1;int record[maxm];char sum[maxn][maxn];int val[maxn][maxn];//定义一个二维数组才存放n*n的迷宫int cmp[maxn][maxn];int n,m;//n表示n*n迷宫,m表示询问的点的个数//方向数组int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; cmp[x][y] = layer; record[layer] = ++num; for(int i = 0;i &lt; 4;i++) &#123; int a = x + dx[i],b = y + dy[i]; if(val[a][b]==val[x][y]) continue; if(cmp[a][b] == layer) continue; if(a &gt; 0&amp;&amp;a &lt;= n&amp;&amp;b &gt;0&amp;&amp;b &lt;= n) &#123; cmp[a][b] = layer; dfs(a,b); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;sum[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; (sum[i][j] == '1')&amp;&amp;(val[i][j] = 1); &#125; &#125; int sum[maxm]; for(int i = 0;i &lt; m;i++) &#123; num = 0; int temp1,temp2; scanf("%d %d",&amp;temp1,&amp;temp2); if(record[cmp[temp1][temp2]] == 0)&#123;//如果record里面temp1和temp2对应的cmp的值为0的话就进行dfs，并记录到record中 dfs(temp1,temp2); sum[i] = record[cmp[temp1][temp2]]; &#125; else//遇到相同的联通块直接输出对应的record &#123; sum[i] = record[cmp[temp1][temp2]]; &#125; layer++; &#125; for(int i = 0;i &lt; m;i++) &#123; cout&lt;&lt;sum[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-022]]></title>
    <url>%2F2019%2F05%2F24%2FLeetcode-022%2F</url>
    <content type="text"><![CDATA[22.括号生成难度:medium123456789101112题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路：应用递归的思路来解决这道题只有当左括号大于右括号的时候才进行递归但其实递归的实质就是栈的实现 代码如下:123456789101112131415161718192021class Solution &#123;public:void val_generateParenthesis(int left,int right,string str,int n,vector&lt;string&gt;&amp; val)&#123; if(left &gt; n || right &gt; n) return ; if(left == n &amp;&amp; right == n) val.push_back(str); if(left &gt;= right)//只有左括号的数目大于右括号再进行递归 &#123; val_generateParenthesis(left+1,right,str+'(',n,val); val_generateParenthesis(left,right+1,str+')',n,val); &#125;&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; val; val_generateParenthesis(0,0,"",n,val); return val; &#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190523]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1443]]></title>
    <url>%2F2019%2F05%2F23%2FluoguOJ-P1443-bfs%2F</url>
    <content type="text"><![CDATA[P1443 马的遍历题目描述有一个n*m的棋盘(1&lt; n,m &lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步 输入输出格式输入格式：一行四个数据，棋盘的大小和马的坐标 输出格式：一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1） 1234567891011121314151617181920#输入输出样例输入样例#1： 3 3 1 1输出样例#1： 0 3 2 3 -1 1 2 1 4输入样例#2：6 9 1 1输出样例#2：0 3 2 3 2 3 4 5 4 3 4 1 2 3 4 3 4 5 2 1 4 3 2 3 4 5 4 3 2 3 2 3 4 3 4 5 2 3 2 3 4 3 4 5 4 3 4 3 4 3 4 5 4 5 思考:这题就是一道很典型的bfs的题目根据题目给的首节点，来存入队列里面定义方向数组来模拟马走的八个方向然后把首节点存入队列，然后取出首节点，依次遍历八个方向，然后如果可以就Map2 = Map1 +1这样的话根据这个递推公式可以推出所有可以走的点最后还记得定义一个path数组来判断是否走过就行了 这道题目里面的坑:题目要左对齐宽五格所以要printf(“%-5d”,Map[i][j]) 代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;//P1443 马的遍历int n,m;//定义const int maxn = 410;//定义方向数组来定义马走的八个方向int dx[8] = &#123;1,2,2,1,-2,-1,-2,-1&#125;;int dy[8] = &#123;2,1,-1,-2,1,2,-1,-2&#125;;int Map[maxn][maxn];//定义一个数组记录棋盘上的int path[maxn][maxn];//定义一个路径来判断是否走过当前路径struct Node&#123;//定义一个结构体才存放棋盘坐标的值 int x,y;&#125;;queue&lt;Node&gt; val;//定义一个来存放结点void bfs(Node s)//传入结点&#123; val.push(s); Map[s.x][s.y] = 0;//定义开始为0，其余的结点都是依照这个点而来的 path[s.x][s.y] = 1;//记录路径为走过 while(!val.empty())//如果队列里面不为空则继续循环 &#123; Node temp = val.front(); val.pop(); for(int i = 0;i &lt; 8;i++)//八个方向来进行探测 &#123; Node cmp;//定义一个中间变量来存放数据 cmp.x = temp.x + dx[i]; cmp.y = temp.y + dy[i]; if(path[cmp.x][cmp.y] != 0||cmp.x&lt;1||cmp.x&gt;n||cmp.y&lt;1||cmp.y&gt;m) continue; path[cmp.x][cmp.y] = 1;//记录为走过 Map[cmp.x][cmp.y] = Map[temp.x][temp.y] + 1; val.push(cmp); &#125; &#125;&#125;int main()&#123; memset(Map,-1,sizeof(Map));//定义Map上所有结点为-1，如果这个值不会改变则说明这个点根本走不到 Node s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s.x&gt;&gt;s.y; bfs(s); for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; printf("%-5d",Map[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguOJ-P1162]]></title>
    <url>%2F2019%2F05%2F20%2FluoguOJ-P1162-dfs%2F</url>
    <content type="text"><![CDATA[P1162 填涂颜色123456789101112131415题目描述由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字11构成，围圈时只走上下左右44个方向。现要求把闭合圈内的所有空间都填写成22.例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：0 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1-----------0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 输入输出格式输入格式：每组测试数据第一行一个整数n(1&lt;=n&lt;=30)接下来n行，由0和1组成的n×n的方阵。 方阵内只有一个闭合圈，圈内至少有一个0。 输出格式：已经填好数字2的完整方阵。 输入输出样例12345678910111213141516输入样例#1： 60 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1输出样例#1： 0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1 说明: 1&lt;=n&lt;=30 思路:定义一个a数组来接受方阵，然后定义一个b数组，在a数组的外围套一层边界，也就是套一层0，这样做的目的是为了让dfs边界的时候能够把闭合圈以外的部分都能够标记(也就是染色) 然后定义方向数组，从(0,0)开始往四个方向依次寻找两个边界中间的部分然后标记，然后b数组对应没染色的地方就是a数组方阵闭合圈里面要找的 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 40;//定义最大的边界int a[maxn][maxn];//用来接收方阵的数组int b[maxn][maxn];//把方阵外面套一层边界,便于dfs寻找边界int N;//N表示N * N的方阵//方向数组,依次为右下左上int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,-1,0,1&#125;;void dfs(int x,int y)&#123; //当dfs寻找值碰到外边界和内边界时返回上一层 if(x &lt; 0|| x &gt; N+1||y &lt; 0||y &gt; N+1||b[x][y] != 0) &#123; return ; &#125; //如果没碰到边界,继续搜索,令两个边界中间的值为2,并沿着四个方向继续搜索 else &#123; b[x][y] = 1; for(int i = 0;i &lt; 4;i++) &#123; dfs((x + dx[i]),(y + dy[i])); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;N; //输入方阵 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(a[i][j] == 1) b[i][j] = 2; &#125; &#125; dfs(0,0);//对加过边界的b数组进行搜索 for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;=N;j++) &#123; if(b[i][j] == 0) &#123; a[i][j] = 2; &#125; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-019]]></title>
    <url>%2F2019%2F05%2F15%2FLeetcode-019%2F</url>
    <content type="text"><![CDATA[19. 删除链表的倒数第N个节点难度：medium1234567891011题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。 我自己的思路:(两次遍历链表的想法)先定义一个num遍历链表记录结点的总数，然后定义一个cmp = 0，当再次遍历到num - n -1时就表明这个时候的结点是在要删除结点的前一个结点，然后再进行删除操作 这题遇到的坑：不知道leetcode到底有没有头结点，结果最后发现没有头结点，head对应的就是第一个结点，最后定义了一个newhead做头结点来进行操作，如果 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* newhead = new ListNode(0); newhead-&gt;next = head; int num = 0,cmp = 0; ListNode *temp1,*temp2; temp1 = newhead; temp2 = newhead; while(temp1 != NULL)//统计链表的结点数 &#123; temp1 = temp1-&gt;next; num++; &#125; while(cmp != num - n -1 )//定位到要删除结点的前一个结点 &#123; temp2 = temp2-&gt;next; cmp++; &#125; ListNode * flag = new ListNode(0); flag = temp2-&gt;next; temp2-&gt;next = flag-&gt;next; return newhead-&gt;next; &#125;&#125;; 官方的题解思路： 方法一：两次遍历算法思路我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。 算法首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。 Java代码如下:123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next;&#125; 复杂度分析时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。 方法二：一次遍历算法算法上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 Java代码如下:1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next;&#125; 复杂度分析时间复杂度：O(L)，该算法对含有 L个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。 空间复杂度：O(1)，我们只用了常量级的额外空间。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-018]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-018%2F</url>
    <content type="text"><![CDATA[18.四数之和难度: medium1234567891011121314151617题目描述:给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路:回顾一下三数之和的思路:三数之和的主要思路在于双指针的遍历先把数组从小到大排序，然后再从nums[k]开始从左往右进行遍历因为a + b + c = target此时只要 b + c = target - a相等的话就算找到了然后就是相当于定义两个双指针分别对应 b 和 cint i = k+1int j = nums.length() - 1然后 i , j从k的右边到数组的边界，从两头分别开始进行遍历如果nums[i] + nums[j] &lt; (target -nums[k]) 那么就说明i还需要更大一点才能相等,i++如果nums[i] + nums[j] &gt; (target -nums[k]) 那么就说明j还需要更小一点才能相等,j—最后nums[i] + nums[j] == (target -nums[k]) 的时候记录数据这个时候进行去重的操作，因为第一次相等之后，如果i,j,k后面还有重复的数字的话那么就会有重复的结果那么如果遇到符合条件的重复数组就i++,j—,k++去重 四数之和==&gt;三数之和==&gt;两数之和跟三数之和类似，多了层循环遍历数组，同时也需要注意数组的去重操作1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); for(int k=0;k&lt;nums.size();k++)&#123; int i = k + 1; int j = nums.size() - 1; while(i &lt; j)&#123; int value = nums[i] + nums[j]; if(value &gt; (0-nums[k]))&#123; j--; &#125;else if(value &lt; 0-nums[k])&#123; i++; &#125;else&#123; vector&lt;int&gt; list; list.push_back(nums[k]); list.push_back(nums[i]); list.push_back(nums[j]); res.push_back(list); while(i&lt;j &amp;&amp; nums[i] == nums[i+1])&#123; i++; &#125; while(i&lt;j &amp;&amp; nums[j] == nums[j-1])&#123; j--; &#125; i++; j--; &#125; &#125; while(k&lt;nums.size()-1 &amp;&amp; nums[k] == nums[k+1])&#123; k++; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190512]]></title>
    <url>%2F2019%2F05%2F12%2F20190512%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190509]]></title>
    <url>%2F2019%2F05%2F09%2F20190509%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190508]]></title>
    <url>%2F2019%2F05%2F08%2F20190508%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190507]]></title>
    <url>%2F2019%2F05%2F07%2F20190507%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190506]]></title>
    <url>%2F2019%2F05%2F06%2F20190506%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190505]]></title>
    <url>%2F2019%2F05%2F05%2F20190505%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-002]]></title>
    <url>%2F2019%2F05%2F04%2FLeetcode-002%2F</url>
    <content type="text"><![CDATA[2. 两数相加难度 : medium题目描述:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。12345示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析：两个非空的链表表示两个非负的整数，既然是按照逆序的方式来储存，那么就应该对两个链表分别从头开始遍历进行加和操作 用x,y来分别取出两个数对应的数位,用carry来记录是否需要进位先令carry = 0,再计算sum = x + y + carry;如果 sum &gt;= 10,则令carry = 1再让 sum % 10来组成新的数的每一位如果其中一个链表有数可以取出,而另一个链表的下一位为NULL则令为NULL的那一条链表对应的x或者y为0即可 然后最后结束的时候如果carry还为 1,说明最后还多出来一位,则应该再额外多进1。 自己在这题中遇到的问题:Leetcode给的构造函数(struct跟class一样啊，我真的是有点傻了)既然它给的有构造函数ListNode(int x) : val(x), next(NULL) {}则初始化对象的时候一定要调用,那么定义新的结点的时候就一定需要一个初始值(比如0),否则会报错。 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p1,*p2,*p3; ListNode *l3 = new ListNode(0); p1 = l1; p2 = l2; p3 = l3; int carry = 0; while(p1 != NULL || p2 != NULL) &#123; //如果对应的数位为NULL,则直接令其为0 int x = (p1 != NULL) ? p1-&gt;val : 0; int y = (p2 != NULL) ? p2-&gt;val : 0; int sum = x + y + carry; (sum / 10)? (carry = 1): (carry = 0); ListNode *s = new ListNode(0);//定义一个新的结点来存放结果,一定要初始化才行 s-&gt;val = sum % 10; p3-&gt;next = s; p3 = s; (p1 != NULL) &amp;&amp; (p1 = p1-&gt;next);//代替if的语句 (p2 != NULL) &amp;&amp; (p2 = p2-&gt;next); &#125; if(carry)//如果最后carry还为1,则说明还需进一位 &#123; ListNode *s = new ListNode(0); s-&gt;val = 1; p3-&gt;next = s; p3 = s; p3-&gt;next = NULL; &#125; l3 = l3-&gt;next; return l3; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新の开始？]]></title>
    <url>%2F2019%2F05%2F04%2F20190504%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>不知道自己在说些什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五一假期的一点感想]]></title>
    <url>%2F2019%2F05%2F02%2F20190502%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-206]]></title>
    <url>%2F2019%2F04%2F29%2FLeetcode-206%2F</url>
    <content type="text"><![CDATA[206. 反转链表难度:easy反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 自己的解法：思路:至少需要三个结点p1,p2,p3来完成链表的逆序首先从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点、第三个节点。实现链表逆序的完整步骤如下：1.以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。2.三个临时节点引用p1，p2，p3分别向后移动一格位置。3.重复第1步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。4.重复第2步的工作，三个临时节点引用p1，p2，p3分别向后移动一格位置。5.继续像这样子迭代下去，一直到p2是空为止。6.最后，把head节点的next指向空，成为逆序链表的尾节点。并且把p1赋值给head，让p1所在的节点成为逆序链表的头节点。 实现代码如下:方法1：迭代1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) &#123; return head;//当头结点为空，或者它的下一个结点为空的话，返回head &#125; ListNode *p1,*p2,*p3;//声明三个中间变量来交换 p1 = head; p2 = head-&gt;next; p3 = NULL; while(p2 != NULL) &#123; p3 = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p3; &#125; head-&gt;next = NULL; head = p1; return head; &#125; &#125;; 方法2: 递归递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø 若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。 n1 → … → nk-1 → nk → nk+1 ← … ← nm 我们希望 nk+1 的下一个节点指向 nk。 所以，nk.next.next = nk; 要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。 实现代码如下:1234567public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p;&#125;复杂度分析 时间复杂度：O(n)。假设n是列表的长度，那么时间复杂度为O(n)。 空间复杂度：O(n)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到n层。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九周小结]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷Oj-P1101]]></title>
    <url>%2F2019%2F04%2F24%2FluoguOj-P1101%2F</url>
    <content type="text"><![CDATA[洛谷OJ-P1101P1101 单词方阵题目描述给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：12345678910输入： 8 输出： qyizhong *yizhong gydthkjy gy****** nwidghji n*i***** orbzsfgz o**z**** hhgrhwth h***h*** zzzzzozo z****o** iwdfrgng i*****n* yyyygggg y******g输入输出格式输入格式：第一行输入一个数n。(7≤n≤100)。 第二行开始输入n×n的字母矩阵。 输出格式：突出显示单词的n×n矩阵。 思路：1.用两个数组来表示八个方向const int dx_shift[10] = {1,1,0,-1,-1,-1,0,1};const int dy_shift[10] = {0,-1,-1,-1,0,1,1,1};2.在搜索到y之后沿着一个方向搜索izhong，直至不跳出边界为止，搜索完毕如果符合条件记录到另外一个数组中3.j是步长，这里的j正好对应了yizhong 的第j位 所以正好可以对应起来dx = x + j dx_shift[i];dy = y + j dy_shift[i]; 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//P1101 单词方阵int n;//n * n的矩阵//方向数组表示八个方向const int dx_shift[10] = &#123;1,1,0,-1,-1,-1,0,1&#125;;const int dy_shift[10] = &#123;0,-1,-1,-1,0,1,1,1&#125;;int dx,dy;const int maxn = 110;const string cmp = "yizhong";char Map[maxn][maxn],result[maxn][maxn];void dfs(int x,int y)//x,y表示当前点的坐标&#123; for(int i = 0;i &lt; 8;i++)//枚举八个方向 &#123; int flag = 1; for(int j = 1;j &lt;= 6;j++)//对同一方向连续探索6次,直至全部符合izhong为止 &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; if(dx &lt; 1 || dx &gt; n || dy &lt; 1 || dy &gt; n)//若越界直接跳出循环,换一种方向继续尝试 &#123; flag = 0; break; &#125; if(Map[dx][dy] != cmp[j])//如果探索的第j位不符合也跳出循环进行下一次搜索 &#123; flag = 0; break; &#125; &#125; if(flag == 0) &#123; continue; &#125; else//符合条件记录到数组中 &#123; result[x][y] = 'y'; for(int j = 1;j &lt;= 6;j++) &#123; dx = x + j * dx_shift[i]; dy = y + j * dy_shift[i]; result[dx][dy] = Map[dx][dy]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cin&gt;&gt;Map[i][j]; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; result[i][j] = '*'; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; if(Map[i][j] == 'y')//如果搜索到y就进行搜索 &#123; dfs(i,j); &#125; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= n;j++) &#123; cout&lt;&lt;result[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷OJ</category>
      </categories>
      <tags>
        <tag>每天ac的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八周小结]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! U2FsdGVkX18uRZ4iRfseUIxD1o/d2ACXc3gSGu8bUljB85sqWs0Yuq2E+cfBXoyqjeufakT1tO8dyPALkqVLJT80xcsI3QFs+BTH2O7RavS9Gy4BLmNJQRoQJLoSisMLaZrYlvbnuhks9Uf8vJgJCqHUfGLX3/V7hHHVQk/zMMJSmZZN4csJKH2xhsWZWpxLTy5NRWg+VtyDv7dhHy57euk5CFwpwk3ZNCT5+WhQEC0Dw1+MOpqpqT6/iXFVLUoHs/LTiDw+64RWJOlrwDycvSTjl4CRzj9ut7wmwo4d4otcFMMWEdgeAmY3NF+T0L7YRSMeRKyxlK1VO/8BEeJI/yLjdIPh0oeyGo0/WnVWa7CakTlp1LC5Vra1uHyqGXf4FZh3S4kDan33KnXtnDGAthOi3vvFuOeySxng9uqPrX4/5CfCd1t2Xdqci5OuhvnRfe6AQsUfCuY0BVQFSlTC1CmJ6gPE9dOliw3N2Zkv3OpsB/T2gQxd6aqvxzf2ay89grTH7DGRuPR+VZILNfzvXlu5jlkvK51MII2OGFrm/kK5+oLWSIpHIo54NgAbN0vBrxZgyYnmhSZIXrsbg0nvg1niVSX8CCnMzhTdSxwbcnIINegkZuSqAbd9ZHHTP7dp5jfKwsR1IeyJ0zfLlIF5LExl3P+5wQX9nfIBpABK185tTB71eSWz94+xoqvlijeTXiAn33RIivNmHH7f2wbzPqHsuSshVbnxWiqQgYZZwTkadRLdJwIZgm7fc2j3EEArTzKeAB0zhKML11ZcAnGrRj06nRp2A+ik/z1DUhF8DZuwsPdjRY6pAPmlqUf0aZrTMcrAJfAF3MpAsz0k2x0O/fxhpwM2FVd59yr+LX5a0Gs8r20O1RaNYLzwD+QhmHWNJeadhs8msrHVah2StuukzeCWFeVNZ1m8nvhSpr3lQZwOlsopJ4V4HQ91/+U+6pg/aJNl37j6IUoik3I8gfNvSW+9FZ1Fd5Z2i6QroUc6Xttq21QsfnTA5UAQPS3Vecvw3ZySDwCB1EVzrcA/KHH42lHfX2nnNCZlc6eWPC9dLyQuWNlfIUBQ5w6bw//afQV3cRcwlWnMj3+wQ5LTQ7eLWxM1QJwTG/ZJkiL9wSe/uE0nGR2bgC+anE0yRoBx4LbowhPEWrnya0/ASj1CYexVVQ27fLIbHXyRAOidJBJJUPs1D715a4cEXtU3sWBhT5mLEboAPAYceB3YyZrq9doBcXze2elMb6f2AbvKRQSS11Yah70whVU54bBqVj1FwyJWtTb9HEOVUw+W14RrAuwqmAoG56pbOLvFCp96ccRj/nT41HZhMeVrCkf+aPsoa9zFsj3xYo7S+XCPJsMHJRjlhTX6tJDZe9nyCebk3qnLrk3DpVKaoUYU2XyNkhsJa4p1zbLXysSR9a/1e9Ph6SpOdEsOIP0GjVc42x5/ayeKyTdt6GyTSWDmhd0Xv7yQef6x+1aiRyatpbphseuSiF5ukbB7OOEjR0SgFVxTgWWoA6ct34IjovdGN5Sf8Xwd5wgEb4U/w+1gbNDIxjNtc+n9hpLsPTQJHC/EFa9jIdOiN4lwl539kAOiICnmX7GPzSQpFdxa3MXiszkVYlslZgMom/iGDEYqvXS4wSj40OWshKctkOzyI5JqIHuA66GROZ9mKq4MCkl5+3N2JBw8+PGHV98B0irvtkVy8/ZQRggOWSmem7ScUy6TGz4es1qASHT+GujqFH88GxhCQxK505OMPxLt6Rck/v+2aq9ERnDXlcBay5beo+i13c/rs54D/U3+LHW5RAKTZZWuAm8IdsSz1HPJo4qHH/Pl7cSywt93M+WPpjJCvrSHx+PuJcflIYrVjFxOSjAJ/8rZEwryi2QELsUkgn4p9Rc6MmeCZ5xlY73JsFiKuphv5bXqaR8Sphu8nVf7NmNsmcKuF0HwFlf3HotsFJffIUnyHsoulzK7Ro8/s2E6EY1a17Ae/kdaRVNpA5trbKciwtrhuCBw0PNUTCaPyICl+iVIiW9TlISUujCgFzeFP0mI0dIrb9gMH/7oh2X7BZlgtLRxTgfUDuF1QltCyoeWKt69tsCnf19drradux/5YlpdyADTDq9XMUBfbkIE4xVHzc/RiNVAxNSY16v0RWpoCJMyfyF+pUwUrPkGFitX+uWF+cHtLOBBR4BQN/t6YD2Uncfuf9SkpD2oxLRrsRfZo6abCh5EscoZjSjPIXfWO5715lgixhtI645pCZ7Jyi6quI9/K2kgyejeO7O4T9e59Z+iyRQXyk5CQrduWWik7rluRXzjtJS4qrQH+aYABpXiF1H01cTooUa1mSoYFNeKOc4JSgy7kQ8Z3Yyb3MRYBS5WoLLIn6BwHbCbM0ha7F1X+BBvP442d624jePBrcnPCxuX730vDtq/xM2cnkM5Pv+lKFGLUg5uREcZ7svGh0dXbLkD5oYTw5gdQ0beygVG6o1+os908e8T7NI2uQNcWZB7AzT4PBCOM2OrTRju+ATq0XXZqpa4Hj9FJ0pJA80pJHkuU5wFvMIOIJZo3xUN6h++6EJzRsLipY5mTQRmQZcOA/KB170P6aBt612lTdP3wYI5e1eMSNJKBzr++vgwQq69i3Pka6SUU++UIpVyU34bSrjbH+ICf8EkwWvJyuUAZvdgLp+lwPHAoAUjSyuhx+JgObNfN4TWhb2wSsWcuGp5qnM1J3Asc0YYZq/4fA4dCoOr2ocIyJMxj7H1WP8/JkTD/+zwBlv+ELEC/0Ni9a4wuA4zhSi8adBix0O/924UNapW1/LyYMtwaRJGZRu4l/bPykjamvHgkJaDRuTRlLh7ZmIzriwPzm0DvplOI4iABoomdANJYh5cUYQ5mnWRAYmZQCY760oNJXSC4TGf8X498J4hfq9gWpeA3ociuWhyemFVzJIu3Hcjy1OlbrSA84ouc4a6SFm33BAf/GY3NZtIyCjij+BcTdpJhZ7r9wDD2Rvpj39H8KQwddyjwAEGZIICdZBxcpi5OLxen5G8vesJc9YEDHvCRaY4BqXs5XNbdPK5rrT361FPlc412DJag9E0umG1tzbTFhIrCm8fyKjW+ceUEIG+yYGXmRCDalPhwgyaNGvl4WiEwgdzhBLZQYdZZN00+fTuNfiffPDgPqKskqV7oM/XdsUHYhY3hKrenjXpYqzDlhC/Cir0OMNIV37hGzRlS4Fe61TbzCW3sYJk3w7j3Hty1ExTGa6Bxv8WJ+i/GBXaufOh/2kHmMH738+F7GCwcuvestde/vcrdPGoDK031JEMNR/g9f/ekHB6TSP3jZ9uU9jDza4SIFsuzktr27s2o8GrvdmTplcIfTjuJ7/kaoR1PsXmPj9Q3+F3npgNOgV1u8qfMjlmoNa53+Q6CEmHzbr5R6DbO7cAfjyIWai+mmySIGd71ss2P44tNWL8a0NwcLqcGwXVQpeMdK8AbiCd5BiodyiM8GC3i9aaP2ka5ttfiO3ag9zeWz28O0ftXWHbVZdTqNVeeyHKisEKmQuIc/4BVgYRDq6ILjQUjUK07pLKPqmLU9rafBH1yqk+pp4JcvQnh0HdI9ICty0cT09aVGXhsRuFnHUDNoE8qjqgsBEv2RJHGKWkxVjwos7dKSAHGmHrH/oLsrEIkp3YJkFDXfpQGkrqyvUfemAJ4R2XS6pLtmOhvF3dfIQc5BFtXkmQx2qD8EKg8fID7HiuqNfPh8SfyX98cRJ3SkvLsJ8n701J61vHcbY3eKkhjOjPrCZwWGB3gOb1Z2mRB0MFTG0Bi/mZU6ZbrxINb7tVxoh0PUcAXl8qg1H9AcmJacr7BR4qPesBS/0ec4le5HBxp9o7ifDNJws7/qROqp0BpyxEtYZap3QoToJBkecFTYN7O2hW20pAvUKE0v5eqipVqUOUr7fYziU53nyWn/sEXab6mDWptN7zl7vBd4RhtK5UZa2JU0mbyxS3dNN4TQOYTb6hJsUTATS2wvCtEbZwRsptbJXwj35fupfuvoLq59V/1DZGRqrQ23cXVKDNpCjnl+e+8lc8HdPdO3mZYuPHEc25qtRvkZjGtGbTNisWA1mu36sJfl3aVjxgSvO54w0kvHlfplENwYE1UMp9Qrm2lH8ubs28krnzgKfbhd16XupTQ+iab9FsKrhqwGAphakoo1dUPZclEK9vt6Tj5pAf+gD+iiKt2C9oRfpP3QxlmrkSezHaP9qT6rcCOuYJrltMVNyeqZmnXiIGC19R+TkOx+Esz1V1GoUPWraXq0xesCC4lHNWRBDWdaqbv0fuq7c7rPLFQIvHldbn/mgtg6FUZeu77CFufmBFSS0qkkVHVzhOWzfGk69PJ9qxmbVenX4h8RfHuDRCF49HRoiAAjEe9gpk7o+xiU+tdqcvZObFcMM+FRpTJ3X0ZfRfb+5HfQRbI0bRqJcOgN+3T9WI7fIHN2YPx+q/Z5OKlSPlZ4OkRJh9DVxK71qSnNewHPOj3b9ENzwgKqcfOyO3YVwCvDnl7y+PRQIKEdX+7rcaeR1Dm709DTIGU/FhSqujdRqVb5RCRo40Eau7nod944Muz20tTyOKmRZpRwqaCdDlYnK2xosVINioAWX8P7neuj1Mwmg/zPD51RNSosQA0rHt5J+WVn/uH8maRDoAz5ffhlwAk4r1X51/ysOt+Ac+BwMBGW/oA4Uj85DdbOeynTEyCK2an0YMfm6hat87WrzS2Nfo7PRvW0sWx6SayX3YKnUGC1WZ9JYRS0ppclyaSjEau00eS4QKyrPdI4A6X7JLDNZTrjorElZxzlkT7HqhdMPf6URQ/z/pKiffP3lVswEhil9UH5L5Y8i9SmBzWabyIMbYJzY3qhTQ6Sv7LhLqN24XgWiiPDsErpP6SM6US4hpvApdWtR/97nazDt66N0498oBOQYeZ7tFlw0h9jGij7BFqrlSHFfB6Mykc4uI8rEER12hIgFRlds5quccHNU2hTyWPnwa4Ne8g+SXTGs1MNJQWmxDD9tawZfj9LZSgRl8hgLN2mf35XpjKIn5z6r4FTpCpl2V/fXw86nkRLIXXNQ0dMSQrDPWj/omVzVevHFBPvRBOvig9+X1OqH4wQpAdrwBzgBLzFITd8lNIBUSpQkfDp+1MIGwDGjx6m3Odp2sxD+IBtZaqXBteR0HquQfTG7NCWW+Nn3NUUBB5M3DEEhWBWhY5KtTVSgmIlDtAyFJXadVPo7mePcrn+G6kprmzCoBEJuYAP86/oPRcF19+TnAx6aTEJdXchJgp355VxlKrvF8dTQ4tmOivryZSr+TG0uLhr4UvnTkBzFlIOXadAr2koRbrgYBNgnBsATnL81zI6hDQwRdmfG8jaIe8TOy3vyPCqR++krO2bZlgtfbavM3rXseU04Tg3dW7c4RpoqYcoYPoDlLMkMqyYvesFi7iPUG8kYTQITxuNqjgvpdSRC4wxLIE0CYpE7Xpaba2Bj5yRTlNFSV9uy5NX3NWQUbkhMs8PcLnKIe7MA1NDYF+6DR4oR5XWnpRYN4x7eaVtZnlPD8wH8wufp9wVNEwnaTWXBVLVpCmHZUsmxxg6FCr1AfUQwBLaCT5J6eGc/GApuNzUzZXZppxiUyzWiLh1I4cVW+ppqwVGvtZ9u6XVU1HH+aRSqj/RJcwxedRHf42CHOriqjVPg5zCG7ywjFU8lf2p/vfQegTvv1INo+bU05LMXh18jHUfvNK9RAUpcwH3pEV1SgKZwcAQTQMO/cF5EXXUB3byxeY0AwwQSpYAZbsK1gHqXLjslQEbiFvnXJKWMVTsXfm6zDj7jcgYHSD2xLzllqtGRj33pO8MqTQSr7eKW9TRvYkA90TpxZ614MnjYejIMFdJFIWbcBPg/nNGuXLEA9PTM2VW6lvTODCEAPffgXkN9+ocRwvjY2uU+vragUqHP/PgXUwfphyQ3rygdbb+IytJunLeCNjnsJvlFWrBHuoQVd1/3wRCXp4uvBsFVfyeiZm7LoCu5f4nJ0SgwYIfPlQdfnhY2a3VHPtEQbsH/PfNj4OCC3dJkshPFwoVYOiGW016EN4mDUNOjmMRn+IZWD2Kaed97fMKW+57DrwqhgalKnLG3UOx4flKM6K+lLiwnGkJDV/vzc+Snw8Z6pjQJ5VOsKmJIxqkaF3QXzn5Jtwt58EswcxZ/z2STgbV0MkoHlVPxWXaAL8PTKziUyH/5hXAhaeTxdFGM+u2XxZvB/OS1mJxCxzGfFqmPEsz9gRt/eHIWELkIqAplgERSx+kqHauAM6ouk/X2DRWsp+I58h4KEV+tKko6jMDzqU/PUA81r9bA4K4ECusS43IicP6ijpGQmps0vZKnN8ZM5hDKozanTiU6xpS+l4+34PmYTquFw4jaFIYHxWpwqrjTFNNL02GbRzW6MOKHr0chuYcVK1QPur3f0B9YTRP0NzxI0b2oaQHWhoZKePVYvxaZoiTVGFL4yJvXDgev5tuthnI9ABGeLZB7m5lhp1mY3inG2uzEKWOurj0qZYe0FyedgwZSeai2DjRJGhyYuNLd0GRK76jjfgPXa8YsFlWaEjoUqxrSqGlR54v5Vv2N/QR2Dc4pizgMnUp13AeJ8YVVCFcirV4kKEX9I08esZN9dTmJ03G1rwwExeCCwU+YnbkLEV2HjwabLB4+NFwNvfCBpPw7xQ7O1/AiUfKjbldooOEY8XgU+hd5RwpBS3QPd91uCJBT3yJ4Goqh4P/CZnDskwZBKKC9iq8DOou8nDB4eYwBl/WqAdZkCsVRpkjywcrXksIx97XxA9lFb+AYnlh6TqbmDd9qu/E1YS0XRFYT6oagnwzGKIyzxZCRvPZTf/QN23BJEz3JP4lha1dnxsZyZuLv8dfLy73L4FdVkgqZhJBEK2lO9RS3Jbvbd6VRrJpcG8s9TTC1H7zHJJTxpj8GSiSgB6FY4CnmuKEkO9O62X6SM2kmeWFeY1wSkzMw1n6U5KsEM4kfhHC9lItsC8JzZREwDIlxMwU5zQz5vqudukuhMm5PJtPRZ8TXRSiuh269pRzYxR7v0HmmCw3woqU1oc+ARFKy1eN/9uc8hi5UXm3qST8XUxMjEzHOtNFsY+jOrvOo2JkK3W/lU/7/vztjVAOQXwKQBDLNc+mdEwnH5h2qs9PN5TZd4bgnQAX2JlFCxoS8HHrSg2Gn74/pAuIw5qzyHmS2+pIY6bV3yezGTGtFIX0xhACRozLrXiIPbqVezSD7QHcR/+EAQOxSMwSaa6JleGtlsk0OntIqVoeTyOX0/R5ob9WG2f4YiD//+s63MV84QSbES983bNxyPPShpYxb5zbao6mnGrcoyBH5JNQ/9/kYP+8JQ7G5J18rf/UWeKl+qJiKBCZHmIaCzALkGLxyqMM2HyVKgwDHedgj8CvpJEkTI7mGO/yhRRryjEfWIxNu+1Knf7gdzOUBkr3+zFE7HO7myhN/91mW0ZxEWXkp1RmVgDh/KpsnMp/Spdw1xNiRf8zyzjoh3onEjq+/HEdWhdYeASkDDAtXCz7qfENZmedn9iGxfbE9uvUqsydWuLPkVnwZkTOS0qiamk4vXrCeQKGqPpcomnxOnFRZBO06FUZ9cD2AzgCvtZoDvQAML0Uh1GC3ot/hLz9Kn5iCGP5bQ+WwKevecIKOpvtZYh17/PcSqgbUwLdtKo4oc2vj2ChfIfxA94LPI0yhbg2f25khHcUaIXdxyDGbXKzVBxe8LzOiHIqN71XTxuewwv69wQNuvCD5TiHDmBDLske/p5Gxp7I27KRjGot9ZddAgyVtSqwhytp8gS1ifLhptEgB8q1b8hsiSoDN94nEn2cD2pBV/RTu3PSQr5W/rqG/mBbvs7PmHz0lOvpqM19QCERF4Uo3FjgoVmQITaW/DM+BKlXkn/osFn+HKZNspkKUe73lGzUQf+msXRR87Gv+PS3OyaXxTTg4awJb8nivLYPYvRvSpFrK2YdjiwAtHbcy5Qj2tGIhgDL9xNIvZ2ZXceFLYrU6Bey4eSL5RJEWPI+Aurq7KggSajlOvq16AueEOwzTscF3fkiW1FzNmAkXm/lpLddFkcf2zDgwqu6HorefAus++0bJoF9b0ub6ENwso8FgEnQv8z61L76eqNJGcK+kWIZwS+oEuSBFikjH6NDq4WuMlZeCAF3erVfwGj2zjkfmWr8XxN523nk53sa7n+RgnWjMPX5pkG65c8WZsK0h0OM7I66El1oc6jB680C3m8eNGWuj1TYQpC5AaSFYOh0kt84PY4CimY8hKGMrInOSfPJKeViUK+SAli/g8pS+n0fvCsFzwUh3NV4M6A6CJF+S14E2h4edX9qPKuc0Pm9oqMvWPr7kee3tRbbtys0fgXeiFQPyzZnBINUveFu2sPr+m/kAa0I3n1kowOrkhflYjf0h51yRgoY6ZHvs2iEcphE4Z5SjvNKrWGwZKfOGXpQ35rhTVcucwfhtbhPOXbgc6DwL/FsFVIj9U8Yu2xnQEU/axNFJ2c7E2/6jl87A7PUew5nl1bt0QvezcGYqHSI0rjZ6DYFuS1iXCeCu3YDE0Obt/Z4EAodkVnaCoISzS8yEddAzaU4cXQq0E1lgKpUMz49Dg9GVHkD7vfr03sW2gWzDjpaEpWucQC1xQGb9U4V/HcFFlNp8Qnl8Bq3a2Cd+99HXbMnt7ANz5iu7iSqz8MelMCEUnHzJm/7/plpyzndLGSqSvQ+JrsvUOauT2d+XPF/z7Rg6VDgn3K8uVN3SqPEhUZI2UObZHV4COE6pq6JUCMLHYVHVY/w1ybrUZZExWmuE5KJKd6DwtC+F98wPyjVyl0GTBHlvqSZ3nJVaXXuOlrFQftzaKtRMIOcju8GTtIUW53KWOrSMOk72XTG24rjgpnAuiNcRZnJ6g1aqqcO2LUKoLZDYvx2KwmHYztmvgWbB5l5q+hZCIMefl0+HOGiXc5FXT4u0A6csd+1Avl7LGysTVaQoCqc2CyQYhNrJjBHSSq0SQ9IlnVyCx/z8uOVpVUY93WYvFBCvQJUt9BJDxdyA9bTjx/dFx6Npu+TAATKfh9XZGt92Y8ScEVOezkOie7MEyl4O6WbiGIByi6DFgAeDeFiPjNeL613F8lJGifGa5Y44qkyT99i7libaHo5X9bYVTyMhwc1oDLHD8Zm2JE2GcLvRhKC+i39V83uwWtcVTZVM81omU9vJamewuaNe+d8Kwo3ac2HAAI/hJGrXWGCh8Deix0UKDZslpACOFCkcXxjs7SJ4kJMvXzsP7v1FqsYWc/A+0pK4gdPY43O6ORIsyNCE915A3/NRErjDIDzAVEAIAjKZnvABeC6V9W/i15Qxh4s+gDlWrpmlHQKoKDQDu/MfCoUbKz9NdV760svULwn8JY4t4gM8Ov5W/FIdNUidub7np0WexHWHdDcl9qB5ajdj7Yrizm+mLWuEVqJKwvLJ5kSMwWNovNmrwIfAxXbwGWibxx7z1wLcxnW1N2P+tNkMFfaiizz/KwxVjxrj8rET8lFo47z/x/f4u4AzKi6VU19HaQE1Fn0BM5sgfni37Tw14j1q34uBCdEk4TwJ6XYuz38+f7p2wHIe685fZKto1yDPVzCsnS1c3QIufHfwntTY9kg54GV5tHt6zcG4Eb/fssLyJ0FO5GgRmrNvbaeFaHiLMw9lbS+KEY0brztKPpGLGJd2Yl2VvXr+ikO1FJ0TFjPr0vrKQ+6Bow5OF0xBQSQPCNnmSkIfJjg0nioIwjWNlyZPbT2IYbOV6WRgYrv4GASDF3dEaeY2inUDrvH1Aq79XycAJroVaZFnePX8P5xL6cWiQ33SjDFDxpc0mg74zYXM9o+Ce+Bvu9xzg0HuEbiieA+oSHvRzuT6FSwX7dADjy0ZOZ+F6y0ry4QPrubx+5EgjGBqT+bKytJ+hsJYIlNLTTiGOMt4deKuKm38UWOuGesvVSAiU+Ui8wG76zELckly7UzJV/XwZPk0E+7KDxyLXhqneM5yQbDnNluMxtR6bBsAq+10C2YxcIYmYTH6oTol9k/UgrnmrFvnNVUSuAjETFmJMKzdA4O3WLdJH4FR4OZOO9ohd4CnnKlTld4zaYTwRjooiEvK7W/f8cF2Xor3tk4QGxkDuhAMjznGRmSLu/ANpE8zB0q7FzkHnvy77vks+H6jmqu3o4Uht6zXBM80rGp3UeNBUgFzTk1wBsHEStHWb5HkafwNze/5v7hbDuMQEdhR4WSsttHMaFYUVR1P+Vk1vMBfLf5bKteDk+8xLWSmD9XsPVWWa3u0U90H+XRFMiLCJvmVRxHr8cxkBchlot6o3FrL3d2+BlCEEBdIIk+P4UqH/7ozBTVFj1NsGkeuNX7cnslUnI4s2i/67OYiMrUGTWqElXwcJNOykvegIYLB6DJCcalFhOnbuvpXbun2mez+LRws4Yh+mVGnjV8jPXiPwkCezhg==]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>记录自己的心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫评《ようこそ実力至上主義の教室へ》]]></title>
    <url>%2F2019%2F04%2F14%2F20190414%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>漫评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份不再摸鱼]]></title>
    <url>%2F2019%2F04%2F07%2Fdailylife%2F</url>
    <content type="text"><![CDATA[enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随手写的一点东西</tag>
      </tags>
  </entry>
</search>
