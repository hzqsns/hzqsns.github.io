<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SegmentTree</title>
      <link href="/2020/02/08/SegmentTree/"/>
      <url>/2020/02/08/SegmentTree/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a><center>线段树</center></h1><p><img src="/2020/02/08/SegmentTree/74870515_p0_master1200.jpg" alt="坚持就是胜利"></p><p>第八天！加油啊！！！！<br>奥利给！</p><a id="more"></a><h1 id="线段树的两个功能"><a href="#线段树的两个功能" class="headerlink" title="线段树的两个功能"></a>线段树的两个功能</h1><p>1.单点修改，时间复杂度为O(logn)<br>2.区间查询，时间复杂度为O(logn)</p><h1 id="四个基本操作"><a href="#四个基本操作" class="headerlink" title="四个基本操作"></a>四个基本操作</h1><p>1.pushup: 用子节点的信息更新当前结点信息<br>2.build: 在一段区间上初始化线段树<br>3.modify: (单点)修改<br>4.query: 查询操作</p><h1 id="根据具体例子来写一个线段树"><a href="#根据具体例子来写一个线段树" class="headerlink" title="根据具体例子来写一个线段树"></a>根据具体例子来写一个线段树</h1><p>同上次用树状数组的那题，这次用线段树进行求解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/02/08/SegmentTree/1.png" alt="举例"></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p><img src="/2020/02/08/SegmentTree/2.png" alt="举例"></p><p>线段树会存到一个一维数组里面<br>其中下标为x的结点<br>  父节点为x/2 或 x &gt;&gt; 1<br>  左儿子是2x  或 x &lt;&lt; 1<br>  右儿子是2x+1或 x &lt;&lt; 1|1</p><p>因为线段树是一棵树，所以一开始第一层会有n个点<br>然后第二层有n/2个点，第三层有n/4个点<br>依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数<br>所以最后一层最多有2n个<br>n + n/2 + n/4 + …+ 1 + 2n &lt; 4n<br>  所以结点个数小于4n<br>我们设置的数组大小应为4*N<br>我们用一个结构体数组来存放各个结点的信息<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> l,r;</span><br><span class="line">   <span class="keyword">int</span> sum;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure></p><p>其中l,r代表当前结点的左右边界,sum为当前结点左右边界里面所有数的和</p><h1 id="具体的四个基本操作"><a href="#具体的四个基本操作" class="headerlink" title="具体的四个基本操作"></a>具体的四个基本操作</h1><h2 id="pushup操作"><a href="#pushup操作" class="headerlink" title="pushup操作"></a>pushup操作</h2><p>pushup是把子节点的信息更新到父节点<br>这里的题就对应着把子节点的值更新以后，向上更新到父节点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="build操作"><a href="#build操作" class="headerlink" title="build操作"></a>build操作</h2><p>我们这里设置一个函数build(u,l,r)表示把(l,r)这一段的数初始化为线段树<br>其中u一般为根节点,l,r一般为我们要初始化成线段树的数组的边界<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//u为当前结点边界,l,r为左右边界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l,r,w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>,l,mid),build(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(u);<span class="comment">//把信息往上传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们设置mid = l + r &gt;&gt; 1<br>然后u的左儿子对应的就是build(u &lt;&lt; 1,l,mid)<br>右儿子对应的就是build(u &lt;&lt; 1|1,mid+1,r)</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p>当l == r的时候表示到达了根节点，这个时候直接赋值<br>同时在进行每个操作的时候同样要进行初始化即tr[u] = {l, r};<br>表示进入这个函数后u结点对应的边界为l到r</p><h2 id="query操作"><a href="#query操作" class="headerlink" title="query操作"></a>query操作</h2><p>在这个题目里面query操作对应的就是计算区间和了<br>我们定义query(u,l,r)为计算区间(l,r)的区间和，其中u一般为根节点开始<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果结点u对应的边界l1,r1在区间l到r之间，直接返回sum</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="comment">//否则计算u对应边界的中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果l小于u对应的中点，说明需要到u的左儿子里面继续寻找</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) sum += query(u &lt;&lt; <span class="number">1</span>,l,r);</span><br><span class="line">    <span class="comment">//同理如果r大于u对应的中点，说明需要到u的右儿子里面继续寻找</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)sum += query(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="modify操作"><a href="#modify操作" class="headerlink" title="modify操作"></a>modify操作</h2><p>在本题里面modify为修改某个点对应的值<br>我们定义modify(u,x,v)为修改下标为x对应的值要加上v，u一般从根节点开始<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">else</span> modify(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本人的理解就是有点二分查找的意思，u从根节点开始<br>假设一个数组下标为1,2,3,4,5,6,7，我们要修改下标为5的数<br>那么根节点u边界为1到7<br>mid = 1 + 7 &gt;&gt; 1 = 4 &lt; 5<br>这个时候就要从5到7去找，即u的右儿子继续寻找<br>mid = 5 + 7 &gt;&gt; 1 = 6 &gt; 5<br>这个时候就找5到6，即u的左儿子继续寻找<br>然后mid = 5 + 6 &gt;&gt; 1 = 5<br>5 == 5<br>这个时候即为根节点，修改对应的值后<br>再pushup(u)更新结点</p><hr><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树</span></span><br><span class="line"><span class="comment">//对应的操作</span></span><br><span class="line"><span class="comment">//pushup: 用子节点的信息更新父节点</span></span><br><span class="line"><span class="comment">//build: 在一段区间上初始化线段树</span></span><br><span class="line"><span class="comment">//modify: 单点修改或者修改操作</span></span><br><span class="line"><span class="comment">//query: 查询操作</span></span><br><span class="line"><span class="comment">/*假设第一层有n个点，那么第二层有n/2个点，第三层有n/4个点</span></span><br><span class="line"><span class="comment">  依次类推，由于最后一层参差不齐可能会有前面所有点之和的个数</span></span><br><span class="line"><span class="comment">  所以最后一层最多有2n个</span></span><br><span class="line"><span class="comment">  n + n/2 + n/4 + ...+ 1 + 2n &lt; 4n</span></span><br><span class="line"><span class="comment">  所以结点个数小于4n</span></span><br><span class="line"><span class="comment">  线段树存到一个一维数组里面</span></span><br><span class="line"><span class="comment">  下标为x的结点</span></span><br><span class="line"><span class="comment">  父节点为x/2 或 x &gt;&gt; 1</span></span><br><span class="line"><span class="comment">  左儿子是2x  或 x &lt;&lt; 1</span></span><br><span class="line"><span class="comment">  右儿子是2x+1或 x &lt;&lt; 1|1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> l,r;</span><br><span class="line">   <span class="keyword">int</span> sum;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//u为当前结点边界,l,r为左右边界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l,r,w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>,l,mid),build(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(u);<span class="comment">//把信息往上传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) sum += query(u &lt;&lt; <span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)sum += query(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">else</span> modify(u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> k,a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,a,b));</span><br><span class="line">        <span class="keyword">else</span> modify(<span class="number">1</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BinaryIndexedTree</title>
      <link href="/2020/02/06/BinaryIndexedTree/"/>
      <url>/2020/02/06/BinaryIndexedTree/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组及其模板题"><a href="#树状数组及其模板题" class="headerlink" title="树状数组及其模板题"></a><center>树状数组及其模板题</center></h1><p><img src="/2020/02/06/BinaryIndexedTree/75023773_p0_master1200.jpg" alt><br>第七天！<br>777777777</p><a id="more"></a><h1 id="从求区间和的问题来进行深入思考"><a href="#从求区间和的问题来进行深入思考" class="headerlink" title="从求区间和的问题来进行深入思考"></a>从求区间和的问题来进行深入思考</h1><p>对于这种求区间和的问题，一般我们都是通过一个前缀和数组计算S[n]-S[m-1]从而求得区间[m,n]的和<br>但是，如果我们中途要随时给第x个整数加上某一个数v<br>那么我们需要重新更新前缀和数组S，时间复杂度为O(n)<br>如果进行K次这样的操作那么时间复杂度为O(Kn)我们难以接受</p><p>于是我们就要想一个办法来解决这个问题降低时间复杂度</p><p>于是我们就应用树状数组来解决问题</p><h1 id="树状数组的两个应用"><a href="#树状数组的两个应用" class="headerlink" title="树状数组的两个应用"></a>树状数组的两个应用</h1><p>1.给区间中的某个位置加上一个数<br>2.求前缀和从而方便得到区间和</p><p>树状数组仍然是一个数组C[N]，只不过它存的不是从1到N的前缀和<br>而是从区间(x-2^k,x]<br>即C[x] = (x-2^k,x]<br>其中k表示当前下标x对应的数在第k层</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2020/02/06/BinaryIndexedTree/3.png" alt="举例"><br>设有原数组A[N],树状数组C[N]<br>其中对于奇数来说<br>C[1] = A[1]<br>C[3] = A[3]<br>C[5] = A[5]<br>C[7] = A[7]<br>C[9] = A[9]<br>C[11] = A[11]<br>C[13] = A[13]<br>C[15] = A[15]</p><p>对于偶数来说<br>第一种<br>C[2] = A[1] + A[2]<br>C[6] = A[5] + A[6]<br>C[10] = A[9] + A[10]<br>C[14] = A[13] + A[14]</p><p>第二种<br>C[4] = A[4] + C[3] + C[2] = A[1] + A[2]+ A[3]+A[4]<br>C[8] = A[8] + A[7] + C[6] + C[4] = A[1]+ … + A[8]<br>….<br>C[16] = A[1] + … + A[16]</p><p>不难看出，如果把x转换为二进制表示<br>C[x]就表示区间(x-2^k,x]这个前开后闭区间的和<br>其中k表示二进制后面有多少个0<br>对应到我们样例中就是第几层到当前下标x对应层的和</p><h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p>我们定义lowbit(x) = x &amp; -x<br>拿x = 6来举例<br>x|—-0000001101001100<br>-x|—1111110010110100<br>x&amp;-x|-0000000000000100<br>即6对应1后面有2个0<br>lowbit(6) = 2<br>(lowbit(x)也可以理解为能整除x的最大2的幂次)</p><p>于是我们可以把区间(x-2^k,x]转换为(x-lowbit(x),x]</p><p>最后求出树状数组C[N]即可进行更多的操作</p><hr><h1 id="AcWing-1264-动态求连续区间和"><a href="#AcWing-1264-动态求连续区间和" class="headerlink" title="AcWing 1264. 动态求连续区间和"></a>AcWing 1264. 动态求连续区间和</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/02/06/BinaryIndexedTree/1.png" alt></p><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p><img src="/2020/02/06/BinaryIndexedTree/1.png" alt></p><p>树状数组模板题</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>1.lowbit运算 即x &amp; -x<br>2.在下标为x的位置加上v<br> 我们就需要更新树状数组C[i]<br> 即把下标为x,x+lowbit(x),x+2*lowbit(x),…,的树状数组更新<br>3.求前缀和<br>因为C[x]表示区间(x-lowbit(x),x]这个里面的区间和<br>我们只需从x开始从后往前加和直到i等于0为止<br>比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res += C[x];</span><br><span class="line">y = x - lowbit[x];</span><br><span class="line">res += C[y]</span><br><span class="line"><span class="comment">//而C[y]表示区间(y-lowbit(y),y]即区间一直往前延伸直到为0为止</span></span><br><span class="line">然后依次类推</span><br></pre></td></tr></table></figure></p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[N],tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//进行lowbit运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span><span class="comment">//add函数表示在下标为x的位置加v</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &lt;= n;i += lowbit(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//利用树状数组求前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">   &#123;</span><br><span class="line">       res += tr[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) add(i,a[i]);<span class="comment">//生成树状数组</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="comment">//查找操作</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) add(a,b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(b) - query(a<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quickSort</title>
      <link href="/2020/02/05/quickSort/"/>
      <url>/2020/02/05/quickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序-模板"><a href="#快速排序-模板" class="headerlink" title="快速排序[模板]"></a><center>快速排序[模板]</center></h1><p><img src="/2020/02/05/quickSort/59122673_p0_master1200.jpg" alt><br>因为各种事情断了两天，就算是第六天吧！<br>接下来还会一直坚持的<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/02/05/quickSort/1.png" alt></p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><img src="/2020/02/05/quickSort/2.png" alt></p><h1 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h1><p>快速排序的思路,对于一个数列q[N]<br>1.确定分界点 q[l]、q[r]或者是q[l + r &gt;&gt; 1]或者是l到r区间上的随机点<br>值得注意的是如果数据范围很复杂最好不取两个端点而是取中间的点</p><p>2.调整区间<br>使得最后调整的区间<br>x点左边都小于等于x<br>x点右边都大于等于x</p><p>3.递归处理左右两个区间</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>1.如果是取区间的中点<br>那么l + r &gt;&gt; 1有可能要改成l + r &gt;&gt; 1 防止出现死循环<br>2.最后左右递归区间的时候要注意那个分界点对x取点的影响，防止出现死循环<br>3.因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r)<br>  反之则划分为(l,i-1),(i,r),这个时候对应的x的取值就要相应改变</p><hr><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;<span class="comment">//如果l&gt;=r则直接返回</span></span><br><span class="line">    <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里i和j要从区间左右两端的外侧开始，因为后面是先i++,j--然后再进行判断</span></span><br><span class="line">    <span class="keyword">int</span> x = num[(i + j) / <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//当区间划分为下面这种的时候</span></span><br><span class="line">    <span class="comment">//quick_sort(num,l,i-1);</span></span><br><span class="line">    <span class="comment">//quick_sort(num,i,r);</span></span><br><span class="line">    <span class="comment">//int x = num[(i + j + 1) / 2]; x应该上取整才能防止死循环</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">do</span> i++; <span class="keyword">while</span>(num[i] &lt; x);</span><br><span class="line">    <span class="keyword">do</span> j--; <span class="keyword">while</span>(num[j] &gt; x);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)swap(num[i],num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为最后从循环中出来i可能大于j所以划分区间的时候如果以j为准那么就要(l,j),(j+1,r)</span></span><br><span class="line">    <span class="comment">//反之则划分为(l,i-1),(i,r)</span></span><br><span class="line">    quick_sort(num,l,j);</span><br><span class="line">    quick_sort(num,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i]);</span><br><span class="line">    quick_sort(f,<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,f[i]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing122-GreedyAlgorithm</title>
      <link href="/2020/02/02/AcWing122-GreedyAlgorithm/"/>
      <url>/2020/02/02/AcWing122-GreedyAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="一个稍微复杂的贪心问题"><a href="#一个稍微复杂的贪心问题" class="headerlink" title="一个稍微复杂的贪心问题"></a><center>一个稍微复杂的贪心问题</center></h1><p><img src="/2020/02/02/AcWing122-GreedyAlgorithm/76518566_p0_master1200.jpg" alt></p><p>第五天了，我真的是一天都没有停下来呢。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/02/02/AcWing122-GreedyAlgorithm/2.png" alt="题目"></p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><img src="/2020/02/02/AcWing122-GreedyAlgorithm/3.png" alt="数据范围"></p><h1 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h1><p>n个小朋友围成一个环，然后每个人只能给左右两个人传递糖果<br>且传递x个糖果消耗的代价为x</p><p>第一直觉肯定是糖果多的人怎么传给糖果少的人<br>一时半会看不出来用什么方法可以解决问题，我们于是可以先建立一个数学模型</p><h2 id="建立数学模型"><a href="#建立数学模型" class="headerlink" title="建立数学模型"></a>建立数学模型</h2><p>我们可以设n个小朋友现在手里的糖果数分别为A1,A2,A3 … ,An-1,An<br>我们约定，从An传递到An-1为Xn个糖果数</p><p>其中,Xn为正表示糖果从An传递到An-1</p><p>反之如果为负，则表示从An-1传递到An</p><p><img src="/2020/02/02/AcWing122-GreedyAlgorithm/2.svg" alt="如图所示"></p><p>则依题意可知我们最终要求的就是|X1| + |X2| + |X3| + … + |Xn|的最小值</p><h2 id="分析题目的限制条件"><a href="#分析题目的限制条件" class="headerlink" title="分析题目的限制条件"></a>分析题目的限制条件</h2><p>那么，显而易见最后每个点的结果一定是Ā<br>每个点起初都是Ai，结果都是Ā<br>那么我们通过每个点可以得到n个关系式<br>即<br>A1   - X1   + X2 = Ā<br>A2   - X2   + X3 = Ā<br>A3   - X3   + X4 = Ā</p><p>…</p><p>An-1 - Xn-1 + Xn = Ā<br>A1   - Xn   + X1 = Ā</p><hr><p>整理上式<br>X1   - X2   = A1   - Ā<br>X2   - X3   = A2   - Ā<br>…<br>Xn-2 - Xn-1 = An-2 - Ā<br>Xn-1 - Xn   = An-1 - Ā<br>Xn   - X1   = An   - Ā</p><hr><p>感觉跟差分数列差不多的样子<br>于是我们从最后一项依次递加i项<br>比如最后两项相加可以得到X2 = X1 - ((n-1)Ā - An - An-1 -…- A2)<br>最后三项相加可以得到X3和X1的关系<br>依次类推<br>我们可以得到Xi与X1的一个线性关系<br>从而我们可以把所有的Xi转换成X1+Ci继续进行求解</p><p>继续整理<br>Xn   = X1 - (Ā - An)<br>Xn-1 = X1 - (2Ā - An - An-1)<br>…<br>X2   = X1 - ((n-1)Ā - An - An-1 -…- A2)<br>X1   = X1</p><p>于是我们要求的|X1| + |X2| + |X3| + … + |Xn|<br>可以转换成|X1 - C1| + |X1 - C2| + |X1 - C3| + … + |X1 - Cn|</p><p>即转换成在直线上求一点X使得X到C1,C2,C3,…,Cn的距离最小</p><p>其中<br>C1 = Ā - An<br>C2 = 2Ā - An - An-1<br>…<br>Cn-1 = (n-1)Ā - An - An-1 -…- A2<br>Cn = 0</p><p>可以发现其中的一个递推关系就是<br>Cn - Cn-1 = Ā - An-1<br>又C1 = Ā - An<br>我们可以根据这个递推关系求出所有的Ci<br>然后再对Ci从小到大排序<br>找到Ci的中间的点就是使得它到其他Ci距离之和最小的点</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1.数列最好从1开始方便计算<br>2.当数列从1开始的时候，中间点即为(n+1)/2，需要+1<br>3.数据可能爆int，所以要用long long 长整形表示结果</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这题是AcWing 104. 货仓选址的一个进阶题目，或者说是区间选点加了一个套子<br>难点在于我们在考试的时候如果遇到这种题很难静下心来去分析出题目的数学模型并进行进一步的整理<br>所以需要我们多做题多总结模型才行啊（</p><hr><h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> +<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> A[N],C[N],S[N];<span class="comment">//A[i]记录原数据</span></span><br><span class="line">LL n,sum = <span class="number">0</span>,avg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);<span class="comment">//数据范围较大最好用scanf进行输入</span></span><br><span class="line">        sum += A[i];<span class="comment">//计算所有糖果的和</span></span><br><span class="line">    &#125;</span><br><span class="line">    avg  = sum / n;<span class="comment">//计算糖果的平均值</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    C[k] = avg - A[n];<span class="comment">//初始化，C[1] = Ā - An</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        C[k+<span class="number">1</span>] = C[k] + avg - A[i<span class="number">-1</span>];<span class="comment">//根据Cn - Cn-1 = Ā - An-1递推关系来算出所有C[i]的值</span></span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    C[n] = <span class="number">0</span>;</span><br><span class="line">    sort(C+<span class="number">1</span>,C+n+<span class="number">1</span>);<span class="comment">//对各个点到原点的距离进行排序</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(C[(n+<span class="number">1</span>)/<span class="number">2</span>] - C[i]);<span class="comment">//找到中间的那个点再计算到其他个点的距离之和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;<span class="comment">//因为数据保证一定有解，所以我们直接输出res</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mergeSort</title>
      <link href="/2020/02/01/mergeSort/"/>
      <url>/2020/02/01/mergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a><center>归并排序模板</center></h1><p><img src="/2020/02/01/mergeSort/78286152_p0_master1200.jpg" alt><br>今天是第四天！</p><a id="more"></a><h1 id="归并排序的三个要点"><a href="#归并排序的三个要点" class="headerlink" title="归并排序的三个要点"></a>归并排序的三个要点</h1><p>1.确定分界点 mid = l + r &gt;&gt; 1<br>2.递归排序 然后分成左右两个部分继续递归<br>3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余然后再赋值给原数组</p><p>*注意点merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return;</p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的三个要点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.确定分界点 mid = l + r &gt;&gt; 1</span></span><br><span class="line"><span class="comment">2.递归排序 然后分成左右两个部分继续递归</span></span><br><span class="line"><span class="comment">3.用一个额外的数组来依次从小到大左右两部分，并且还要循环左右两边看是否还有剩余</span></span><br><span class="line"><span class="comment">  然后再赋值给原数组</span></span><br><span class="line"><span class="comment">* 注意点 merge_sort的边界条件是区间里面的个数为1个或者没有的话就直接return;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];<span class="comment">//设一个额外的tmp数组来</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;<span class="comment">//当区间里面的个数为1个或者没有的话就直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q,l,mid); merge_sort(q,mid+<span class="number">1</span>,r);<span class="comment">//把原数组分成左右两边然后继续归并排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,x = l,y = mid+<span class="number">1</span>;<span class="comment">//k为tmp里面有几个数</span></span><br><span class="line">    <span class="keyword">while</span>(x &lt;= mid &amp;&amp; y &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[x] &lt; q[y]) tmp[k++]= q[x++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[y++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x &lt;= mid) tmp[k++] = q[x++];<span class="comment">//如果还有剩余的就存放进tmp数组里面</span></span><br><span class="line">    <span class="keyword">while</span>(y &lt;= mid) tmp[k++] = q[y++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) q[l+i] = tmp[i];<span class="comment">//把tmp数组里面的数重新赋值给原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>binarySort</title>
      <link href="/2020/01/31/binarySort/"/>
      <url>/2020/01/31/binarySort/</url>
      
        <content type="html"><![CDATA[<h1 id="四个常用的二分模板"><a href="#四个常用的二分模板" class="headerlink" title="四个常用的二分模板"></a><center>四个常用的二分模板</center></h1><p><img src="/2020/01/31/binarySort/76938192_p0_master1200.jpg" alt><br>第三天<br><a id="more"></a></p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;<span class="comment">//测试数据</span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求小于等于target的最后一个数的下标</span></span><br><span class="line">   <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + R + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt;= target) L = mid;</span><br><span class="line">        <span class="keyword">else</span> R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求大于等于target的第一个数的下标</span></span><br><span class="line">   <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小于target的最后一个数的下标</span></span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + R + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt; target) L = mid ;</span><br><span class="line">        <span class="keyword">else</span> R = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于target的第一个数的下标</span></span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &gt; target) R = mid;</span><br><span class="line">        <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;L;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个看起来很复杂的组合问题用dp求解</title>
      <link href="/2020/01/31/AcWing1214-dp/"/>
      <url>/2020/01/31/AcWing1214-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing1214-波动数列"><a href="#AcWing1214-波动数列" class="headerlink" title="AcWing1214. 波动数列"></a><center>AcWing1214. 波动数列</center></h1><p><img src="/2020/01/31/AcWing1214-dp/78316040_p0_master1200.jpg" alt><br>Day3，striving<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/01/31/AcWing1214-dp/1.png" alt></p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><img src="/2020/01/31/AcWing1214-dp/2.png" alt></p><h1 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h1><h2 id="分析题目的大意"><a href="#分析题目的大意" class="headerlink" title="分析题目的大意"></a>分析题目的大意</h2><p>一开始分析这道题咋一看是个序列模型，但其实是个组合模型<br>因为可以肯定的是第一个数是不变的设为X<br>那么数列即为<br>X  X+d1  X+d1+d2  X+d1+d2+d3  …  X+d1+d2+…+dn-1<br>其中di = {+a,-b}<br>整理可得<br>nx + (n-1)d1 + (n-2)d2 + … + dn-1 = S<br>转换后</p><p>x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n</p><p>则当S和di确定的时候x是一定确定的<br>任何一个满足要求的合法序列对应一个d1到dn-1的取值，反过来也成立<br>这是一一对应的关系</p><p>即原序列不同的方案数，等于所有d1到dn-1合法的取值的方案数</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>题目转换为求所有满足要求的所有d1到dn-1所有取法的方案数<br>那么满足的要求是什么？<br>1.di为+a或者-b<br>2.因为x = {S-[(n-1)d1 + (n-2)d2 + … + dn-1]} / n<br>  那么S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]<br>即有多少种选法的d1到dn-1的取值代入序列之和对n的余数等于总和S对n的余数</p><h2 id="用dp的思路去求解问题"><a href="#用dp的思路去求解问题" class="headerlink" title="用dp的思路去求解问题"></a>用dp的思路去求解问题</h2><h3 id="状态的表示"><a href="#状态的表示" class="headerlink" title="状态的表示"></a>状态的表示</h3><p>这道题目就相当于一个组合问题，可以相当于背包问题来做<br>分析状态<br>应该用两维去表示f[i,j]<br>状态对应的集合即为所有从前i个数(前i个di)，且当前总和(总和即表示代入[(n-1)d1 + (n-2)d2 + … + dn-1])除以n的余数的方案的集合<br>属性应该为数量</p><h3 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h3><p>f[i,j]考虑最后一步，抓住最后一个不同点<br>最后一步有两种情况因为最后一步是+dn-1<br>有可能是+a,也有可能是-b</p><p>d1 + d2 + …    di(+a)<br>d1’+ d2’+ …    di(+a)<br>不管前面的di是多少,di都为+a<br>所以可以所有先去掉这个最后这个di<br>去掉之后就相当于只考虑前i-1项，<br>然后代入(n-1)d1 + (n-2)d2 + … + dn-1<br>但是为了方便我们变换成d1 + 2d2 + … + (n-1)dn-1 (一一对应)<br>(不换也可以)<br>假设前i-1项的原序列和为C<br>则有C(mod n) + ia(mod n) == j(mod n)<br>即 C(mod n)  = (j - ia)(mod n)<br>即f[i,j] = f[i-1,(j - ia)%n]</p><p>同理当di = -b时<br>f[i,j] = f[i-1,(j + ib)%n]</p><p><img src="/2020/01/31/AcWing1214-dp/3.png" alt></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>1.凡是问满足要求不同选法的数量或者最大值时，都可以用以上类似的背包问题的模型<br>2.这题不能用dfs来做<br>因为长度n为1000，dfs时间复杂度为2^1000，不予考虑<br>3.这个题取模的时候有可能为负数<br>那么需要把负余数转换为正余数<br>所以需要写一个函数get_mod<br>4.S的范围包含负数,所以最后不能直接写S%n，也应代入get_mod函数中<br>5.初始化f[0][0] = 1，表示当一项都不选的时候方案数为1，一项都不选代入原序列和为0,0对n取模的余数也为0</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>最后把f[i][j]所有的方案数都求出来<br>最后对应的f[n-1][get_mod(s,n)]即为结果<br>因为S % n == [(n-1)d1 + (n-2)d2 + … + dn-1]<br>所以j = get_mod(s,n)时候对应的方案数为我们所求的结果<br>因为对应的最后一项为dn-1<br>所以i = n-1，表示前n-1项</p><hr><h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>,MOD =<span class="number">100000007</span>; </span><br><span class="line"><span class="keyword">int</span> n,s,a,b;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//因为x有可能为负数，那么我们取模的时候需要加上y再取模得到正余数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % y + y) % y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化，当一项都不选的时候方案数为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]= (f[i<span class="number">-1</span>][get_mod(j-a*i,n)] + f[i<span class="number">-1</span>][get_mod(j+b*i,n)]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n<span class="number">-1</span>][get_mod(s, n)];<span class="comment">//注意S也有可能为负数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由两个简单dp组合而成的复杂dp问题</title>
      <link href="/2020/01/30/AcWing1212-dp/"/>
      <url>/2020/01/30/AcWing1212-dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/01/30/AcWing1212-dp/4.jpg" alt><br>第二天，坚持。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/01/30/AcWing1212-dp/1.png" alt></p><p><img src="/2020/01/30/AcWing1212-dp/2.png" alt></p><h1 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h1><p>题目有两个限制<br>1.只能往右或者往下走<br>2.一定要按照递增的顺序取物品<br>3.一共要恰好取K件</p><p>数据范围n和m都为50<br>所以这个题的维度可能比较多</p><p>分析f里面一定要有两维i,j来存坐标<br>如果还要存当前取的数的坐标那么就会有四维了<br>这是一个不明智的行为<br>但是我们发现所有数的大小很小，才0到12，有很强的限制<br>所以不需要存最后一个数是哪个数，只需要存最后一个数是多少就行了<br>还有一维就是存最后一个取的物品价值是多少<br>即f[i,j,k,c]前两维表示坐标,k表示当前取多少件,c表示取最后一件的价值是多少</p><p>计算时间复杂度50*50*50*12*13 = 390000<br>用最多的时间复杂度10^7/390000约等于25<br>即状态转移的计算量(大概还可以再循环一次)<br>所以大概是五重循环的样子，前四重是状态，还有一重是状态的转移</p><h1 id="y氏dp分析法分析dp问题"><a href="#y氏dp分析法分析dp问题" class="headerlink" title="y氏dp分析法分析dp问题"></a>y氏dp分析法分析dp问题</h1><p><img src="/2020/01/30/AcWing1212-dp/3.png" alt></p><p>分为四种情况<br>两大类AB<br>分析最后一步<br>A最后一步从上往下走 B最后一步从左往右走<br>然后A B两类又可以继续划分<br>A：<br>A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品<br>B：<br>B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品</p><p>考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变<br>考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的<br>对应的C应该从之前已经选取k-1个物品中最大的价值C’，这个时候直接从0到V进行循环相加即可</p><hr><h1 id="对应的代码如下："><a href="#对应的代码如下：" class="headerlink" title="对应的代码如下："></a>对应的代码如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分为四种情况</span></span><br><span class="line"><span class="comment">两大类AB</span></span><br><span class="line"><span class="comment">分析最后一步</span></span><br><span class="line"><span class="comment">A最后一步从上往下走 B最后一步从左往右走</span></span><br><span class="line"><span class="comment">然后A B两类又可以继续划分</span></span><br><span class="line"><span class="comment">A：</span></span><br><span class="line"><span class="comment">A1：不取第W[i][j]个物品 A2：取第W[i][j]个物品</span></span><br><span class="line"><span class="comment">B：</span></span><br><span class="line"><span class="comment">B1：不取第W[i][j]个物品 B2：取第W[i][j]个物品</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">考虑不取第W[i][j]个物品，那么拿A1举例的话f[i][j][k][c] = f[i-1][j][k][c]因为不取第W[i][j]个物品那么k没变，对应的C也没变</span></span><br><span class="line"><span class="comment">考虑取第W[i][j]个物品，那么拿A2举例的话f[i][j][k][c] = f[i-1][j][k-1][c-W[i][j]]因为取第W[i][j]个物品那么对应的就是从k-1转移过来的</span></span><br><span class="line"><span class="comment">对应的C应该从之前已经选取k-1个物品中最大的价值C`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>,MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">13</span>][<span class="number">14</span>];<span class="comment">//f[i,j,k,c]</span></span><br><span class="line"><span class="keyword">int</span> W[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;W[i][j];</span><br><span class="line">            W[i][j]++;<span class="comment">//所有物品的价值都+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][W[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;  <span class="comment">//取第一件物品</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;         <span class="comment">//不取第一件物品,这里初始化C为-1其实更好理解,因为C的范围是在0到12，也就是说有可能为0</span></span><br><span class="line">                              <span class="comment">//取-1表示没取第一件物品，所以C初始化为-1，后面所有的物品价值都会大于-1</span></span><br><span class="line">                              <span class="comment">//但是数组下标最好不取负数，所以把所有的物品价值W[i][j]都++，第一件不取C初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//已经初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt;= k;u++)(u和v都是从<span class="number">0</span>开始的)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt;= <span class="number">13</span>;v++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> &amp;val = f[i][j][u][v];<span class="comment">//用一个val做别名免除很长的f[i][j][u][v]</span></span><br><span class="line">                    val = (val + f[i<span class="number">-1</span>][j][u][v]) % MOD;<span class="comment">//每加一次都需要取模</span></span><br><span class="line">                    val = (val + f[i][j<span class="number">-1</span>][u][v]) % MOD;</span><br><span class="line">                    <span class="keyword">if</span>(u &gt; <span class="number">0</span> &amp;&amp; v == W[i][j])&#123;<span class="comment">//因为要取出一件来，所以u必须大于0(保证u-1大于0)，且只有当C对应的为W[i][j]时才能取出这一件来</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c &lt; v;c++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        val = (val + f[i<span class="number">-1</span>][j][u<span class="number">-1</span>][c]) % MOD;<span class="comment">//因为MOD为1000000007，那么最多只能加两个数取模，否则有可能爆int</span></span><br><span class="line">                        val = (val + f[i][j<span class="number">-1</span>][u<span class="number">-1</span>][c]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">13</span>;i++) res = (res + f[n][m][k][i]) % MOD;<span class="comment">//最后再把走到[n,m]取了k个数，价值从1到13(因为之前把W[i,j]都加了1)每个相加再取模得到最后的结果res</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维前缀和</title>
      <link href="/2020/01/29/AcWing796-TwoDimensionOfSum/"/>
      <url>/2020/01/29/AcWing796-TwoDimensionOfSum/</url>
      
        <content type="html"><![CDATA[<h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><center>二维前缀和</center></h1><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/76098630_p0_master1200.jpg" alt></p><a id="more"></a><h1 id="什么是前缀和？"><a href="#什么是前缀和？" class="headerlink" title="什么是前缀和？"></a>什么是前缀和？</h1><h2 id="前缀和的定义"><a href="#前缀和的定义" class="headerlink" title="前缀和的定义:"></a>前缀和的定义:</h2><p>对于给定的数列A，它的前缀和数列S是通过递推来求出来的部分和<br>即<br>S[0] = A[0];<br>S[1] = A[0] + A[1];<br>S[2] = A[0] + A[1] + A[2];<br>…<br>S[n] = A[0] + A[1] + A[2] + … + A[n];</p><h2 id="这样做有什么好处？"><a href="#这样做有什么好处？" class="headerlink" title="这样做有什么好处？"></a>这样做有什么好处？</h2><p>对于一个数列来说，我想求从下标m到n这一个区间的和<br>如果不处理的话一个一个累加A[m] + A[m+1] + … + A[n]<br>需要O(n)的复杂度<br>我如果询问n次那么每次都要累加n次<br>时间复杂度就是O(n^2)</p><p>很显然，如果每次询问的区间有重叠的话那我们每次都要累加多余的次数<br>这个时候我们就要想办法去消除这种多余的步骤来降低我们的时间复杂度</p><p>于是我们可以提前预处理数组，取一个前缀和数组来存放数列的前缀<br>这样，如果要求区间[m,n]的和的话值为S[n] - S[m-1]<br>通过预处理把时间复杂度降到了O(1) (用前缀和数组存放也是一种空间来换时间的思想)</p><p>这便是一维前缀和的情况<br>但是如果我们遇到了二维的情况应该怎么办呢？</p><p>下面来用一个例题来为讲解二维前缀和</p><hr><h1 id="二维前缀和-1"><a href="#二维前缀和-1" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p><a href="https://www.acwing.com/problem/content/798/" target="_blank" rel="noopener">传送门</a></p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/AcWing796.png" alt></p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/example.png" alt></p><p>从例题给的数据开始举例<br>当前的二维数组(前缀和数组的下标统一从1开始)<br><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/1.png" alt><br>原数组A[i][j]表示存放原始数据<br>二维前缀和数组S[i][j]表示从A[1][1]到A[i][j]这个矩阵的所有的和</p><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/2.png" alt><br>怎么求二维前缀和数组？</p><p>假设我想求[2,2]这个点的二维前缀和<br>可以利用容斥原理<br>即图中的两个黄色部分(黄色部分包括那个小的蓝色部分)<br>中间那个蓝色部分被加了两次所以要减去<br>最后剩下那个白色部分A[2,2]加上即得到了整个二维前缀和</p><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/3.png" alt="如图所示"><br>用代码表示即<br>s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];</p><p><img src="/2020/01/29/AcWing796-TwoDimensionOfSum/4.png" alt><br>计算了二维前缀和接下来就要计算子矩阵的和了<br>假设我要计算从[x1,y1]到[x2,y2]这一部分的前缀和<br>同样利用容斥原理<br>大的矩形S[x2,y2]<br>减去y1旁边的小矩形(黄色部分)s[x2,y1-1]<br>减去x1旁边的小矩形(黄色部分)s[x1-1,y2]<br>最小的那个部分减去了两次需要重新加回来s[x1-1,y1-1]<br>即<br>s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]</p><hr><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn],s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];<span class="comment">//计算二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[x2][y2] - s[x1<span class="number">-1</span>][y2] - s[x2][y1<span class="number">-1</span>] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);<span class="comment">//从二维前缀和计算子矩阵的和</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记念自己的21岁。</title>
      <link href="/2020/01/22/20200122/"/>
      <url>/2020/01/22/20200122/</url>
      
        <content type="html"><![CDATA[<h1 id="一个旁观者的自我陈述"><a href="#一个旁观者的自我陈述" class="headerlink" title="一个旁观者的自我陈述"></a><center>一个旁观者的自我陈述</center></h1><p><img src="/2020/01/22/20200122/76377786_p0_master1200.jpg" alt><br>不知道自己在写什么东西…<br>可能自己观察自己也是很难的一件事吧。<br><a id="more"></a><br>不经意之间，又来到了一个我自己特别熟悉但是又不想去面对的日子——1.22</p><p>没错，原来自己又老了一岁啊(叹气)，从去年正式20岁的那股兴奋劲，一年之后自己并没有多少变化，反倒每天过的更加颓废、更加消沉，人生好像也早已没有了奋斗的目标</p><p>可能是我潜意识地觉得自己老了吧，我本身的心态也不好，面对各种事情想的并不是如何去挑战如何去解决，反倒是心底里先一步就胆怯了，我，好像真的变了吗？</p><p>原来的我是个多么自信的一个人呐，做什么也不服输，不相信自己的能力比任何人差。<br>但不知道从什么时候开始，慢慢的，我就好像失去了那股奋斗的动力，失去了那种自信，在潜意识里面接受了不如别人的事实<br>渐渐地，我开始变得逐渐内向了起来，不喜欢说话，不喜欢去交朋友，不喜欢和陌生的人接触交流，整天活在自己的小世界里面<br>没错，在现实里面我可能是一个非常喜欢自闭的人吧，平时跟室友之类的人接触也只是表面应和下，学校里面说实话也没几个真正能够称得上朋友的人</p><p>不过在网络里面我却表现的很活跃，认识了不少朋友，平时能够一起说笑其实是一件很开心的事情，既然现实里面没有性格类似且兴趣相近的人，那么只有网上才能够把我们聚到一起了，但是这样做最后导致的结果就是我和很多我以前的好朋友都失去了联系，尤其是我的初中同学们，他们大多都在优秀的大学里面不断的提升自己，随手转发的说说其实都时刻鼓舞着我要像他们学习，我也挺向往他们那样的生活的，不论是网上还是现实之中都活的挺开心的，我从心底里羡慕别人，但是却又迟迟不敢自己去行动，去改变自己，没错，可能是我太在意别人的看法了吧，准确的说是不是那么熟的人面前我不太敢表现自我，只有关系特别好的人面前我才敢把自己真正的性情展现出来，所以口嗨确实很爽但是落实到实际行动里面我还是不太行qwq</p><p>不说废话了，多立flag然后贴到墙上才能时刻提醒自己吧<br>就像看到一个up主所说的，“坐在一个沙漠里面，周围没有人，就会感到自己非常的渺小，希望新的一年自己能够在b站这个平台上不再渺小”<br>然后今年他真的做到了，拿到了百大，也突破了百万粉<br>而他今年立的一个个flag，也全都实现了<br>这实在是太鼓舞我了，看着自己喜欢的up从默默无闻到现在这样的成就，而自己依旧没有什么变化<br>这种心态是很复杂的，但是也给予了我一个不断前进的动力吧！<br>我也希望能够收获更多，收获友情乃至爱情是我不断向往的事情。</p><p>新的一年，希望在知乎这个平台变得不再那么渺小吧！一起加油！</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认真你就输了</title>
      <link href="/2019/12/25/2019-year-end-summary/"/>
      <url>/2019/12/25/2019-year-end-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="随便写一点东西"><a href="#随便写一点东西" class="headerlink" title="随便写一点东西"></a><center>随便写一点东西</center></h1><p>先占个坑，这几天慢慢把年度总结写一下吧！这一年有过遗憾也有过精彩的时刻，有过欢乐也有过失落的时候，我想好好地写一写今年的感受。</p><p><img src="/2019/12/25/2019-year-end-summary/77880953_p0_master1200.jpg" alt></p><h1 id="致终将逝去的20岁。"><a href="#致终将逝去的20岁。" class="headerlink" title="致终将逝去的20岁。"></a><center>致终将逝去的20岁。</center></h1><a id="more"></a><p>看了看自己去年写的一些东西，真的是笑了出声，明明有很多事想去做也明明有大把的时间为什么会变成这样子呢<br>看着自己慢慢变老一无所有，看着别人应有尽有<br>呐呐，这真的是你想要的么？</p><hr><p><img src="/2019/12/25/2019-year-end-summary/20191226.png" alt></p><p>一条一条的来说，不想回避也没啥不好意思的，我的脸皮已经很厚了(bushi</p><p>1.每天坚持刷算法题，刷完洛谷提高组的题目</p><p>这个确实是没有坚持下来，有的时候甚至一个星期都没有做几道算法题。<br>未来打算就是去每天参加leetcode上的周赛和双周赛以及洛谷上的相关题目<br>反正2020年一定要好好坚持下来！</p><p>2.学习C++，java什么的</p><p>咳咳，这个目标和我当初想的差距比较远，去年的这个时候还没有意识到现在该干嘛，C++和java其实两个学好一个就行了，所以明年会继续学好C++呢</p><p>3.学习前端三件套(html+css+js)</p><p>这个本来在寒假我其实就学的差不多了，但是大半年没用了估计也忘得差不多了，所以给我的启示就是你决定做什么事情一定要经常去做去练去刷题去实践才行吧。</p><p>4.每天学习英语,6月一次性过6级</p><p>每天学习英语这个还是没有坚持下来，但是6月份确实一次性的过了六级还是让我很开心吧，但是考的分数并不高，12月份准备刷分来着但是也没有好好的去准备只是又裸考了一次，嘛，明年要坚持每天学习英语并且养成阅读的习惯，重点准备考研英语吧。</p><p>5.每周刷数学一题目，准备考研</p><p>这个确实没有坚持下来，嘛，我对数学还是有自己的一份热爱的吧，虽然没能坚持下来，但是明年可能需要我重新找回那一份的感觉吧。</p><p>6.准备CCF和PAT的比赛</p><p>这个今年没有准备，但是明年三月份准备去考PAT,CCF以后有机会也会去考虑吧</p><p>7.学习LINUX</p><p>这个其实很早就开始计划要学习了，但是一直没有学习上的动力驱使着我去学习这个所以只是下了个虚拟机装了Ubuntu但是还没有开始学习，明年大概没时间去学习，但是未来有时间一定会去接触的。</p><p>8.玩单片机或者树莓派</p><p>硬件方面本来准备接触的，但是今年居然一直没抽出时间去接触去了解，但是明年还是专注于软件方面，先把基础知识先补齐全再说吧。</p><p>9.准备数模比赛，微信小程序比赛之类的</p><p>数模比赛是没机会去参加，因为如果要参加的话学校就会强制要求暑假参加集训并且还要参加两轮考试才能被参加，我真的不想再吐槽这学校官僚主义有多严重了，反正就是跟我的计划冲突我也不想去强制参加什么集训反正国赛是放弃了，美赛也没精力去参加了，其实挺遗憾的，只能在其他方面补救了。</p><p>微信小程序比赛这个最后不了了之了，不想再说了。</p><p>总之以后如果下定决心去参加什么比赛的话就一定要坚持到底，所以明年的目标我会考虑的很清楚，不会给自己定很多没意义的目标。</p><p>嘛，总之花了两天时间回顾了自己今年立下的一个个flag，明天再来回顾下今年自己发生的各种事情吧！</p><hr><p>去年的事不想再回忆了，不过在我脑子里也真的没什么事能够留下印象，有印象的就是一开年元旦给我发的比赛证书，过年时豪情万丈，上半年课少的轻松，暑假结识了一个志同道合的大佬然后又碌碌无为的情况还有十月份出去旅游的开心以及不烦恼和十一月份的校赛，还有十二月份到今年初复习周的痛苦。</p><p>嘛，原来一年的事情一句话就能说完嘛，说明19年真的是很没有激情、很没有意思、很没有动力，20岁最黄金的开头就这么被我浪费了，剩下来的时间可要好好珍惜才行，呐。</p><hr><p>过去的就让它过去吧，就像昨天回到家跟家里聊起了过去种种的遗憾种种的失落，都在懊悔着当初我该怎么怎么样现在也不会这个样子<br>但是，已经没用了啊哈哈，虽说我人生的遗憾确实挺大的，我还是有信心在未来能够填满我当初失去的，以及没有得到的，我统统都要拿回来才行呢。</p><p>嘛，现在再回头来看看自己4月份建博客以来的日记，简直个个都是黑历史一般的存在(雾)，就像再看那年今日的说说一样，都会感觉当初自己都好傻好笨</p><p>其实我自己的文笔一直都不算很好吧，第一我本来就不喜欢写东西，其次就是我也不喜欢表达自己的感情，最后导致了我也不太会写文章，有的时候逻辑什么的都不太清晰看知乎上别人都一条一条特别清楚就感觉自己差距真的挺大的。</p><p>嘛，不过我自己心里清楚我缺少最多的东西就是自信，嘛，在之前的博客里面写的很多东西其实也很多都透露出来了这一点，不自信-&gt;不敢表达自己的想法-&gt;有各种各样的担忧-&gt;不去行动-&gt;自闭，形成了一个循环了</p><p>就像有个朋友有一天跟我说，“你啊，整天把自己关在心里，一个人在角落默默努力，看上去比我还孤独比我还自闭”，当场瞬间就哭了</p><p>是啊，谁会喜欢孤独呢？谁喜欢一个人天天自闭，想找人说话都不能，我体会不到那些真正享受孤独的人的那种感受，我不希望我能有一天能够体会到，一点也不。</p><p>我也想和朋友们一起说说笑笑，一起去吃饭，一起去唱歌，一起去看电影</p><p>其实初中之前我是一个挺开朗的人，有一大堆优秀的朋友能够交流，那时的我也不胖甚至还有点小帅，如果你说当时的我能够成为我现在的样子，可能没有一个人会信吧<br>然后高中是一个黑暗的三年，大学也不在我满意的范围里面，然后整个人就越来越内向越来越自闭，不喜欢和外人说话不喜欢到现实里面和别人交流，只喜欢在网上和别人打字，网络可能是我最后的稻草了吧，在这里你也看不到我我也看不到你，大家都能放下戒心来聊天，其实我挺享受的，所以现实中的我和网上的我是两个人，我不希望这两者能够产生任何联系，也不希望有人能够同时认识这两个我，除非是特别特别亲密的人，我的戒备心其实也挺重的。</p><p>不过现在的我也没多少人关注就是了，归根到底还是什么样的水平认识什么样的人，反正我是这样的观点，我觉得自己当前的层次水平达不到平均水平，需要花时间去沉淀自己才行，所以我不喜欢去结交朋友，但是并不代表不想认识优秀的人，如果有人来找我我还是很乐意接受去分享给你我曾经的故事以及每天的喜怒哀乐，其实如果兴趣相投的话，每天其实能有一堆话可以说的。</p><p>心里话想说的差不多也都说完了，接下来还是好好想想今年该完成的几个目标吧<br>上半年大概的目标<br>1.准备三月份的pat</p><p>2.准备四月份的蓝桥杯</p><p>3.准备上半年学校的天梯赛</p><p>4.确定考研的学校、专业、方向，并开始准备初试</p><p>全年坚持的目标</p><p>1.坚持每天一道leetcode/洛谷/其他OJ</p><p>2.日常更新回答or文章</p><p>3.开始接触做视频</p><p>4.坚持写日记</p><p>5.坚持每天学习英语，坚持每天两道数学题</p><p>嗯…暂时想到的就这么多吧，等完成了某个目标之后我会及时更新的，等回了学校我也会写一份贴墙上，就先写这么多吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20191216</title>
      <link href="/2019/12/16/20191216/"/>
      <url>/2019/12/16/20191216/</url>
      
        <content type="html"><![CDATA[<h1 id="都好起来了呢"><a href="#都好起来了呢" class="headerlink" title="都好起来了呢"></a><center>都好起来了呢</center></h1><p><img src="/2019/12/16/20191216/77899254_p0_master1200.jpg" alt><br>最近一直都在发生好的事情，而且是一连串的发生，好像并不算是巧合呢。<br><a id="more"></a><br>上个星期三的早晨，本来是很平淡的一天，我还在漫不经心的复习着英语，突然知乎上有人私信我.</p><p>本来以为又是知乎管理员之类的私信，正想把碍眼的那个消息的小红点给按掉的时候.</p><p>原来是那个人重新注册知乎然后发现了我留下的呼唤重新找到了我<br>一瞬间，开心激动的心情瞬间充满了我的脑海里面.</p><p>可能这就是所谓的缘分所谓的幸福吗？</p><p>当你发现原来曾经做过很多不可挽回的事情突然发现有了新的转机的那种感受，真的很难言说出来.</p><p>再重新看看几个月前自己写下的怨恨的话，写下的种种不满，在现在看来是多么的幼稚多么的可笑，也许人不经历点事情是不会成长的吧.</p><p>所以以后我也不会说自己多么多么的成熟，因为在很多事情面前自己都还只能够算是一个孩子罢了。希望今后能够不断的进步不断的成长吧.</p><p>rebegin</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20191209</title>
      <link href="/2019/12/09/20191209/"/>
      <url>/2019/12/09/20191209/</url>
      
        <content type="html"><![CDATA[<h1 id="炒鸡开心的两天！！！！！"><a href="#炒鸡开心的两天！！！！！" class="headerlink" title="炒鸡开心的两天！！！！！"></a><center>炒鸡开心的两天！！！！！</center></h1><p>好开心好开心好开心啊，这几天发生的事情让我从心底里感受到了什么叫做真正的快乐，虽然在别人眼里看来可能真的没什么，但是对于我来说确实算是一个挺不错的经历了吧<br><img src="/2019/12/09/20191209/76783584_p0_master1200.jpg" alt></p><a id="more"></a><p>先说说比赛的相关的事情吧，从二十多天前就知道了校赛要来了，原来的我对待这种事情都是特别犹豫的，各种各方面的原因都会困扰着我不敢勇敢的做出最终的选择<br>正因为如此，我可能在大学这两三年的过程中错过了一个又一个的机会吧，比如上个学期本来是有机会去参加我喜欢的社团来着，但是当时我觉得自己已经大二了，已经错过了最好的加入的机会了，然后我就没去参加，但是我的室友去参加了，然后我只能眼睁睁的看着我的室友在社团里面交到好多朋友，认识到好多大佬，现在想想还是后悔的要死，因为大学明明有这么多的人，我却没机会认识到别人(潜意识里面我是觉得交朋友的话至少要到同一个水平上，不然很容易就躺列了之类的，这并不是我想要看到的结果)，可能我就是这么一个人吧，不满足自己的现状希望不断改变来提升自己，可能只有自己哪天成为了自己心目中想要成为的人我才会停止脚步吗(<del>但很明显不会有那么一天</del>)</p><p>咳咳，还是回到正题上来吧，我不想再错过这一次校赛的机会，不管我多老不管我多捞，我希望大学里面能够尽可能的多参加比赛啊，错过了现在的机会等我真正老了哪还会再有能够拼搏的机会呢？</p><p>于是我选择了参加，和一个朋友再拉了一个他的同学我们三个人于是便组成了一个队伍，在前半个月里面我们并没有在一起配合着练习，而是在图书馆里面选择了自己提升自己，虽然现在看来我在这半个月准备的时间还是有所不足，在学习的过程中最大的感受就是一定要做笔记才行，因为很可能你半个月前学过的东西你半个月之后再看就完全不懂了，现在就是我之前暑假学过的很多知识点我现在再看又完全不懂了，等于我的暑假相当于白费的感觉，不仅是今年的暑假，以前的两年也是差不多的这样子，养不成每天学习每天刷题的习惯，也就是半途而废的那种，每次都是等到期中或者期末考试就要中断一段时间的学习，然后长时间不去刷leetcode或者洛谷之类的OJ就完全不习惯了，然后过半个月就又傻眼了<br>所以这次我不想再重蹈覆辙了，因为留给自己的时间也不多了，12月到寒假结束的2月可能是我最后提升自己的机会了，也许人都是到了最后的关头才会急的人吧，再过一年零半个月不到的时间就是我去考研的时间了，当那种限期到来的时候的感觉是真的很煎熬，我希望我每天能过的充实起来，不仅只是在学习上，也可以在很多其他方面上呢，比如写写日记，刷刷知乎答答题之类的亦或者做做自己喜欢的视频啊，我觉得都是很有意义的事情呢~~那种感觉就好像是真正的找到了自己人生目标的感觉，虽然我现在还没有真正的意识到自己真正喜欢哪个领域的内容，但是我平时喜爱的东西已经能够让我兴奋起来了，也能够从中学到很多东西，这种东西这种感觉果然是别人教不来的，也许恋爱也会是这种样子吗(<del>我到底在想什么啊</del>)</p><p>诶多，好像又偏题了呢，咳咳，到了比赛的前三天我们才正式见面，第一天更是只匆匆的认识了下，然后第二天和第三天我们打印了试题去模拟了下试题，虽然模拟的感觉让我们感觉自己的水平还不太够，但是也别无办法了，毕竟只有短短的三天供我们去模拟了</p><p>然后就真正到了昨天的比赛日了，还是挺难忘的一天吧！早晨七点就被昨天已经约定好的老爸打电话把我叫醒，醒的时候整个人的精神状态还算是不错吧，前一天十一点左右就睡着了(幸好我的室友还算是好说话的人，要按照平时估计要开黑开到十二点之后，但我这次说了明天有比赛的话他们就挺安静的了)</p><p>诶多，然后就起床了，肚子巨不舒服，去上了厕所之后还是不太舒服，这个不适感一直伴随到我比赛临近开始都没有消除，和同学一起去了比赛的场地拿了参赛证，还有个吊牌(<del>看起来还蛮正规的，好歹也是个校赛吧</del>)算是个参加比赛的证明了，就算没得奖的话(<del>我这么想着，起码不要报名费吧</del>)，然后等到开幕式了，开幕式上真的是好多大佬啊，还有大佬代表来发言(<del>这就是我想要的目标啊</del>)，他们在自己的专业去参加比赛不仅提升自己的水平，为自己将来的发展铺平了道路，而且还很可能能够得到保研的资格，是我梦想中想要的生活(<del>还是当初吃了选择的亏，这点深有体会以后有机会再聊聊吧</del>)</p><p>从开幕式上我了解到一共有将近一百五十支队伍四百多个人来参加这个比赛，这个队伍在我看来是有点多了，不过我也并没有害怕，反倒是觉得越来越有意思了，想看看我跟别人队伍的差距到底在哪，嗯，然后就进了机房去调试机器了，上午的热身赛真的是让我一言难尽，三道题目其中两道题考到了素数，还有一道题考到了脑筋急转弯，我对素数什么的还不算很熟悉…欧拉筛什么的，反正就是很难受，但是已经到了比赛的那天了也顾不上那么多了。</p><p>十一点一起去食堂去吃饭，下午一点就要开始比赛也不敢吃太多，毕竟肚子还不是很舒服了，点了个小份的大盘鸡也没吃太饱就回宿舍了，十二点差一刻戴耳机睡觉，一直趴到了十二点半，没睡着，戴着耳机懵懵地趴了半天，然后洗了个脸清醒了，于是和队友就直接去比赛的场地了。</p><p>到了上午调试过的位置以后，周围已经是有很多人了，那种气氛有点压抑但是也没什么办法只能硬着头皮上了，嗯，很平静的就宣布比赛开始了，发了三本题目的册子和比赛账号，于是我们便开始为期四个小时的比赛了，一开始我从后面的K题开始看，然后其他人从前面的A题开始看，我们看到了几道签到题，于是我开始写K题到OJ上，可惜出事不利，我好像忘了特殊的情况，直接上来WA呜呜，队友刚开始也看着很不开心的样子，又试了一次继续WA，吓得我赶紧退下主位来给大佬去坐，自己赶紧装装样子去看别的题(<del>其实当时心里是有点不开心，毕竟开门”红”确实让人很难受</del>)，好在后来我们及时调整了状态，先就把签到题全部A了，然后再去思考那几题还有点思路的题，具体的过程就不细说了，反正过程算是很惊险的，其中最重要的就是两道重要的题我们A出来了，一道是C题一道是E题，虽然我自己A了E，也给大佬提供了C题的思路，我觉得我在这次比赛里面的功劳勉强还算大吧_(:<em>」∠)</em>，但是没有大佬的帮助我觉得我们这次连二等估计都莫得嘤嘤嘤，其中最遗憾的就是本来如果时间策略好一点我们其实可以再A出一道题就能拿一等奖甚至第一了(<del>还是有点耿耿于怀噫</del>)但是总体上的结果也算是让我满意了吧，起码也不枉费我这几十天的努力吧！<br>最后朋友还请了我们俩吃了顿饭，我觉得这顿饭可能是最温馨最香的一次饭吧，毕竟是用我们共同的努力所换来的。</p><p>说完了第一件比赛的事，第二件事可能就是蓝桥杯报名的一件事了吧，这件事也是让我整整难受了一个多星期吧，以为这个比赛是个人都能随便报的，结果还是要院校一起报名，但是众所周知我的专业是不负责这个比赛的，结果就是我只好去通过别的院的老师去报名，但是别的院的老师告诉我要去找自己院负责竞赛的老师去联系才行，但是我那个专业又没负责这个比赛的，所以就非常的矛盾，然后拖了几天吧，好多人互相推皮球好像都不想负责(<del>三百多的报名费都不想赚真的是</del>)好在今天终于是解决了，真心想感谢那个组委会老师，虽然是被规则所限定了，但是一直在给我想办法，给了我好几个老师的电话去主动拨打去联系，简单的一句“不行再来找我”真的是给了我莫名的信心，让我的心非常温暖，虽然在别人看来这可能只是一件微不足道的小事，但是在我很绝望很心塞的时候，组委会老师坚定的承诺确实是给了我莫名的鼓舞，他也从不耐烦语气也很温柔，以后我如果能够成为给别人带来价值，能够帮助他人的人我觉得其实也很棒呢！</p><p>所以，大概这就是这几十天以及这两天发生的故事吧，坚持学习然后心里煎熬了那么就大概也终于到了结束的时候吧，看着自己在日程表上一天一天划日期，虽然没怎么按着自己的计划来进行，但是结束之后再看会觉得自己心里有种很温暖的感觉。<br>没错，既是结束，也是一个新的开始，我从这个过程里面也了解了很多，也学到了很多，对自己最近几年的人生目标萌发了点自己的想法，虽然还不是很清晰，但我相信只要能坚持那些好的习惯坚持自己的爱好，虽然今年立的flag确实没怎么完成，但是我希望，明年的这个时候我能够胸有成竹，意气风发！但是这绝不只是口里说说就能够成功的。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dijkstra</title>
      <link href="/2019/11/30/dijkstra/"/>
      <url>/2019/11/30/dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈Djikstra算法"><a href="#浅谈Djikstra算法" class="headerlink" title="浅谈Djikstra算法"></a><center>浅谈Djikstra算法</center></h1><p><strong>前言</strong>：前几天在算法笔记上看到了晴神对于最短路径算法Dijikstra的一个深入的分析，我感觉挺感兴趣的，顺便想借此机会来深入分析，<del>顺带也是更新下博客了</del><br>咳咳，顺带说一句我的博客看起来挺乱的，等有时间会做一个分类吧，但我不想把它变成单纯的一个技术博客，而是记录一个我的学习，生活，感悟，以及展示自己兴趣爱好的地方(<del>虽然现在从哪方面看上去这人都挺low的</del>)</p><p>好吧，那就开始我对Djikstra算法的认识吧<br><a id="more"></a></p><h1 id="从最短路径算法Djikstra初谈"><a href="#从最短路径算法Djikstra初谈" class="headerlink" title="从最短路径算法Djikstra初谈"></a><center>从最短路径算法Djikstra初谈</center></h1><h1 id="什么是Djikstra"><a href="#什么是Djikstra" class="headerlink" title="什么是Djikstra?"></a>什么是Djikstra?</h1><blockquote><blockquote><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p></blockquote></blockquote><p>这是百度百科上的定义，用我们生活中的例子来讲<br>就相当于我们每天在地图上用的导航，导航可以帮我们在错综复杂的街道上，找到一条从出发地到达终点的最短路径</p><p>所以我们需要一个好的算法来干这事，而这种算法就叫做<strong>最短路算法</strong>(SSSP)</p><p>而其中Djikstra算法就是最短路算法中的一种(<del>当然也是最简单的一种</del>)</p><p>至于为什么叫Djikstra算法，因为Dijkstra算法是由一个叫Dijkstra的荷兰人发明的，故称此算法为Dijkstra算法。(<del>怎么这么多废话</del>)</p><p>好了，那现在进入正题</p><h1 id="Dijkstra算法的工作原理？"><a href="#Dijkstra算法的工作原理？" class="headerlink" title="Dijkstra算法的工作原理？"></a>Dijkstra算法的工作原理？</h1><p>因为这个算法是为了求出来在一系列限制条件下两个地方的最短路径，那么我们一般怎么找到从一个地方到另外一个地方的最短路呢？</p><p>对，我们首先得有一张地图才行啊</p><p>就拿我国庆去上海玩的经历来说吧</p><p>你现在刚从火车站出来搭地铁到人民广场这个下站了，天色已经很晚了，，但是你突然想走去黄浦江边的外滩去看风景</p><p><img src="/2019/11/30/dijkstra/photo1.png" alt="如图所示"></p><p>你可能要问，诶我为什么不继续坐地铁到那个南京东路下站然后再走去外滩啊，<del>这样不是更近吗？</del><br>(<del>然鹅不幸的是国庆的前几天南京东站的晚上基本上都是被封的</del>)</p><p>所以你只能选择走去外滩，当然你不可能像红色箭头这样飞过去了，不然警察叔叔会罚你 $10^{10} RMB的，所以你只能找到合适的道路走过去，也就是说你只能走那些<strong>标记为“路”的地方</strong></p><p>于是我们就可以把每一个路口或建筑看作一个<strong>点</strong>，有些点与另一些点之间有<strong>边</strong>连接，这个边其实就是马路，连结了两个地方。</p><p>当然，有些马路的车流量比较大，有些在比较小；于是有的马路通过需要花费的时间多，有的花费的时间少。我们把一条马路通过所需要花费的时间，称作这条边的<strong>权值</strong>。所有的点和边连在一起，就成为了一个<strong>图</strong>。<br>(<del>没错如果你想直接从人民广场直接直接走到外滩几乎是不可能的，人流量可以把你窒息死</del>)</p><p>图这种东西大概长这样：</p><p><img src="/2019/11/30/dijkstra/photo2.png" alt="一个简单的图的示意"></p><p>一个圆就是一个<strong>点</strong>，圆上的数字是点的<strong>序号</strong>，绿色的线是<strong>边</strong>，边旁边的橙色数字是边的<strong>权值</strong>。之所以加上箭头，是因为我们假设所有马路都是单行线（<del>双向车道改成两条单向车道不就好了</del>）。</p><p>具体的Dijikstra算法的证明过程在这里不再给出，具体的过程可以自行百度好了(<del>其实是我的证明水平还8太行</del>)</p><p>但是djikstra算法不适用于有负边权的图，在这里不再赘述(<del>才不会告诉你别人已经有更好的解释了啦</del>)</p><p><a href="https://blog.csdn.net/Kprogram/article/details/81220702" target="_blank" rel="noopener">戳这里</a></p><p>对我的理解来说，Djikstra算法最直观的一个解释就是以起点开始寻找有没有其他中介点能够使起点到达其他顶点的距离能够变小</p><h1 id="Djikstra算法的一个伪代码"><a href="#Djikstra算法的一个伪代码" class="headerlink" title="Djikstra算法的一个伪代码"></a>Djikstra算法的一个伪代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Djikstra</span><span class="params">(G, d[],s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    初始化</span><br><span class="line">    <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">        u = 使d[u]最小的还未访问的顶点的标号</span><br><span class="line">        vis[u] = <span class="literal">true</span>;<span class="comment">//记下u已被访问</span></span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; 以u为中介点使s到达顶点v的最短距离d[v]更优)</span><br><span class="line">            &#123;</span><br><span class="line">               优化d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中G为邻接矩阵，s为起点</p><p>vis[i] == true时表示顶点Vi已被访问，vis[i] == false时表示顶点Vi还未访问</p><p>d[]表示起点s到达顶点Vi的最短距离，初始化时除了起点的d[s]赋为0，其余的顶点都赋予一个很大的数(比如INT_MAX或者自己赋一个很大的INF)<br>(即相当于把除了起点与其他顶点的边权确认后，其余各个顶点之间的距离设为无穷大(即INF)，这样可以保证后来各个点的最短距离d[i]都是从起点s得来的)</p><h1 id="举一个简单的例子"><a href="#举一个简单的例子" class="headerlink" title="举一个简单的例子"></a>举一个简单的例子</h1><p>拿一个简单的有向图来举例子吧</p><p><img src="/2019/11/30/dijkstra/example1.png" alt></p><p>起点的d[s] = 0，其余点的d[i] = INF;</p><p><img src="/2019/11/30/dijkstra/example2.png" alt></p><p>开始循环，起点1可以到达点3和点2<br>先把vis[1] = true;下次就不再循环到起点1<br>因为d[1] + weight[1][3] &lt; d[3]所以更新d[3]<br>d[3] = d[1] + weight[1][3] = 3;<br>同理d[1] + weight[1][2] &lt; d[2]所以更新d[2]<br>d[2] = d[1] + weight[1][2] = 6;</p><p><img src="/2019/11/30/dijkstra/example3.png" alt><br>继续循环，寻找d[i]中最小的点(即离起点最近的)再开始计算<br>这时候d[3] = 3最小(因为d[1]已经被标记过了不再访问)<br>此时就以点3为中介点，看起点以它为中介点到达另外点的距离能不能变短<br>标记vis[3] = true;<br>此时d[3] + weight[3][2] &lt; d[2];<br>      3  +     2       &lt;   6<br>(即从1-&gt;3-&gt;2的距离比1-&gt;2的离更小)<br>所以更新d[2] = d[3] + weight[3][2] = 5;</p><p>又以点3中介点可以到达点4<br>d[3] + weight[3][4] &lt; d[4];<br>  3  +     3       &lt;   INF<br>此时更新d[4] = d[3] + weight[3][4] = 6;</p><p>同理以点3中介点可以到达点5<br>d[3] + weight[3][5] &lt; d[5];<br>  3  +     4       &lt;   INF<br>此时更新d[5] = d[3] + weight[3][5] = 7;</p><p><img src="/2019/11/30/dijkstra/example4.png" alt></p><p>此时还能访问的d[2] = 5,d[4] = 6,d[5] = 7,d[6] = INF;<br>然后继续循环发现d[2]最小，于是再以2为中介点进行寻找<br>vis[2] = true;<br>d[2] + weight[2][4] &gt; d[4];<br> 5   +      5       &gt;  6<br>此时不更新，由于2只能到达4所以结束循环</p><p><img src="/2019/11/30/dijkstra/example5.png" alt><br>此时还能访问的d[4] = 6,d[5] = 7,d[6] = INF;<br>于是以点4为中介点进行循环<br>vis[4] = true;<br>由于点4可以到达点5和点6<br>d[4] + weight[4][5] &gt; d[5]<br> 6   +      2       &gt;  7<br>不更新，继续循环<br>d[4] + weight[4][6] &lt; d[6]<br> 6   +      3       &lt;  INF<br>所以d[6] = d[4] + weight[4][6] = 9;<br>然后结束循环</p><p><img src="/2019/11/30/dijkstra/example6.png" alt></p><p>此时还能访问的d[5] = 7,d[6] = 9;<br>以点5为中介点进行循环<br>vis[5] = true;<br>由于点5可以到达点6<br>d[5] + weight[5][6] &gt; d[6]<br> 7   +      5       &gt;  9<br>所以不更新，结束循环</p><p><img src="/2019/11/30/dijkstra/example7.png" alt></p><p>此时还能访问的d[6] = 9;<br>vis[6] = true;<br>最后发现除了6自己以外其他点都已访问过，所以结束循环</p><p>最后的结果就是<br>d[1] = 0<br>d[2] = 5<br>d[3] = 3<br>d[4] = 6<br>d[5] = 7<br>d[6] = 9</p><p>至此算法结束。如果您人脑模拟出来跟上面的图示有不一致的地方建议您重新阅读本拙文。<br>如果您还看不懂请<a href="http://baidu.physton.com/?q=Dijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">戳这里</a>。</p><p>具体实现的代码，以邻接矩阵作为举例<br>这里是以<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PAT1003</a>为举例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;<span class="comment">//最大的城市数</span></span><br><span class="line"><span class="comment">//N表示一共有N座城市 M表示一共有M条道路 C1 C2分别表示起点和终点</span></span><br><span class="line"><span class="keyword">int</span> N,M,C1,C2;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;<span class="comment">//定义一个数组来判断城市是否被访问</span></span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];<span class="comment">//表示城市与城市之间的距离</span></span><br><span class="line"><span class="keyword">int</span> pre[maxn];<span class="comment">//存储前驱结点</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//记录最短距离,d[u]表示从起点s到达顶点u的最短距离</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];<span class="comment">//每个点的权值</span></span><br><span class="line"><span class="keyword">int</span> w[maxn];<span class="comment">//记录起点到每个点的最大权值</span></span><br><span class="line"><span class="keyword">int</span> num[maxn];<span class="comment">//num[u]表示起点s到达顶点u的最短路径条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//s表示起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+N,INT_MAX);<span class="comment">//把所有点的距离都抹掉</span></span><br><span class="line">    d[s] = <span class="number">0</span>;<span class="comment">//把起点的最短距离设置为0</span></span><br><span class="line">    w[s] = weight[s];<span class="comment">//起点开始的权值即为起点的权值</span></span><br><span class="line">    num[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123; <span class="comment">//循环n次</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,MIN = INT_MAX;<span class="comment">//u设置为-1是为了方便当找不到可以连接的点时方便判断,MIN存放最小的d[u],</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到未访问顶点中d[]最小的顶点,因为从起点开始更新了后面的d[u],然后下次循环就要从这个点寻找能到达顶点中距离最小的那个点</span></span><br><span class="line">            <span class="keyword">if</span>(d[j] &lt; MIN &amp;&amp; vis[j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;<span class="comment">//找到跟起点相距最短的那个点</span></span><br><span class="line">                MIN = d[j];<span class="comment">//更新最短的距离</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span> ;<span class="comment">//如果找不到小于INT_MAX的d[]，意味着剩下的顶点和起点s不连通</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;<span class="comment">//标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt; N;v++)</span><br><span class="line">        &#123;   <span class="comment">//如果u能到达v 且 v未访问 -&gt; 则以u为中介点到达v可以使d[v]更优</span></span><br><span class="line">            <span class="keyword">if</span>(G[u][v] != <span class="number">0</span> &amp;&amp; vis[v] == <span class="literal">false</span> )</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//当以u为中介点的时候能使d[v]变小</span></span><br><span class="line">               <span class="keyword">if</span>(d[u] + G[u][v] &lt; d[v] )</span><br><span class="line">               &#123;</span><br><span class="line">                  d[v] = d[u] + G[u][v];<span class="comment">//覆盖d[v]</span></span><br><span class="line">                  w[v] = w[u] + weight[v];<span class="comment">//更新w[v]</span></span><br><span class="line">                  num[v] = num[u];<span class="comment">//覆盖num[v]</span></span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(d[u] + G[u][v] == d[v])<span class="comment">//找到一条相同长度的路径后</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(w[v] &lt; w[u] + weight[v])<span class="comment">//如果这条路径的点权之和更大</span></span><br><span class="line">                   &#123;</span><br><span class="line">                      w[v] = w[u] + weight[v];<span class="comment">//更新</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   num[v] += num[u];<span class="comment">//有相同路径长度,则相加num[u],因为当d[u] + G[u][v] &lt; d[v]时候已经算出一个num[v]是符合条件的</span></span><br><span class="line">               &#125;                    <span class="comment">//那么当d[u] + G[u][v] == d[v]时之前d[u] + G[u][v] &lt; d[v]算的num[v]仍然符合条件,则继续加上现在相等时候的num[u]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分析算法的复杂度？"><a href="#分析算法的复杂度？" class="headerlink" title="分析算法的复杂度？"></a>分析算法的复杂度？</h1><p>从复杂度来看，主要是外层循环O(V)与内层循环(寻找最小的d[u]需要O(V)、枚举v需要O(V))产生的，总复杂度为O(V*(V+V)) = O(V^2).</p><p>但其实Djikstra算法是可以优化到O(nlogn + m)的级别的<br>为什么？<br>因为必须把每个点都标记为已访问(即vis[i] = true)，所以外层循环的O(V)时间是无法避免的<br>但是寻找最小的d[u]的过程可以不必要一个一个重新循环去寻找最小的那个的d[u]<br>可以通过堆优化来降低复杂度，最简单的做法就是直接用STL中的优先队列priority_queue(<del>STL依赖症</del>)</p><p>看了上面的代码你可能已经发现了一个问题，那就是如果题目除了最短路径还有其他的要求怎么办？<br>比如PAT1003里面就要求找到从起点到终点的最短路径的条数以及最短路径的数目之和<br>即最短的路径可能不止一条</p><p><strong>于是有三种主要的方式来进行考察</strong><br><strong>①</strong>新增边权，即以新增的边权花费为例<br>cost[u][v]表示从u -&gt; v的花费，并增加一个数组c[]，令起点s到达顶点u的最少花费为c[u]同理初始化的时候c[s] = 0,其余均为INF<br>这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和c[v]<br>而当d[u] + G[u][v] == d[v]时且c[u] + cost[u][v] &lt; c[v]时更新c[v]<br>(即可以是s到v的最少花费更优时更新c[v])</p><p>样例代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt; n;v++)&#123;</span><br><span class="line">   <span class="comment">//如果v未访问 &amp;&amp; u能到达v</span></span><br><span class="line">   <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF)&#123;</span><br><span class="line">      <span class="keyword">if</span>(d[u] + G[u][v] &lt; d[v])&#123;</span><br><span class="line">         d[v] = d[u] + G[u][v];</span><br><span class="line">         c[v] = c[u] + cost[u][v];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(d[u] + G[u][v] == d[v] &amp;&amp; c[v] &gt; c[u] + cost[u][v])&#123;</span><br><span class="line">         c[v] = c[u] + cost[u][v];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>②</strong>新增点权，即以新增的点权代表城市能收集到的物资为例，用weight[u]表示城市u中的物资数目，并新增一个数组w[]，即从起点s到达顶点u可以收集到的最大的物资为w[u]，初始化的时候w[s] = weight[s],其余均为0，这样就可以在d[u] + G[u][v] &lt; d[v]时更新d[v]和w[v]<br>而当d[u] + G[u][v] == d[v]时且w[u] + weight[u][v] &gt; w[v]时更新w[v]<br>(即可以使s到v的最大物资更优)<br>代码与上面类似不再给出</p><p><strong>③</strong>求最短路径条数，只需要增加一个数组num[]，令从起点s到达顶点u的最短路径条数为num[u]，初始化时num[s]为1，其余num[u]均为0<br>这样可以使当d[u] + G[u][v] &lt; d[v]使num[v]继承num[u]<br>而当d[u] + G[u][v] == d[v]时将num[u]加到num[v]上</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt; n;v++)&#123;</span><br><span class="line">   <span class="comment">//如果v未访问 &amp;&amp; u能到达v</span></span><br><span class="line">   <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF)&#123;</span><br><span class="line">      <span class="keyword">if</span>(d[u] + G[u][v] &lt; d[v])&#123;</span><br><span class="line">         d[v] = d[u] + G[u][v];</span><br><span class="line">         num[v] = num[u];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(d[u] + G[u][v] == d[v])&#123;</span><br><span class="line">         num[v] += num[u];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>鉴于时间关系暂时就先总结这么多，Dijikstra算法其实能扩展的东西还有很多，比如如果题目要求具体的最短路径的话还要另外增加一个记录前驱结点的数组之类的东西，等以后有时间我再来补齐吧!</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20191120</title>
      <link href="/2019/11/20/20191120/"/>
      <url>/2019/11/20/20191120/</url>
      
        <content type="html"><![CDATA[<h1 id="平静的生活也需要心灵的慰藉"><a href="#平静的生活也需要心灵的慰藉" class="headerlink" title="平静的生活也需要心灵的慰藉"></a><center>平静的生活也需要心灵的慰藉</center></h1><p>最近在读吴军老师这几年出的新书《见识》<br>感觉给我带来的东西确实挺多的，不像是豆瓣上别人说的那种鸡汤文<br>吴军老师确实是在用他漫长人生中遇到的种种事例来举例子所得到的一些感悟和体会，比如在谷歌时期工作时候遇到的很多优秀的同事从中学习到了很多优点，亦或者是谷歌的两个联合创始人拉里佩奇和谢尔盖布林的一些故事，从中可以感受到谷歌之所以能取得如今这样的成功，并不是偶然。<br>并把他所遇到的人和事都亲口讲述出来。<br>确实和我的切身体会差不太多，除了没有职场的那些经历，其他的在我不长的人生中其实已经有太多的感悟了。<br>提到“见识”，就会想起高中数学老师给我讲的那句话，我至今仍然时刻记在心中<br>“眼界决定境界，态度决定高度”<br>当时上高中的时候还不以为然，现在真正出来了，到了新的世界才感受到了自己的渺小，自己的无知，然后会产生一种很大的遗憾感，把自己的前几年拿来和那些有见识有眼界的人的来比简直就是可笑</p><hr><h1 id="人生需要做减法"><a href="#人生需要做减法" class="headerlink" title="人生需要做减法"></a><center>人生需要做减法</center></h1><p>有的时候我们是不是应该静下来思考一个问题，每天自己到底在忙什么？每天给自己布置那么多的任务到底有用吗？整天下来确实很忙，但是自己真的学到东西了吗？</p><p>我很赞同吴军博士他在这里表达的一个观点，就是我们需要对我们自己的事情做减法<br>诚然，的确有那种每天做很多事还能做的很好的人，但那毕竟是少数。大多数人其实每天能做好一两件事已经达到一个人每天精力的上限了<br>正因为如此，我们需要给自己做减法，吴军博士在书中阐述自己能够成功的原因不是因为很会合理安排时间(当然合理安排每天的时间并不是说一点用也没有)，而是因为他每天少做很多不必要的事情。<br>我们不禁反问自己，自己每天真的需要做那么多那么多的事情吗？难道有些事情不做天就会塌下来吗？<br>仔细想想确实，对于我自己来说，这两三年来确实给自己布置了太多任务了，每天忙来忙去但是其实到头来收获其实没有多少，自己现在的各种意义上的水平和自己两三年刚入学的时候其实并没有多少提升，想想就很惭愧，但是这也从另外一个方面体现出一个人的思考和每天的习惯对一个人的影响有多大，但是这不正是因为自己之前没有多少见识，只会一味的伪努力去感动自己，可能一时确实还以为自己不错，哎呀又不怎么打游戏又不干别的事，但是长期来看伪努力和那些天天打游戏上课摸鱼的又有什么区别呢？还不都是什么都不会，还不如当初好好玩呢(暴论)，所以最后落得个学也没学好，玩也没玩好的尴尬的地步了。<br>所以我特别认同他的话，“人生需要给自己做减法”，不仅仅是学习工作中，其实各种意义上都是如此，每天如果能够做好一两件事并且能够坚持的下来，对于一个人的潜移默化的好处是不可言喻的。<br>但是现在的人可能就是如此，或者说人本身就有一种贪婪的本性，就是什么都想要，什么也不想舍弃，“我全都要”的调侃可能是每个人心中都想要达到的目标，但是现实往往并没有如此的简单，因为本身“做好一件事”其实就已经要花费人大量的时间和精力了，更何况是还要涉及很多领域的知识(当然我在这里针对的是像我这种平凡的普通人来说)<br>对于我来说我其实对很多方面都很感兴趣，政治，历史，计算机，经济，金融，甚至是投资这方面的知识，当然一个人兴趣多是好事，但是也要分阶段分精力去学习才行，对于我来说今年还剩下一个月的时间，明年的这个时候就要准备考研计算机了，对于我来说最重要的东西当然是计算机专业相关知识的学习了，其他的东西都可以放一放，所以我要抓紧时间去学习算法相关的知识，不仅是为了准备半个月之后的比赛，更是为了自己的前途和明年的考研要开始做准备了。<br>道理听起来确实简单，但是很少有人能够真正地自我剖析，能够真正的明白自己当前任务的主次才行，所以很多事都是说起来容易做起来难，这跟平时人们常说的“道理谁都懂”等诸如此类的话罢了，先达到每天能做好一件事的水平之后再去干更多的事情<br>要认识到人的精力和能力都是有限的，尽可能地去做那些捡西瓜的事而不是去捡芝麻，把宝贵的时间浪费在一点微不足道的蝇头小利上，付出和收入实在是不成正比。<br>的确，人的眼光往往是短视的，就跟在a股投资差不多，赚短期赚快钱是一件很爽的事情但同时伴随着高风险，很可能一不小心你就栽跟头了，这个时候人们容易追涨杀跌从而亏得叫苦连天，只有长期坚定不移的投资才能给自己带来合理的回报。<br>同理，做人又何尝不是如此呢，在我的身边其实就有两类人，一类是贪图享受，每天从早到晚都只会打打游戏看看剧聊聊天，日子过得好不自在。另一类就是所谓的伪工作者，每天从早到晚待到自习室感动自己，以为自己很努力，甚至还要发说说发朋友圈作秀，但其实一点用也没有，到头来跟前一类人没多大区别。<br>我们所要避免的就是成为这两类人，提早的认清自己，认清自己将来的目标将来的发展，认清每天应该要做什么事情，哪些是重要的哪些是不重要的</p><p>&lt;未完待续…..&gt;<br>这篇blog我会随着这本书的感悟每天都写一点，嗯，也是看完书对自己的一种记录吧，每天都写一点收获和体会，不一定要刻意的去对待，但是把得到的收获每天记录下来警醒自己我觉得是有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天一点小感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1032</title>
      <link href="/2019/11/13/PAT-1032/"/>
      <url>/2019/11/13/PAT-1032/</url>
      
        <content type="html"><![CDATA[<h1 id="1032-Sharing"><a href="#1032-Sharing" class="headerlink" title="1032 Sharing"></a><center>1032 Sharing</center></h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920" target="_blank" rel="noopener">传送门</a></p><p><img src="/2019/11/13/PAT-1032/PAT1032.png" alt="题目"></p><a id="more"></a><p>题目的大意就是:</p><p>给出两条链表,要你找出两条链表第一个相交点<br>如果有相交点,给出相交点地址值,如果没有,返回-1</p><hr><p>思路：<br>1.给出两条链表，我把所有的结点都标记为false(或者0)，然后我标记第一条链表的所有点为ture(或者1)，我再从第二条链表开始遍历，如果遇到标记点为1就为相交点，如果没遇到就说明两条链表没有相交点</p><p>注意事项：<br>1.这题应该用静态链表比较合适，用map容易超时<br>2.再用静态链表的时候定义maxn一定要大一点,因为数组的index值也很大(比如11111,22222)，否则数组会越界，PAT会报错“段错误”<br>3.最后输出的时候要用print(“%05d”)来输出，因为我是用int型来保存地址的嘛，所以在输入00002的时候他会保存为2，那么我在输出的时候就应该在前面补0才行<br>4.静态链表的next结点不是指针</p><hr><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PATA 1032 Sharing</span></span><br><span class="line"><span class="comment">//题目大意：给出两条链表,求出两条链表的第一个共用结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1,s2;<span class="comment">//s1和s2分别为第一二条链表的首节点</span></span><br><span class="line">    <span class="keyword">int</span> N;<span class="comment">//N表示一共有N个结点</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2&gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> address,next;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;address&gt;&gt;data&gt;&gt;next;</span><br><span class="line">        node[address].data = data;</span><br><span class="line">        node[address].next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = s1;p != <span class="number">-1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        node[p].flag = <span class="literal">true</span>;<span class="comment">//flag为true表明在第一条链表上</span></span><br><span class="line">        p = node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = s2;q != <span class="number">-1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[q].flag == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = q;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q = node[q].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;result; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> PAT-A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1059</title>
      <link href="/2019/11/02/PAT-1059/"/>
      <url>/2019/11/02/PAT-1059/</url>
      
        <content type="html"><![CDATA[<h1 id="1059-Prime-Factors"><a href="#1059-Prime-Factors" class="headerlink" title="1059 Prime Factors"></a><center>1059 Prime Factors</center></h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488" target="_blank" rel="noopener">传送门</a><br><img src="/2019/11/02/PAT-1059/PAT1059.png" alt></p><a id="more"></a><p>题目大意：<br>就是分解一个质因数</p><p>思路：<br>如果要分解一个质因数，那么最简单的思路就是从2开始相除，直到不能除尽为止，同时记录除每个质因数的次数，最后按题目的要求输出</p><p>所以要几个步骤：<br>1.首先列出一个素数表<br>2.从素数表里面依次相除，并记录每个可以相除质数的次数<br>3.打印的时候要注意最后一个不能有*符号<br>(所以我需要用一个num来记录有多少个不同的质数方便最后打印)<br>4.用一个fac的结构体来记录质数和次数</p><hr><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分解质因数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn],pNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[pNum++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; pNum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * prime[j] &gt; maxn) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            p[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,cnt;<span class="comment">//x记录质因数,cnt记录质因数的个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>,n;<span class="comment">//num为不同质因子的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decomposePrimeFactor</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>,i = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(n % prime[temp] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[i].x = prime[temp];</span><br><span class="line">            fac[i].cnt++;</span><br><span class="line">            n /= prime[temp];</span><br><span class="line">            <span class="keyword">if</span>(n % prime[temp] != <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setPrime();</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"1=1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    decomposePrimeFactor(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fac[i].cnt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cmp == num<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;fac[i].x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cmp++;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;fac[i].x&lt;&lt;<span class="string">'*'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fac[i].cnt &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cmp == num<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;fac[i].x&lt;&lt;<span class="string">'^'</span>&lt;&lt;fac[i].cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               cmp++;</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;fac[i].x&lt;&lt;<span class="string">'^'</span>&lt;&lt;fac[i].cnt&lt;&lt;<span class="string">'*'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT-A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20191007</title>
      <link href="/2019/10/07/20191007/"/>
      <url>/2019/10/07/20191007/</url>
      
        <content type="html"><![CDATA[<h1 id="上海之旅"><a href="#上海之旅" class="headerlink" title="上海之旅"></a><center>上海之旅</center></h1><p>已经上了两年的大学了，还从来没有好好出去玩过一次，于是一个月前，我就和两个同学计划在国庆7天里面好好出去玩玩，如今已经旅游完回到宿舍，不觉感叹美好时光的短暂，也从这次旅游之中感触到自己的很多不足，也是希望借机会记录一下自己的生活吧，反正自己的blog想写啥就写啥咯，记录一点不一样的东西可以让我的心宁静下来吧。<br>(其实就是想记录记录流水账，让自己记忆还未忘却的时候用文字和图片记录下来，我觉得这也是旅游的意义之一吧，而不是去过了什么收获体会都没有)<br><a id="more"></a></p><hr><h1 id="9月30日-amp-10月1日"><a href="#9月30日-amp-10月1日" class="headerlink" title="9月30日 &amp; 10月1日"></a><center>9月30日 &amp; 10月1日</center></h1><p>下午6点的车去魔都，4点后翘掉选修课回去洗了个澡穿了身新衣服就和同学坐地铁去火车站了，随便吃了点什么就上车了</p><p><img src="/2019/10/07/20191007/IMG_20190930_175203.jpg" alt></p><p>这还是我人生中第一次体验绿皮火车吧，之前从来也只坐过高铁动车之类的，坐火车过夜倒是人生中的第一次，去之前其实心里也有点忐忑不安，因为说实话之前已经在知乎上看到有好多人说卧铺怎么怎么不好，同学也都跟我说里面空气不太好</p><p>不幸中的万幸可能就是我在订火车票的时候把我们三个都订在同一边的铺位上了吧，这样子还挺方便我们互相照顾的</p><p>进去之后果然，感觉里面的位置都好小好紧，人们都坐在过道旁边的座位上，吃着东西有说有笑，我和同学走了很久才找到了自己的铺位</p><p><img src="/2019/10/07/20191007/IMG_20190930_180937.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20190930_180950.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20190930_181911.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20190930_182346.jpg" alt></p><p>“有个小桌子，有被子有枕头，我睡在下铺应该没什么大问题吧”，我内心这样想着<br>于是，把东西放下后不久后火车便缓缓的开动了<br>让我出乎意料的是平时在学校用的不怎么样的联通卡，在火车上的信号居然奇好无比(比我同学的移动简直好不完，经常找我开热点给他)<br>闲着无聊，我于是在火车上就开始写作业，一直写了差不多3个小时的样子吧，到十点火车上熄灯了，同学也都从我床上上去休息了，我也差不多躺下来看会手机<br>这一躺不知道，躺下去才知道火车是有多晃啊，当时我就感觉晚上睡觉不会顺利了(最后也没出乎我的意料)<br>刷着手机过了凌晨，上完厕所去睡觉，躺下来蜷缩在被子里面，因为我有很严重的鼻炎的缘故，我每天睡觉只能侧着身子睡觉，但是火车晃的很严重让我侧着身子经常睡不好，于是就这样半睡半醒的样子持续到了4点多钟，迷迷糊糊的到了5点半，乘务人员就来叫醒我们准备下车了<br>我去洗了个脸，用发泥弄了下自己的头，内心其实有点期待和不安吧，期待的是魔都能够给我带来什么样的惊喜，不安的是自己眼界不足，总感觉出去会丢人之类的想法。</p><p>嗯，总算是出站了，可是外面下着大雨让我的心里的不安达到了极点</p><p><img src="/2019/10/07/20191007/IMG_20191001_065330.jpg" alt></p><p>没错，我当然知道要提前看天气，9月28日那天我就知道1号的时候会有台风天气，说实话，一直只待在内地的我确实还从来没有经历过台风天气，以前都是只能从电视上或者手机上的新闻了解到台风有多么多么厉害，好了，现在可算是“身临其境”了。</p><p>出了火车站就直接去地铁站感受下魔都地铁的便捷</p><p><img src="/2019/10/07/20191007/IMG_20191001_070802.jpg" alt></p><p>令我惊讶的是来的时候地铁站里面居然没有很多人，可我看新闻明明魔都是国庆人们出游最多的地方了，“这台风是有多厉害喔，难道劝退了这么多人吗”<br>由于订的民宿中午十二点之后才能入住，所以这之前我们要随便找个地方去转转</p><p><img src="/2019/10/07/20191007/IMG_20191001_072227.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_072428.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_072437.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_072654.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_073342.jpg" alt></p><p>直奔云南路去找b站上那些大大们推荐的地方去随便吃点早餐吧<br>到魔都早点最有名的就是生煎和锅贴了吧，于是在云南路上找了家店坐下来，外面居然就下起了暴雨了起来(原来这就是台风的威力吗)</p><p><img src="/2019/10/07/20191007/IMG_20191001_074349.jpg" alt></p><p>等了几分钟点了两份锅贴和馄饨，不得不说，魔都本地的锅贴和我在学校吃的真的完全不一样，我觉得最大的不同点就是它里面的汁是真的足，吸完汁再吃一大口肉馅，那种感觉是真的不一样</p><p><img src="/2019/10/07/20191007/IMG_20191001_080501.jpg" alt></p><p>吃完了早餐，由于离中午还有很久的时间我们就到人民广场附近随便转转，由于雨实在是太大了我们于是就找了家全家去避雨去了(魔都随处可见的便利店简直是不能再方便了)</p><p><img src="/2019/10/07/20191007/IMG_20191001_085907.jpg" alt></p><p>等雨小之后我们于是继续在附近转，准备去附近的广场公园去看看</p><p><img src="/2019/10/07/20191007/IMG_20191001_094352.jpg" alt></p><p>不看不知道，一看是真的把我美倒了<br>“魔都这里的公园才能叫公园啊，有花有草有小溪有湖，里面还有一大群鸟儿，甚至还有橘子树”，其他地方的公园和这里一比简直是弱爆了。。。</p><p><img src="/2019/10/07/20191007/IMG_20191001_094518.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_094559.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_095045.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_094755.jpg" alt></p><p>继续走，到了十点钟也正好是阅兵的时候，我们也正好走到了上海市政府中心的位置(正好也是阅兵刚开始的时候吧)，我们也顺便一遍走一遍观看阅兵的直播。</p><p><img src="/2019/10/07/20191007/IMG_20191001_102902.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_103140.jpg" alt></p><p>不知不觉居然就走到了南京路步行街附近，但是第一天我们的计划里面并没有计划在这里好好玩，于是我们在美团里面找到了这附近评分最高的一家叫“南京大牌档”的地方去吃第一顿午餐了</p><p><img src="/2019/10/07/20191007/IMG_20191001_115310.jpg" alt></p><p>不得不说这家餐厅里面的上海菜的确有它的特点，偏甜，偏小，里面的粥挺好喝的，还有类似的糕和小吃都能满足我们的味蕾，价格方面也不算离谱(没错，这顿饭也是这次旅游里面体验最好的一次了)</p><p>吃完饭，将近十二点了，于是我们便坐地铁到龙阳站附近的民宿去放东西(我背着一个电脑包来旅游实在是不太方便)</p><p><img src="/2019/10/07/20191007/IMG_20191001_130945.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_131404.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_132200.jpg" alt></p><p>走了半天终于找到了订的民宿，经过一番折腾后终于是住了进去(没人，门上是智能开锁，只需要主人告诉密码就进去了)</p><p><img src="/2019/10/07/20191007/IMG_20191001_133632.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133645.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133656.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133719.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133737.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133746.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191001_133754.jpg" alt></p><p>民宿里面的环境还不错，三个人平均下来也只要一百多一个晚上，这在寸土寸金的上海简直就不要太便宜，而且旁边就是很方便的地铁站，住的地方是真的不错</p><p>我们休息了会天就黑了，准备出去恰个晚餐，我们仨打个伞就直接出去了，结果被台风天气虐到了，鞋子全湿裤子也几乎全被打湿了，一个伞在台风面前是在是不够看，我也是第一次见识到了台风的威力了。</p><p>虽然有点不爽，但是我们只能原路返回去避雨了，我们仨居然就直接在饿了么美团上面点外卖吃了(没错，出去玩还点外卖，我其实也是有点哭笑不得)</p><p>但也是迫于无奈吧，玩了玩电脑到过了凌晨，洗了个澡我们就直接睡觉了</p><p>第一天的旅途就这么结束了呢。</p><hr><h1 id="10月2日"><a href="#10月2日" class="headerlink" title="10月2日"></a><center>10月2日</center></h1><p>第二天，起来的不是很早，因为好像是晚上一两点才睡的觉我们晚上的精神不知道为什么都挺好的</p><p>嗯所以我们十点左右的时间才从家里出发</p><p>有个人要去见他亲戚一面于是和我们分开了</p><p>嗯虽然只有两个人，我们还是去了云南路去吃饭，</p><p><img src="/2019/10/07/20191007/IMG_20191002_113036.jpg" alt></p><p>先去了这家阿叔熬奶茶去点了一杯血糯米奶茶，不过很失望，喝起来和普通奶茶店的奶茶好像没什么区别</p><p><img src="/2019/10/07/20191007/IMG_20191002_115131.jpg" alt></p><p>又去附近的八宝炸猪排去买了个猪排，猪排十一块一个，虽说分量不是很多，但是加上那个汁确实好吃</p><p><img src="/2019/10/07/20191007/IMG_20191002_120435.jpg" alt="苏州汤包"></p><p>又去云南路附近的汤包店点了两笼汤包以及一碗葱油面，点的时候还以为不够，点了才知道根本就吃不完。。。<br>那个苏州汤包是真的好鲜啊。。。不蘸醋直接一口吃简直就是大大的满足，里面的汁水很足但是也不算太大，就算过了二十多天我还是记忆犹新</p><p><img src="/2019/10/07/20191007/IMG_20191002_125158.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191002_125241.jpg" alt></p><p>从云南路准备去世博园去的，但是途中居然就碰到了中共一大的会址。。。说巧也不巧，因为可以凭借身份证免费进去参观，于是我们便排队进去参观了</p><p>虽然是国庆但是可能是前一天的台风的影响吧，第二天中午还没看到很多人，于是我们便进去参观了</p><p>嗯…犹豫里面大多数的历史我都已经很清楚了，所以我们进去看了一圈就出来了，就随便放几张图好了</p><p><img src="/2019/10/07/20191007/IMG_20191002_125814.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191002_130058.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191002_130305.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191002_131845.jpg" alt></p><p><img src="/2019/10/07/20191007/IMG_20191002_131933.jpg" alt></p><p>嗯，差不多就放这么多好了</p><p><img src="/2019/10/07/20191007/IMG_20191002_134101.jpg" alt></p><p>出了一大会址，我们便坐地铁准备去世博园了</p><p><img src="/2019/10/07/20191007/IMG_20191002_134315.jpg" alt="世博园正门"></p><p><img src="/2019/10/07/20191007/IMG_20191002_134354.jpg" alt="正门的各国的国旗"></p><p>到了世博园，进去售票处，发现只要凭借身份证就能够免费的进去参观</p><p><img src="/2019/10/07/20191007/IMG_20191002_134841.jpg" alt></p><p>于是我和他就领了票进去参观</p><p>额，由于里面其实也没什么好看的，那我也就不放图好了</p><p><img src="/2019/10/07/20191007/IMG_20191002_144001.jpg" alt></p><p>进去参观将近一个小时之后就出去了</p><p>准备去梅赛德斯奔驰馆参观了</p><p><img src="/2019/10/07/20191007/IMG_20191002_151624.jpg" alt="路过的世博中国区但没进去参观"></p><p><img src="/2019/10/07/20191007/IMG_20191002_151938.jpg" alt="梅赛德斯奔驰馆远景"></p><p>到了梅赛德斯奔驰馆，其实说实话有种不真实的感觉，因为平时在家里电脑手机上看到那么多在这里举行的比赛居然现在真真切切的在我身边，唯一有点遗憾的就是他不让游客进入比赛地点去参观了，属实有点遗憾。</p><p>梅赛德斯奔驰馆后面就是黄浦江，说实话，这里的景色是真的很棒啊，真的是很壮观的长江，里面还有好多游轮，但是在广阔的长江上就显得十分渺小</p><p><img src="/2019/10/07/20191007/IMG_20191002_152714.jpg" alt="江对面的金茂大厦和金融中心"></p><p>从梅赛德斯奔驰馆出来我们便准备去附近的世博公园去转转了<br>世博公园是真的很大，地图上黄浦江一边的一大块都是世博公园，好像不骑自行车根本就不可能逛完，江边的公园景色真的很美啊！</p><p><img src="/2019/10/07/20191007/IMG_20191002_162110.jpg" alt="江边的景色"></p><p><img src="/2019/10/07/20191007/IMG_20191002_162129.jpg" alt="江边的景色"></p><p><img src="/2019/10/07/20191007/IMG_20191002_162938.jpg" alt="江边的景色"></p><p><img src="/2019/10/07/20191007/IMG_20191002_162140.jpg" alt="江边的景色"></p><p>正在世博公园走的脚都快疼死的时候，突然另外一个同学打电话来说弄完了</p><p>我们于是便动身去前期约定好的animate店去集合了，A店在中国只有上海有一家店，虽然东西比较少但是对于我们这种宅来说去看看去打卡还是挺不错的</p><p><img src="/2019/10/07/20191007/IMG_20191002_170124.jpg" alt="路过的东方明珠"></p><hr><p>未完待续……….</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190926</title>
      <link href="/2019/09/26/20190926/"/>
      <url>/2019/09/26/20190926/</url>
      
        <content type="html"><![CDATA[<h1 id="每天只会无能狂怒的废物-gt"><a href="#每天只会无能狂怒的废物-gt" class="headerlink" title="每天只会无能狂怒的废物&gt;"></a><center>每天只会无能狂怒的废物</center>&gt;</h1><p>发泄了下自己的情绪<br>这种东西还是不要让别人看到好了</p><hr><p>U2FsdGVkX18ozjEFPW24ghqnE/MSb6IaGOwzT/PpMkTjQQ1mSSsNHlZa7R8TnCZC<br>7pm6GU9kfYJ4A+GDtKMi2RYJKlNJryanpv3fkRPjSscAeHkOlZs3ZBkMTVuFqP0b<br>2T7sVcDkseRhdG7vtVppVkk0r8uU1s1XJ/X1BgP8AGlG24WytFmRuc3QcWog8oqI<br>KrnunpU5VIhvW1ZqGddkXArbF51GI3uhbUFczWAi4sLyJ/LmqVMMdZdp8PZC2NoF<br>kNFsucbhPKqBrR5h4R8OUa9ND7X9TXPcU4OrjQUXM14LgaoEsLZO1kq19GXsf0aB<br>hHsroJQYRRcjlM1qIIoMML2P9x+v6/cSV84V/vu08a0T4s6osrnCv5lBoHhzauNj<br>TGgC8YinrXUlIm1yDXHYsyZYtG21I2K3gzWGCY817ZKAOpfIyP2XJcQPPkXJUvIY<br>TpDYiugCD/xg/+lmpHQTxDBTBKjQVECu9krDEP8ZHZxrMY/+BlYHpb3qw77L7/Eh<br>mN8OOtJ1+b6stNxjcgo+BtbIbTuHmQx7D7irsg5BtBpucBDBeRvCtKhb5G4EyOS6<br>Ra/3aHMGyFiyz25KzPYCnLVo49b2oGqA9nRpIs9rXaTkquzGlw+k18KCirFOQ8hY<br>BuTu0sZoz5jF5v5e2kHQ7+PmPsOO6Y0omkxpOQsnD1H28GPDOIAwzi/gacYpif1E<br>oLdQh9TMnnuJrkgh+0WHQ96RdbPxdBWLiuXBvoTvJ+PSZ588n1L2YfNCacAz453p<br>JjvZ+yD3CjwDg3/n4vct0tuPNYALNCaGCURafMurrT7NlFSbgbRb+BGH5zQ2m+wA<br>aCON3gOP+T5SxMX9tNCclTE6d0GbNNR2aVyJTYWz4OZqE4Ra1tWrgPy0Xdn3hKkB<br>xhh9kilMEJcdfANbbBMFeUWmC7qsAUmsb/IY91f5UYvLB3m/FNeN79DO+usGgzud<br>3jsek6E7v2VnCmqFZkJdO+JFvHFV2DSvdthQr3nGKodmnJR87Qu30AVTAmwr0rSa<br>5X5HFcJmXdfgVtbL1IhNhXcu2YL56b/2QqHbJSO4VlU7la2GSQg5ztmpT63yrHVj<br>PWPLpWI9Fb3bLVvFIgrP0OCrEVBMkXkXu/na7jJGspjibZMHQCgXN3E1aiMrCWYq<br>mj7kws4X5h2Q6IZ/4LWkjX2IevitaG6zuNQ0o6+LCuLc+5ryK/7gTd5eEBDQy59O<br>f7EeVNI0VWWPuboYU9nBSEgJWwoAJ56pryw3V2xtLa+0hTuOnwmy/uTnyfbuTdNO<br>0yoJL9BckApN+wkER+dtL/lCjOhHfeO848JR0ClMO/KSACx4UW0HBc5Dt2R8aHzp<br>/umeqE2/k0CQjvcz0wVefqaA1WCgCD+0u323EQ1nYoR7OA/j+bs48zExobSPzgp+<br>a9PG9DltvqjZ2Tf1EkNnAhwlB8mqaRYc3+Q6bakUMCgpCHfWWu/9P3tKVfeyoP1B<br>tjjvY6UfN4I0wg8nNtIlVZ5BTAc+yOimnZyc48NaxyIUI4bi+cqW3GEpX4rExdKZ<br>cfaoxsUtSXEbQ7iCHPbczjfJNrphhxRfFJyRCl0gw5cxafWu1IhX4IqJ7oQkUX/2<br>6mb8ldXslmWBpP3ThBK9jx5qym96caD1mSF/Q27E3C6yjspfFT1R/5h1cgq5ELcU<br>XUb8gSXV0qzNd8W8pua4iWdURzCjgtie1MCpcyDQTDQF8uOOutGs8eAPbgtQ/NfZ<br>ZddVxXrLvH0EoWosI2VGJifwj2IlxVcflOGQycV/Gm2DciUJjCbdFe7ra3L2bRi+<br>gwxB23Zm/zgL3k4W0kceFMnApkOdoeYvTvw/UF3KFPUNriaY3Ci1Ee+ZTzsalojE<br>19YSTU7IJkfyY6UgWKkCwEo8vpL2I9X8i7mkpXT2CtQOdFcOVVBeV1sVawdvN3pY<br>62vAfUCe6LfL4ZGBHGXXfHlo5sEZ/Un+bTjtiVNepT3uOyYG3vxlOMFoccWzzAdV<br>lid6QFB3Bl6NohD6vYZp+vO/7Tf7EKOSKwbEaIxOhsXtltki6Es+o6ElNwZCADl1<br>ZW/l4ednEVDYyzONRVILz+Eje+dbVaunILjudBYSS9BBl9MfzYnT77cFIqZ+f5Ij<br>5/FFu92wuPQTdDaA0nnVjkxW0jgo14feb1VNydI7BrVgIjTC5oygLbTgwsBzgKtp<br>h8Epxo/9rX+/ueMLa1H/MbEnzVF9pXj8uYtrPM0a1R8dfM8SLJRKsIOw8KaaeIr0<br>agshW6sZrIByEEjWPsIOxDA1u55S8h6HFHnJajYCiMh24T1eA4FoYORAsamyeODJ<br>NdI1+E22D94HExfZAGam3piFbmhCIKL1SS4dZRa7h51mweZG827opxEN1pU6hfZa<br>Nt+Mnp1KJFV43/8IHm2M4zBSSPVowbyTWRjGxWQHjfiVfoDFp4lYGXSwo4qq0wjG<br>dJx1CUFW1YAMFgMxm9AsMeFpdotMnluVMa8YL5EuJklvCjCpSEPU9ChTN7flJjdX<br>9NdwsX7ryzhf1mQ9fmD0+3obOSCwuDDVqLUY4dRb3qC7IDwWf03FawBF76ohGsAB<br>HzuDPN/wLq2N/NtaK8SchTOeuJZ7xgPeChJN4dmnJDo/Y/FI1m0fOlJ/kigRtA9m<br>ldfO3rXE36zzBICYYScl+EHl8/mw9WurJvMzB4psLrsw8uTwe1/VL3M6BChipBPa<br>TwDhwCLaXwTs7G9YWhg5ZylmeWEvqisQ4zmLvwWCIiSMXUJ3zPyLojT0gQgUJuqg<br>+R8HHpCbZR4OHx/BodqswZchNTCQQy/EF7h9PEk823e/DoroiVNs2DTy4d1JaQf+<br>cNDH9yvUc2ppjzb9ujrnwLrZZd5RZKfy/sc7E9JrKkPlQv3LrSP1E7eahocBGD6P<br>3xBvkR6YqLfU5No3K/RRb3pOvie6vM/af8lcHuXsB4r5ZJ6JpZL0GPmTbQDXm0uy<br>sATw5cqi7TS1jfWbGk8pw0uNHsBRBomm2cbu9pMgJtpV7qrZli5MZUmN8ktQe7dX<br>pfWKxqiG3E9S4tum3ooBXnjY01+GPF1LhtlOhqEi0OPD//bkmC9I+xI4ZsrIDE+g<br>5CcLAEFDxvRetPV119zt/de5Xc/NgI/47APAp83VWM3GPCB8nssGSWWmKKdYcRcR<br>YKdbsoUHvVdHLlhYlT3GTH0iuU5i7IMfxifeublbmcCguQZWZgvx+sl+RAnr8jqT<br>JwIW02NhdZRCh8VbIfjvzngaWcIFhKshe2vofBFJIDdrqCntPS5rzrDW4YwBd4DM<br>hBl6hpat+mF/NR143xlV42/ZRGYu7REFZI5LJ/Ky/4RJHbL6uH/fdOhU4CXr8T+S<br>LGsvoe7/NeUuxQqJPJY2k07EtjduqdS6O39F1LegHHqXvQAc3qsD3dQBBVMMWaBy<br>DBdKWY1cjMsjQFsGauIn1ho5jIbIFhNahrNiVwfeezrmojvW7w6tXaI/4OVphjSU<br>RXJQD76Yv07+xboGYa0+g/cwgglqovbr+77rBuWLyYdscUnCb3Vys2mhv81S60ZR<br>q1GIJUHNKX7X6rcQkfOYgJ+/9WJzYgw5rSwcIdy/EeNoRsiJr/1gBWPtchGlA8EE<br>72WQH1FjKQp2yW0qraOBYGFK18VA0HqCLUKHXKk+XKF8lKaYW6EZ0UGrE9e9p8nx<br>NoEZ/ryiFyobXJG4oH1qx+6y7enGTtcckyowIS/pIuJOOoRCC5mC1QHEiEBgDKk3<br>UwWZ0JZOmOefM+Vql/1pzMRqvqp2OvCKCldVAxBN6pUi1DXWvJ1/kgYbD9i1Fy7Z<br>3434vi/sDsA9xgX84avDyxHovaC32/0ccuxHAqeq2jWXfnpeBmIrmWi+r8EY0tHw<br>DqrR8BsS00YHSuPq9t6I5mmGRIXH8DMsLIsyhIc51zQey3q5183lup1V0fqvea4Q<br>5jPTd3DGt2yr/dGJ764u/HS1UKX6H7b2gkZYUeFl9VJbi8c/hbfZMaOAqTrPnl5c<br>kHt9AVO++klExO4QhdBjot45+39i6lJpKayK58wGJ8kWKRxY31KtfgthuKoCCT13</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-169</title>
      <link href="/2019/09/14/Leetcode-169/"/>
      <url>/2019/09/14/Leetcode-169/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1003</title>
      <link href="/2019/09/09/PAT-1003/"/>
      <url>/2019/09/09/PAT-1003/</url>
      
        <content type="html"><![CDATA[<h1 id="1003-Emergency"><a href="#1003-Emergency" class="headerlink" title="1003 Emergency"></a><center>1003 Emergency</center></h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">传送门</a><br><img src="/2019/09/09/PAT-1003/76388374_p0_master1200.jpg" alt><br><a id="more"></a></p><h2 id="英文描述"><a href="#英文描述" class="headerlink" title="英文描述:"></a>英文描述:</h2><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.</p><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><hr><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>2 4</p><hr><h2 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h2><p>给出N个城市，M条无向边。每个城市都有一定数目的救援小组，所有边的边权已知。现在给出起点C1和终点C2，求从起点C1到终点C2的最短路径条数及最短路径上的救援小组数目之和。如果有多条最短路径，则输出数目之和最大的。</p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>把样例输入来举例子吧<br>5 6 0 2<br>分别代表<br>5座城市(对应N)<br>6条道路(对应M)<br>0表示对应的起点是第0号城市(因为城市的编号是从0到N-1)<br>这里我把0到4的五个城市分别从A到E来表示比较方便<br>那么如图所示<br><img src="/2019/09/09/PAT-1003/PATA1003.png" alt><br>ABCDE五座城市,起点为A终点为C<br>红色的数字表示每座城市的救援人员人数<br>绿色的数字表示城市与城市之间的道路距离<br>所以我们要求的是在从A到C道路距离最小的情况下,沿途城市一起的救援人数越多越好</p><p>所以我们定义一个rescueWorkers和val_distance来存放最后的结果<br>并且令rescueWorkers = INT_MIN,val_distance = INT_MAX方便后面比较结果</p><p>定义一个邻接矩阵road[maxn][maxn],其中如果road[i][j]为0表示i和j之间没有道路,如果不为0则表示i和j之间有道路,且值即为图中绿色颜色的数字所代表的距离</p><p>再定义一个visit[maxn]来判断城市是够走过<br>定义一个map&lt;int,int&gt;city来存放每个城市的救援人数,其中city[i]表示第i个城市的救援人数(map也可以用一个数组来代替,因为城市是从0到N-1的所以没有影响)</p><p>所以我的思路就是用dfs从起点开始来进行搜索,直到到达终点位置然后就继续回溯,直到全部搜索完<br>于是有两种情况<br>1.搜索到C2的时候,当前的distance比之前更新过的val_distance要小<br>这个时候应该重新更新sum为1,因为这是只有一种最小的情况,并且更新val_distance<br>2.搜索到C2的时候,当前的distance和之前更新过的val_distance相等,这时表示当前找到了另一条最短路径,则此时sum++,然后再判断people和rescueWorkers的大小,如果当前的people比rescueWorkers大则重新更新rescueWorkers</p><p>几点需要注意的地方:<br>1.在输入邻接表的时候不仅要更新road[i][j],一定也要还更新road[j][i]！！！否则会造成错误<br>2.dfs的思路就是从0开始进行遍历,所以用一个for循环从头开始进行遍历,当visit[i] == 0 &amp;&amp; road[nowVisit][i]不为0的时候进一步dfs<br>3.dfs后一定要令visit[i] = 1,回溯的时候一定要令visit[i] = 0<br>4.dfs直接从最初的C1点开始搜索,dfs(C1,city[C1],0)表示从C1开始搜索,最初的人数为city[C1],距离为0开始</p><hr><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1003 Emergency</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;<span class="comment">//邻接矩阵最大的数目</span></span><br><span class="line"><span class="keyword">int</span> N,M,C1,C2,sum = <span class="number">0</span>;<span class="comment">//N表示城市数量,M表示道路的条数,C1表示当前所在城市,C2表示要去的城市</span></span><br><span class="line"><span class="keyword">int</span> rescueWorkers = INT_MIN;<span class="comment">//rescueWorkers来存放最多的救援队人数</span></span><br><span class="line"><span class="keyword">int</span> val_distance = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> road[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> visit[maxn];<span class="comment">//表示是否访问过</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;city;<span class="comment">//定义一个map来存放城市对应的救援队的数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowVisit,<span class="keyword">int</span> people,<span class="keyword">int</span> distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nowVisit == C2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(distance &lt; val_distance)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">1</span>;</span><br><span class="line">            val_distance = distance;</span><br><span class="line">            rescueWorkers = people;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(distance == val_distance)</span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            rescueWorkers = max(rescueWorkers,people);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(distance &gt; val_distance) <span class="keyword">return</span> ;<span class="comment">//如果现在的距离已经超过最短的距离直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">0</span> &amp;&amp; road[nowVisit][i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i,(people+city[i]),(distance+road[nowVisit][i]));</span><br><span class="line">            visit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        city[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; M;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        road[a][b] = c;</span><br><span class="line">        road[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(C1,city[C1],<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">" "</span>&lt;&lt;rescueWorkers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> PAT-A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1449</title>
      <link href="/2019/09/05/luoguOJ-P1449/"/>
      <url>/2019/09/05/luoguOJ-P1449/</url>
      
        <content type="html"><![CDATA[<h1 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a><center>P1449 后缀表达式</center></h1><p><a href="https://www.luogu.org/problem/P1449" target="_blank" rel="noopener">传送门</a><br><img src="/2019/09/05/luoguOJ-P1449/76442880_p0_master1200.jpg" alt></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p><p>如：3*(5–2)+7对应的后缀表达式为：3．5．2．-*7．+@。’@’为表达式的结束符号。‘.’为操作数的结束符号。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入：后缀表达式</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出：表达式的值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h2><p>3.5.2.-*7.+@</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h2><p>16</p><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>字符串长度，1000内。</p><hr><p>思路：<br>从左到右扫描后缀表达式</p><ul><li>如果是操作数就压入栈</li><li>如果是操作符就连续弹出两个操作数(且后弹出的是第一操作数,先弹出的是第一操作数)<br>然后再进行对应操作符的操作<br>最后再把新生成的操作数压入栈里面,直到后缀表达式扫描完毕<br>那么此时栈只剩下的一个数就是最终的答案</li></ul><hr><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] ==<span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num.push(val);</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt;= <span class="string">'9'</span> &amp;&amp; str[i] &gt;=<span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val *= <span class="number">10</span>;</span><br><span class="line">            val += str[i] - <span class="string">'0'</span> + <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] != <span class="string">'@'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp1,temp2,temp;</span><br><span class="line">            temp2 = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            temp1 = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp1 + temp2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp1 - temp2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp1 * temp2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'/'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp1 / temp2;</span><br><span class="line">            &#125;</span><br><span class="line">            num.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'@'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;num.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1433</title>
      <link href="/2019/09/03/luoguOJ-P1433/"/>
      <url>/2019/09/03/luoguOJ-P1433/</url>
      
        <content type="html"><![CDATA[<h1 id="P1433-吃奶酪"><a href="#P1433-吃奶酪" class="headerlink" title="P1433 吃奶酪"></a><center>P1433 吃奶酪</center></h1><p><a href="https://www.luogu.org/problem/P1433" target="_blank" rel="noopener">传送门</a><br><img src="/2019/09/03/luoguOJ-P1433/76296843_p0_master1200.jpg" alt><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在(0,0)点处。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数n (n&lt;=15)</p><p>接下来每行2个实数，表示第i块奶酪的坐标。</p><p>两点之间的距离公式=sqrt((x1-x2)<em>(x1-x2)+(y1-y2)</em>(y1-y2))</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个数，表示要跑的最少距离，保留2位小数。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p>输入 #1<br>4<br>1 1<br>1 -1<br>-1 1<br>-1 -1</p><p>输出 #1<br>7.41</p><hr><p>思路：<br>double一个sum来统计每次dfs到底的时候比较最短距离，如果s比sum要小就更新sum<br>我觉得这里面最重要的就是用visit[maxn]数组来判断是否走过因为每次用now在dfs里面表示当前第几个点<br>因为要走过所有的点，所以从哪个点开始进行dfs是无所谓的，所以默认dfs(0,0,0.0)开始没问题<br>然后double Distance[maxn][maxn]来存放点与点之间的距离<br>Distance[i][j]表示第i个点和第j个点之间的距离<br>然后再dfs(i+1,j,s+Distance[now][j])<br>这个的意思就是现在位于now点,然后再准备走向下一个点,也就是走向j对应的点<br>然后就先令visit[j] = 1表示j这个点即将要走到了<br>那么s就加上一个Distance[now][j],此时继续dfs<br>那么此时的now就等于j点,如果一直dfs,一直递归到条件不成立,那么就回溯,令visit[j] = 0<br>因为每一层dfs里面的for循环都是从1一直到n的,所以怎么无论dfs多少次都是会从1开始遍历<br>如果经过了就不考虑,如果没经过就继续dfs,直至每层dfs为止然后再更新最小的sum值<br>又因为输出的格式要求要保留两位小数,所以最后就printf(“%0.2f”,sum)得到最后的结果</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">10000.0</span>;<span class="comment">//sum来存放跑动的最少距离</span></span><br><span class="line"><span class="keyword">double</span> Distance[maxn][maxn];<span class="comment">//存放点与点之间的距离</span></span><br><span class="line"><span class="keyword">double</span> x[maxn],y[maxn];<span class="comment">//存放每个点的坐标</span></span><br><span class="line"><span class="keyword">int</span> visit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> now,<span class="keyword">double</span> s)</span><span class="comment">//i表示已经走了几个点，now表示当前第几个点，s表示距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= sum)<span class="comment">//如果发现s已经大于当前最小的sum则直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == n)<span class="comment">//全部走完的时候</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum = min(sum,s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visit[j])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[j] = <span class="number">1</span>;<span class="comment">//把即将要走过的这个点设置为走过</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,s+Distance[now][j]);</span><br><span class="line">            visit[j] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Distance[i][j] = <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.2f"</span>,sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1403</title>
      <link href="/2019/09/02/luoguOJ-P1403/"/>
      <url>/2019/09/02/luoguOJ-P1403/</url>
      
        <content type="html"><![CDATA[<h1 id="P1403-AHOI2005-约数研究"><a href="#P1403-AHOI2005-约数研究" class="headerlink" title="P1403 [AHOI2005]约数研究"></a><center>P1403 [AHOI2005]约数研究</center></h1><p><a href="https://www.luogu.org/problem/P1403" target="_blank" rel="noopener">传送门</a><br><img src="/2019/09/02/luoguOJ-P1403/76478287_p0_master1200.jpg" alt><br><a id="more"></a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><pre><code>科学家们在Samuel星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机“Samuel II”的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用“Samuel II”进行数学研究。</code></pre><p>小联最近在研究和约数有关的问题，他统计每个正数N的约数的个数，并以f(N)来表示。例如12的约数有1、2、3、4、6、12。因此f(12)=6。下表给出了一些f(N)的取值：</p><p><img src="/2019/09/02/luoguOJ-P1403/1645.png" alt><br>f(n)表示n的约数个数，现在给出n，要求求出f(1)到f(n)的总和。</p><p>输入格式:<br>输入一行，一个整数n</p><p>输出格式:<br>输出一个整数，表示总和</p><p>输入输出样例<br>输入 #1<br>3<br>输出 #1<br>5</p><p>说明/提示<br>【数据范围】</p><p>20%N&lt;=5000</p><p>100%N&lt;=1000000</p><hr><p>思路：</p><p>(数学方法)<br>f(1)到f(n)的和，即为1到n之间因子的和<br>那么1到n之间<br>1的因子总共有n/1个<br>2的因子总共有n/2个<br>3的因子总共有n/3个<br>…<br>依此类推<br>那么1到n之间因子的和即为f(i) = n / i;i从1到n的总和  </p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += n / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>(非数学方法)(用筛法)</p><p>定义一个数组num[maxn]，result = 0；<br>从1到n,<br>int i = 1,然后每隔1就累加一次num[i]++,表示从1到n每个数都拥有的1的个数,然后再从1到n,s加一次a<a href="然后i从2开始就不用再管之前的i了">i</a><br>然后i++递增,同理,i = 2,每隔2就累加一次num[i]++,然后依次类推表示从2到n里面每个数如果含有2就会++一次,然后结束循环之后,s再加一次a[i]<br>依此类推</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[<span class="number">10000001</span>],s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=n;j+=i)a[j]++;</span><br><span class="line">        s+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1118</title>
      <link href="/2019/08/31/luoguOJ-P1118/"/>
      <url>/2019/08/31/luoguOJ-P1118/</url>
      
        <content type="html"><![CDATA[<h1 id="P1118-USACO06FEB-数字三角形"><a href="#P1118-USACO06FEB-数字三角形" class="headerlink" title="P1118 [USACO06FEB]数字三角形"></a><center>P1118 [USACO06FEB]数字三角形</center></h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problem/P1118" target="_blank" rel="noopener">传送门</a></h2><p><img src="/2019/08/31/luoguOJ-P1118/73923548_p0_master1200.jpg" alt><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有这么一个游戏：</p><p>写出一个1至N的排列ai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少1，直到只剩下一个数字位置。下面是一个例子：</p><p>3,1,2,4</p><p>4,3,6</p><p>7,9</p><p>16</p><p>最后得到16这样一个数字。</p><p>现在想要倒着玩这样一个游戏，如果知道N，知道最后得到的数字的大小sum，请你求出最初序列ai，为1至N的一个排列。若答案有多种可能，则输出字典序最小的那一个。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入输出样例</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"><span class="number">4</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">说明/提示</span><br><span class="line">对于<span class="number">40</span>%的数据，n≤<span class="number">7</span>；</span><br><span class="line"></span><br><span class="line">对于<span class="number">80</span>%的数据，n≤<span class="number">10</span>；</span><br><span class="line"></span><br><span class="line">对于<span class="number">100</span>%的数据，n≤<span class="number">12</span>,sum≤<span class="number">12345</span>。</span><br></pre></td></tr></table></figure></p><hr><p>思路：<br>假设n = 5,那么a b c d e依次对应<br>a     b     c     d      e<br>  a+b   b+c   c+d     d+e<br>   a+2b+c b+2c+d  c+2d+e<br>    a+3b+3c+d b+3c+3d+e<br>        a+4b+6c+4d+e<br>此时1到5对应的权值即为<br>位数 1 2 3 4 5<br>权值 1 4 6 4 1</p><p>假设n = 8,那么a b c d e f g h依次对应<br>a       b      c       d       e        f        g       h<br> a+b      b+c      c+d      d+e      e+f       f+g     g+h<br>  a+2b+c    b+2c+d    c+2d+e    d+2e+f    e+2f+g   f+2g+h<br>   a+3b+3c+d  b+3c+3d+e  c+3d+3e+f  d+3e+3f+g  e+3f+3g+h<br>    a+4b+6c+4d+e b+4c+6d+4e+f c+4d+6e+4f+g d+4e+6f+4g+h<br>     a+5b+10c+10d+5e+f b+5c+10d+10e+5f+g c+5d+10e+10f+5g+h<br>      a+6b+15c+20d+15e+6f+g b+6c+15d+20e+15f+6g+h<br>            a+7b+21c+35d+35e+21f+7g+h</p><p>此时1到8对应的权值为<br>位数  1  2  3  4  5  6  7  8<br>权值  1  7  21 35 35 21 7  1</p><p>所以这其实就是一个杨辉三角的一个模型<br>那么构建一个杨辉三角的代码如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//最左上角的数初始化为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//由于这里数组的记录是从1开始记的，所以不用担心越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//每个数都等于它肩上两数之和</span></span><br></pre></td></tr></table></figure></p><p>或者直接套用杨辉三角的通用公式来直接解出来,和上式一样<br>C(n-1,m-1)=(n-1)!/[(m-1)!(n-m)!]<br>(其中!表示阶乘，n！=n<em>(n-1)</em>…<em>2</em>1)</p><p>那么当n为几,sum的和就是n个数乘以杨辉三角第n行分别对应系数得到的结果</p><p>然后直接从1开始进行dfs,因为是从1开始储存的,所以得到的结果肯定也是字典序最小的</p><hr><p>完整代码如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;//万能头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,p;<span class="comment">//输入必备</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>];<span class="comment">//输出必备</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">13</span>][<span class="number">13</span>];<span class="comment">//杨辉三角必备</span></span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">13</span>];<span class="comment">//判重必备</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;p)<span class="comment">//如果现在累加的数已经超过了给定的数，就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;n)<span class="comment">//如果已经搜完了n个数，就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==p)<span class="comment">//如果答案跟给定的数相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i];<span class="comment">//输出</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//如果没有输出答案，就返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==<span class="literal">false</span>)<span class="comment">//如果当前这个数没有用过</span></span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=<span class="literal">true</span>;<span class="comment">//标记成用过</span></span><br><span class="line">            a[dep]=i;<span class="comment">//保存第dep个取的数</span></span><br><span class="line">            dfs(dep+<span class="number">1</span>,s+i*c[n][dep]);</span><br><span class="line">            b[i]=<span class="literal">false</span>;<span class="comment">//注意这里要将状态回归，不然TLE</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;<span class="comment">//输入</span></span><br><span class="line">    c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//生成杨辉三角</span></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//开启深搜之旅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190823</title>
      <link href="/2019/08/23/20190823/"/>
      <url>/2019/08/23/20190823/</url>
      
        <content type="html"><![CDATA[<h1 id="想做一点有趣的事情"><a href="#想做一点有趣的事情" class="headerlink" title="想做一点有趣的事情"></a><center>想做一点有趣的事情</center></h1><p><img src="/2019/08/23/20190823/63372879_p0_master1200.jpg" alt><br>好久都没写博客了Orz，这个习惯要开始慢慢重新恢复起来了。。<br><a id="more"></a><br>嘛，最近开始接触了PR,AE之类的软件，突然感觉心血来潮，对做视频这方面感觉挺有意思的，现在越来越觉得游戏没多少意思了，虽然能够给我带来快乐，但是都只是短暂的，不可持续的，比每天刷一道题，去知乎好好写一篇回答，亦或者去好好做一个视频给自己带来的成就感确实低多了。。。</p><p>所以我现在所在的问题不是会不会用什么东西，而是要去自己深入了解其中的内涵，不然自己跟所谓的工具人又有什么区别(悲</p><p>果然不出我所料，回家带的几本书根本翻都没翻，就算看书我也是喜欢直接到电脑上去看。。。感觉自己对于电脑的感情还是不一般呢，可能自己一辈子也离开不了它了吧。。。</p><p>其实我一直都在问自己，到底喜欢什么，以后到底喜欢做什么事情，但是确实没有什么事情能够让自己一直能够很开心的去做下去，所以看那些大佬们每天能够做自己喜欢做的事情真的是羡慕的不行呢，果然跟C菌说的一样。。。兴趣就是最好的前进动力可惜我没有叻。。。</p><p>自己的惰性还是大于自己的干劲，这几天和家里的老人又聊了聊天感觉自己过的时候真的是太幸福了，像我爷爷奶奶到了我这个年纪就要去工厂干活或者去农田里面耕作，虽说现在时代是好了但是我在家也没有好好学习充实自己反而是每天浪费时间去做很多很多无意义的事情。。。每天中午睡觉也是。。经常就睡一下午，就感觉跟家里人所说的没有操心一样，心里没有一点事情就睡得安稳，就喜欢混时间，可能是不到最后一刻不到生死关头自己才会醒悟吗？可是每次都把希望寄托在明天我最后可能什么都得不到。。。</p><p>想了想19年已经8月底快9月了，这一年过的真的是太快太快了，就好像刚刚过年没多久自己立下的flag还历历在目但是现在来看根本没完成几个。。。我真的有点厌倦了。</p><p>可能是舒服的日子过得太久了吧，两年前还在奋斗高考的我的那股冲劲感觉完全都没有了，现在的我只是一个一事无成每天喜欢看手机玩电脑的废物，这也不会那也不会。。。明年就要考研了我还没开始系统的学习知识点，还有好多想做的事情没有去做。。我很难过，但是我不怪别人，这都是自己找的，但是我已经认识到了我自己的问题，新的学期大三虽然是满课，但是我觉得我每天可以过的很充实，一天一道题，一个星期写一篇回答，一个月制作一个视频，我觉得自己给自己找点事情做才会让自己每天都充实。</p><p>那么今天的日记就这样吧，以后写日记的频率会增加吧，我觉得真的挺充实的，还会更新算法相关的笔记，那么就这样吧Orz</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20190816</title>
      <link href="/2019/08/16/20190816/"/>
      <url>/2019/08/16/20190816/</url>
      
        <content type="html"><![CDATA[<h1 id="一点点疑惑"><a href="#一点点疑惑" class="headerlink" title="一点点疑惑"></a><center>一点点疑惑</center></h1><p>突然发现自己的博客居然有人在看，不禁觉得有点害羞，但是仔细想想既然分享了出去，那么肯定就是希望有人来看的，但是这种感觉就好像是自言自语被别人看到了一样(就感觉像个沙雕一样呜呜呜)<br>可能我就是这样的人吧，有的时候会太在意别人的看法，在意别人看法的后果就是做什么事情都畏手畏脚，从而好多事情都不敢去做，就比如交朋友来说，觉得别人很厉害啊什么的就不敢去交流不敢去交往，我觉得这可能也是很多人的一个通病吧，所以好好的做好自己才是更应当做到的事情(天天都在摸鱼的屑留下来不思进取的眼泪)</p><p>但是我又不禁感到一丝惭愧，作为一名还没有任何知识水平的人，既没有自己擅长的领域可以分享给别人，也没有好好分析一个问题的能力，实在是让我惶恐不安，可能这就是所谓的键盘侠吧，打字计划满满的一堆，但是真正去做什么事情都会大打折扣。<br>所以想要朋友是对的，但是莫名其妙的去强行和别人交流真的不可取，不同阶级，不同知识水平，自己都没有这个水平怎么跟别人聊得起来呢？<br>所以现在我也想开了，提升自我修养才是更应该去做的事情，只有自己的知识水平上去了，只有自己变得足够优秀，才能有和别人成为朋友的价值。<br>正如我之前所说，朋友之间是相互的，如果你不能给别人足够的帮助，那别人为什么要和你成为朋友呢，所以这其实是一个伪命题。<br>这件事我不会再写很多了，说多了其实自己也挺烦的，一个人就一个人吧，一个人其实也挺好的，至少没人来烦我Orz。</p><hr><p>乱七八糟又写了这么多，暑假也快要过完了，我觉得是时候要好好想一想一下自己未来的生活了xd</p><p>在b站上看到一个视频，学习思维和方法确实比知识重要太多了，以前觉得这个都不怎么重要，现在才知道原来自己是多么幼稚，简直就是浪费了自己当初多少的大好时光，所以说导致现在这个样子真不能怪别人，只能怪自己太短视了。</p><p>番茄工作法真的很适合我这种不自觉的人，平时干什么事情都会莫名其妙就看手机，刷知乎，上b站去了，还不如规定一段时间让自己专心致志的去做某件事情，能够让自己集中注意力，我觉得挺赞的。</p><p>我今天才发现自己平时真的是不爱思考，不喜欢思考事情，不管是好是坏都是一种无所谓的态度，可能在这个过程之中逐渐就丧失掉了自己的思考问题的能力，我觉得不能再拖下去了，是时候正视自己的缺点去改进了</p><p>所以以后会在blog更新一些我对时事的一些看法和一点意见吧。<br>哦对了，好久都没有把刷过的题目好好做个总结，这也是今后需要做的事情，当初其实是想当一个技术blog来着的(但是真的没什么技术水平)，但是我会努力的！<br>争取在合理的时间做合适的事情吧，还有十天不到的时间，就这样先试试看吧~</p><p><img src="/2019/08/16/20190816/76153784_p0_master1200.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190810</title>
      <link href="/2019/08/10/20190810/"/>
      <url>/2019/08/10/20190810/</url>
      
        <content type="html"><![CDATA[<h1 id="一点感慨"><a href="#一点感慨" class="headerlink" title="一点感慨"></a><center>一点感慨</center></h1><p>有一段时间没有更新过博客了吧，这段时间也确实发生了很多事情，这其中我也想了很多，思考了很多，我发现自己确实变了很多，长大了之后就感觉自己逐渐失去了自我？(maybe)，学会了如何去讨好他人？学会了怎么去妥协别人？反倒是自己不能够随心所欲的去干一些事情？我觉得到现在看来真的挺可笑的，有的时候自己确实想的太多思考的太多，反倒有的时候过于考虑别人从而让自己每天活在不快乐之中。<br>嗯，所以我决定了，自己以后不管是谁都不能改变自己的初心了，我就是我，我想干什么就去干什么，真的没什么好顾忌的。</p><p>因为现在已经没有什么可以失去了。<br><img src="/2019/08/10/20190810/75961124_p0_master1200.jpg" alt><br><a id="more"></a><br>嗯，接下来就说说这几天发生的事情吧，算是都跟朋友有关吧，直到今天我才有时间来好好总结。</p><p>第一件事就是我和我现实中的好朋友吧，我和他算是老相识了吧，从小学就开始认识了，到现在为止算了算认识了也有十几年了吧，但是可能是我过于高估我们两个之间的关系了吧？长大以后，我的性格越来越内向，我从一个外向开放的人逐渐走向内向自闭的一个人，尤其是在高中这个阶段，嗯，高中的氛围很不好，很不好，很不好，以至于我不再想回忆起我的高中生活，但是我必须要去面对那段事实，就是我确实感觉很孤独，在那么紧张那么激烈的一段时间里面，没有人能够一起说话没有人可以让自己表达自己的感情，有的只是同学之间相互之间的嘲讽，没错就是嘲讽。<br>你可能难以想象，怎么可能，高中同学难道不应该是相互鼓励相互尊重然后一起努力去考上一个好的大学吗？<br>很可惜，对于我来说很不巧，刚好分到了一个班级里面都不是那么友善的人，简单的来说就是他们不是想跟你一起努力，反而是通过各种手段(就比如各种嘲讽)来影响你让你考试发挥不好，影响你的心态然后就能踩在你身上获得成就感，虽然已经两年了，但是我还是忘不了这段时期，现在已经不敢想象当时自己是怎么过来的。<br>于是就在这个背景之下，我和那个人就因为认识了很多年的原因，所以就成为了表面上的好朋友吧，毕竟当时在班里我也和别人不熟，他也和我差不多，但是到今天为止我都没猜透他到底在想什么。<br>你可能会说，这不是一件好事吗，认识了那么久，在一个班里刚好能互相取暖吧，但可能我不知道我做了什么事情让他心里不爽吧(可能)，一直跟我保持距离，但是我一直都算是把他当做最好的朋友来看待的。现在想想真的是可笑，别人可能根本把我不当什么吧，都怪我自作多情，大学里面还经常打电话过去，每次出去玩都是我主动找他，他一次也没有找过我，直到前几天各种理由来推脱我，我这时候才终于明白了。</p><p>朋友之间不应该是相互的吗？为什么只有我去关心别人？朋友不应该就是能够互相依靠的吗，说句不好听的话，怎么就成了我去舔别人了呢？现在想想真的可笑，我可能是为了寻求内心那一点点依靠，把别人看的太重了，导致成了现在这幅样子，但是如今我也想开了，已经没有什么好失去的了，这种朋友不要也罢，前几天一气之下就直接把他删了，既然不想跟我做朋友，既然不想跟我见面，那我们各走各的有缘再见吧。</p><p>第二件事就是知乎上一个朋友橘猫，我也不想说你的id你也注销过好几次了，不，按您的说法我们根本就算不上朋友，我也不想回忆您我也不想再说和您的故事，好聚好散，虽然你是个渣男和好多木桶饭也都交往过，请好好想想为什么最后都会成为这样，不要把责任都推到别人身上，你自己本身就有很大的问题，我现在也看开了不是同一个世界的人就没有必要天天聊这个聊那个的，思维都不一样，希望您早点出国成为人生赢家，走入社会再干上您最讨厌的工作吧，哦不，或者成为一个哲学家(当代马克思)也说不定？</p><p>稀里糊涂说了这么多我也不想改了，反正就是记录自己最近的烦心事，以后会随着自己的本性去做事情了，不会再去顾忌这个顾忌那个</p><p>因为自己已经没有什么好失去的了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190727</title>
      <link href="/2019/07/27/20190727/"/>
      <url>/2019/07/27/20190727/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一下昨天晚上的一些心事"><a href="#记录一下昨天晚上的一些心事" class="headerlink" title="记录一下昨天晚上的一些心事"></a><center>记录一下昨天晚上的一些心事</center></h1><p>从25号回家到现在也有两天了，发现回家也并没有想象中的那么兴奋嘛，第一天家里人见到我都说我瘦了好多好多Orz，还怀疑我有没有在学校好好吃饭(其实在学校根本就没吃过早餐，因为没有好吃的早餐哼唧)，看着自己那么胖那么粗的一根腿说实话我觉得我自己胖的要爆炸了这个腿根本不可能让别人有社保的欲望啊(逃<br>但是家里人好像可能已经察觉到了什么了？诶多，下学期还是要坚持运动吧，争取能再瘦个10斤？(flag先立起来再说)</p><p>然后再就是昨天晚上发生的事情让我难受了一个晚上吧Orz<br><img src="/2019/07/27/20190727/75787791_p0_master1200.jpg" alt><br><a id="more"></a><br>嗯，昨天晚上的事情确实有点让我伤心，本来这个月初就跟原来最好的朋友说好要一起出去的，当初也答应了我要一起出去，结果昨天发消息却是不情不愿，也不想跟我说话<br>我是真的真的特别伤心，因为本来原来高中的时候跟同学处的就不是很好，到现在也没几个能联系的人，唯一一个在我眼里看来算是最好的朋友的人可能不把我放在心上吧。每次放假都是我主动给他打电话，每次什么活动都是我主动去拉别人，现在想想真的是有点自作多情了，说实话我对他可能是有感情的吧，毕竟同学了十几年了，从小学一直到高中，可是别人却把我不当回事，我是真的真的很心痛，可能本来就不是一路人吧，我现在也想开了<br>今天中午又跟另外一个朋友聊了半天，说句笑话，我真的算是条舔狗吧？把别人当回事，还义无反顾的去舔，我现在真的无所谓了，以后爱见不见，有缘再见吧真的是，你不情愿我也无所谓，厚着个脸皮天天叫你真的没意思ok？<br>但是伤心是真的伤心，现实里面真的就没有那种真正意义上能够关心我的朋友了吗，为什么会这样子呢…我也不知道为什么从小长到大性格越来越内向，越来越不喜欢跟别人交流但是却又想和更多的人交流沟通。。。</p><p>真的是很矛盾呢。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190724</title>
      <link href="/2019/07/24/20190724/"/>
      <url>/2019/07/24/20190724/</url>
      
        <content type="html"><![CDATA[<h1 id="回家前的一点感悟"><a href="#回家前的一点感悟" class="headerlink" title="回家前的一点感悟"></a><center>回家前的一点感悟</center></h1><p>终于，摸了这么多天我还是选择回家好了(其实是因为没钱的缘故了xd)，又要一个人踏上回家的旅程了，回家一次就是相差大半年，仔细算算还有几个大半年能够这样呢(就是没多少假期意思desu)，想想没几年就是个社畜了(悲，还没有可爱的大姐姐来找我呜呜呜，这辈子算是难了<br>噗，不说多的了，希望今天能有一个好梦吧！<br><img src="/2019/07/24/20190724/75766101_p0_master1200.jpg" alt></p><a id="more"></a><p>时间真的是过得非常非常快，从2号考完到现在已经整整过了22天了，也就是将近一个月了，暑假已经走到了一半了，说来惭愧，这二十多天真的是没有做什么事情，其实留校和在家真的没有什么区别，反而每天要自己花时间来安排自己的吃喝，反而效率更低了(笑)</p><p>真的是不知道为什么，当初那种努力的感觉就是找不回来了，学习完再快乐本来应该是一件很棒的事情，但是在电脑上就是抑制不住自己，但是仔细想想我现在本来是一个很自觉的人啊，为什么会这样子呢。</p><p>想了想，可能还是没吃过苦头吧，也就是所谓的在危机没有真正到达眼前之前，人总会给自己找各种各样的借口来为自己的懈怠推脱，所以现在格外的意识到了人性，”说到底还不就是一条懒狗”，完美总结了这22天的宿舍生活。</p><p>于是我决定明天就回家好了，宿舍还有个室友经常打扰我，在家里应该不会有人打扰我了，而且也不用操心自己的吃喝，挺好的，这次回家我准备就带两本书回去，还有两本关于经济学方面的书准备看完，现在我的知识水平还是太欠缺了，根本不能到知乎上去做像模像样的回答(同时也没有勇气和大佬们交流)<br>所以虽然玩了知乎有几年了，但是认识的朋友却并不多(悲)，希望能好好改善一下当前的处境呢。</p><p>这个暑假最大的收获可能就是认识了一位志同道合的朋友吧(或者说是未来的研友也不为过)，虽然他就住在我楼下但是感觉认识更多的人自己的信息面会广很多啊，这个朋友为我提供了很多资料，我挺感谢他的，毕竟都是失败专业的人嘛，互相帮助互相交流我觉得挺好的，早点认识到自己的失败所在，及时的改正我觉得才是一个正常人应有的判断和抉择。</p><p>暑假还打算出去旅游来着，但是好像约的人好多都有事，如果能顺利出行的话会继续到博客上更新的hhh说不定还会拍vlog？(从而成为一名up主？)，说实话我一直都很想做点视频去做一名up主，看到老番茄激励的视频就感觉很兴奋，但是兴奋了一会之后往往又会平静下来，可能这就是我吧。</p><p>总之我想摆脱当前这样的生活，一天到晚打游戏的生活虽然快乐但是却并不能给我带来收获，在并不知道自己真正喜欢什么的时候只有努力学更多的知识才能让自己处于不败之地吧(可能)</p><p>其实说实话什么时候能真正摆脱人的惰性，我觉得干什么事都能够成功的，摸鱼一时爽，一直摸鱼一直爽，可是时间不等人喔，今年我已经20岁了，已经不再是一个小孩子了，是时候该为自己的未来做打算了，毕竟，不仅是为了自己，也是为了那份执着的信念罢。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1168</title>
      <link href="/2019/07/10/luoguOJ-P1168/"/>
      <url>/2019/07/10/luoguOJ-P1168/</url>
      
        <content type="html"><![CDATA[<h1 id="P1168-中位数"><a href="#P1168-中位数" class="headerlink" title="P1168 中位数"></a><center>P1168 中位数</center></h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/P1168" target="_blank" rel="noopener">传送门</a></h2><p><img src="/2019/07/10/luoguOJ-P1168/73731504_p0_master1200.jpg" alt></p><a id="more"></a><p><img src="/2019/07/10/luoguOJ-P1168/20190710194408.png" alt="题目描述"></p><hr><ul><li>这题主要的思路</li><li>1.因为这题的数据很大,常规思路就是我每隔两个就sort一下,然后再找出中位数</li><li>显然这样做重复的次数会很多,一定会TLE,所以需要转换思路<br>*</li><li>2.所以应该从输入的时候一开始就进行插入操作,输入1个插入1个,然后以插入的方式直接有序的插入进去</li><li>然后插入3个之后则第2个即是前三个的中位数,然后依次类推。<br>*</li><li>3.然后考虑插入操作应该怎么插入,很容易就能想到用二分查找的方式查找到X附近的位置然后进行插入</li><li>因为是进行的插入操作所以应该用upper_bound()(或者lower_bound())进行二分查找,然后再进行插入<br>*</li><li>自己遇到的坑: 我以为要输入完之后再全部进行输出,但是其实可以一边输入一边进行插入操作</li><li>从而降低了时间复杂度。</li></ul><hr><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1168 中位数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//N表示整个序列的长度</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;<span class="comment">//定义一个数来存放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= N;i++)<span class="comment">//直接用一个变量x就可以代替数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="comment">//val.insert(val.begin()+(upper_bound(val.begin(),val.end(),x)- val.begin()),x);</span></span><br><span class="line">        val.insert(lower_bound(val.begin(),val.end(),x),x);<span class="comment">//上式等价的写法,val.begin()被抵消了</span></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;val[(i<span class="number">-1</span>)/<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//因为存入vector中下标是从0开始的,所以要用i-1,(i-1)/2即是排序好的奇数个数中的中位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1325</title>
      <link href="/2019/07/09/luoguOJ-P1325/"/>
      <url>/2019/07/09/luoguOJ-P1325/</url>
      
        <content type="html"><![CDATA[<h1 id="P1325-雷达安装"><a href="#P1325-雷达安装" class="headerlink" title="P1325 雷达安装"></a><center>P1325 雷达安装</center></h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/P1325" target="_blank" rel="noopener">传送门</a></h2><p><img src="/2019/07/09/luoguOJ-P1325/12d69028.jpg" alt="喵呜"></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">描述：</span><br><span class="line"></span><br><span class="line">假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围d。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。</span><br><span class="line"></span><br><span class="line">数据使用笛卡尔坐标系，定义海岸线为<span class="keyword">x</span>轴。在<span class="keyword">x</span>轴上方为海洋，下方为陆地。</span><br><span class="line"></span><br><span class="line">样例<span class="number">1</span>如图所示</span><br></pre></td></tr></table></figure><p>！<a href="luoguOJ-P1325/175.png">样例</a><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入输出格式</span><br><span class="line">输入格式：</span><br><span class="line">第一行包括<span class="number">2</span>个整数<span class="built_in">n</span>和d，<span class="built_in">n</span>是岛屿数目，d是雷达扫描范围。</span><br><span class="line"></span><br><span class="line">接下来<span class="built_in">n</span>行为岛屿坐标。</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">一个整数表示最少需要的雷达数目，若不可能覆盖所有岛屿，输出“-<span class="number">1</span>”。</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入输出样例</span><br><span class="line">输入样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">-3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p>这题我的思路过程</p><ul><li>这题遇到的坑</li><li>1.雷达的范围,以及坐标值最好都要用double来确定精度,否则int和double混用来进行计算的时候往往会出现问题<br>*</li><li>2.这题的思路刚开始有问题,刚开始我是把所有岛屿的横坐标作参照进行排序,但其实这样会漏掉很多种情况,虽然也是基于贪心的思想,</li><li>但是这样子会把横坐标小但是纵坐标很高的情况排到左边,于是就会产生误差<br>*</li><li>正确的思路应该是:因为已经知道每个岛屿的坐标和雷达的范围,所以以每个岛屿为圆心以雷达的半径作圆交于X轴都能够得到两个坐标</li><li>此时这两个坐标即是雷达所在位置的两个极值,此时按一般的思路从左往右从小到大进行排序,</li><li>把所有确定雷达的右坐标从小到大进行排序,首先确定第一个雷达的位置为确定第一个岛屿的右坐标,num++,</li><li>然后以这个右坐标为基准,因为贪心的思想,我在两个极值(a,b)之间虽然我放在a或者ab之间的某点都能够覆盖这个岛屿,</li><li>但是我如果把这个雷达放在最右边的b点的时候能够覆盖更多的岛屿,所以我放在最右边的b点,</li><li>判断这个b点是否大于第二个点最左边的a点,如果可以的话说明这个雷达能够覆盖第二个点,说明就不需要再新加雷达了</li><li>然后依次类推,如果这第一个的b点小于某一个点最左边的a点,说明覆盖不到,所以需要新加雷达站,num++</li><li>所以再以这个点的b点为基准来进行判断,然后依次类推,就可以算出雷达站最少的数目了。‘<br>*</li><li>3.第三个坑就是雷达站怎么也覆盖不到的情况,即岛屿的纵坐标y恒大于雷达的范围d,那么不管怎么样</li><li>都覆盖不到该岛屿,即返回-1</li></ul><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1325 雷达安装</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//存放雷达数</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//N表示岛屿的数目</span></span><br><span class="line"><span class="keyword">double</span> d;<span class="comment">//d表示雷达的范围</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> x,y;<span class="comment">//x,y分别代表岛屿的横坐标和纵坐标</span></span><br><span class="line">&#125;;</span><br><span class="line">Node radar[maxn];<span class="comment">//定义一个结构体数组来存放岛屿的横纵坐标</span></span><br><span class="line">Node coordinate[maxn];<span class="comment">//定义一个结构体数组来存放确定半径之后每个岛屿左右雷达的坐标值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span><span class="comment">//待会sort的时候以每个岛屿确定的最右边的雷达坐标来从小到大进行排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rightradar</span><span class="params">(Node a)</span><span class="comment">//已经确定最右边的岛屿,算最右边雷达的X坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x + <span class="built_in">pow</span>((d*d-a.y*a.y),<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">leftradar</span><span class="params">(Node a)</span><span class="comment">//已经确定最右边的岛屿,算最左边雷达的X坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x - <span class="built_in">pow</span>((d*d-a.y*a.y),<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">val</span><span class="params">(Node x)</span><span class="comment">//判断岛屿是否超出了雷达站的范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.y &gt; d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入数据</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;radar[i].x&gt;&gt;radar[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!val(radar[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)<span class="comment">//计算每个岛屿的左右雷达坐标的极值,并存放到结构体数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        coordinate[i].x = leftradar(radar[i]);</span><br><span class="line">        coordinate[i].y = rightradar(radar[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(coordinate,coordinate+N,cmp);<span class="comment">//以每个雷达站的右坐标为标准从左往右进行排序</span></span><br><span class="line">    <span class="keyword">double</span> temp = coordinate[<span class="number">0</span>].y;<span class="comment">//先计算第一个雷达站</span></span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)<span class="comment">//然后根据第一个雷达站的坐标为基础来进行进一步的计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= coordinate[i].x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = coordinate[i].y;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num;<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1182</title>
      <link href="/2019/07/09/luoguOJ-P1182/"/>
      <url>/2019/07/09/luoguOJ-P1182/</url>
      
        <content type="html"><![CDATA[<h1 id="P1182-数列分段Section-II"><a href="#P1182-数列分段Section-II" class="headerlink" title="P1182 数列分段Section II"></a><center>P1182 数列分段<code>Section II</code></center></h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/P1182" target="_blank" rel="noopener">传送门</a></h2><p><img src="/2019/07/09/luoguOJ-P1182/75049717_p0_master1200.jpg" alt="诶嘿嘿"></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">对于给定的一个长度为N的正整数数列A-i，现要将其分成M(M≤N)段，并要求每段连续，且每段和的最大值最小。</span><br><span class="line"></span><br><span class="line">关于最大值最小：</span><br><span class="line"></span><br><span class="line">例如一数列<span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span>要分成<span class="number">33</span>段</span><br><span class="line"></span><br><span class="line">将其如下分段：</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span> <span class="number">2</span>][<span class="number">4</span> <span class="number">5</span>][<span class="number">1</span>]</span><br><span class="line">第一段和为<span class="number">6</span>，第<span class="number">2</span>段和为<span class="number">9</span>，第<span class="number">3</span>段和为<span class="number">1</span>，和最大值为<span class="number">9</span>。</span><br><span class="line"></span><br><span class="line">将其如下分段：</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>][<span class="number">2</span> <span class="number">4</span>][<span class="number">5</span> <span class="number">1</span>]</span><br><span class="line">第一段和为<span class="number">4</span>，第<span class="number">2</span>段和为<span class="number">6</span>，第<span class="number">3</span>段和为<span class="number">6</span>，和最大值为<span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">并且无论如何分段，最大值不会小于<span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">所以可以得到要将数列<span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span>要分成<span class="number">3</span>段，每段和的最大值最小为<span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">输入输出格式</span><br><span class="line">输入格式：</span><br><span class="line">第<span class="number">1</span>行包含两个正整数N,M。</span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>行包含N个空格隔开的非负整数Ai,含义如题目所述。</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">一个正整数,即每段和最大值最小为多少。</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">输入输出样例</span><br><span class="line">输入样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">输出样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>这题我的思路:</p><ul><li>这题遇到的坑</li><li>1.cmp初始化应为1,或者最后应加1,因为M表示的是分成多少段,而我却搞成了有多少个分隔,导致运行错误<br>*</li><li>2.temp初始化为0,之后若temp + num[i] &gt; x,直接令temp = num[i]再进行下一轮循环,而不是令temp = num[i+1]</li><li>比如 4 2 4 5 1,如果temp = 4,x = 4,4 + 2 &gt; 4,则此时应有一个分隔即4 | 2 4 5 1,此时再令temp = 2开始寻找下一个分隔,而不是令temp = 4(2之后的4)再进行寻找<br>*</li><li>3.如果当cmp &gt; M之后就可以结束循环判断为false,不必令cmp正好 == M,因为如果cmp &lt; M,</li><li>也满足条件的话那么只需在已经分好的中间再多加几个分隔符就行了,所以只需判断错误的情况 </li></ul><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1182 数列分段`Section II`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> N,M;<span class="comment">//N表示有多少个正整数,M表示要分多少段</span></span><br><span class="line"><span class="keyword">long</span> num[maxn];<span class="comment">//存放数字的数组</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;<span class="comment">//求和以便进行二分查找</span></span><br><span class="line"><span class="keyword">long</span> result;<span class="comment">//最后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> cmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp + num[i] &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = num[i];</span><br><span class="line">            cmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt; M) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">long</span> l = LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">        sum += num[i];</span><br><span class="line">        l = min(l,num[i]);<span class="comment">//选取num[i]的最小值作为边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> r = sum;<span class="comment">//选取所有和来作为右边界</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)<span class="comment">//当l == r时才终结循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(judge(mid))<span class="comment">//判断mid是否符合条件,如果符合就继续往左缩小边界</span></span><br><span class="line">        &#123;</span><br><span class="line">           r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190706</title>
      <link href="/2019/07/06/20190706/"/>
      <url>/2019/07/06/20190706/</url>
      
        <content type="html"><![CDATA[<h1 id="迟迟到来的总结以及这个暑假的展望"><a href="#迟迟到来的总结以及这个暑假的展望" class="headerlink" title="迟迟到来的总结以及这个暑假的展望"></a><center>迟迟到来的总结以及这个暑假的展望</center></h1><p>嗯，没错，正式放假了四天之后我才记起来要写这个学期的总结和下个学期的展望了<br>先说点题外话吧，自从这个学期搭建了博客以来我感觉还是挺不错的，能够在小地方记录记录自己的生活，写写近些天自己的烦心事，同时记录自己刷过的题目，我觉得挺好的！虽然近一个月都没怎么写了，但是我觉得我还是应该坚持下去，因为经常写博客真的很快乐，虽然确实好多都是些流水账或者重复的内容，但是能够记录自己的生活让我感觉每天生活都是有意义的，不管是学习还是做其他的事情，这样做的正反馈确实挺多的，所以，还需要坚持才行呢，以后我也需要看更多的书来提升自己的知识水平了~而不是天天打游戏~，嗯那就先写这么多好了<br><a id="more"></a><br>总的来说这个学期没有做什么事情，可以说是完全浪费了一个学期，因为这个学期本来很宽松的时间并没有被我好好利用，我觉得这是一个很大的教训吧，有的时候过于轻松的环境反而会让人懈怠啊，可能这是老生常谈的话题了但是我还是不得不时刻提醒自己应该去注意这方面的东西，因为人是健忘的，有的时候不到最后一刻可能就没有行动的动力，嗯就像我基友这学期一样吧，上课和考试周都很轻松，这学期反倒挂了两门专业课，我觉得挺不可思议的，虽然确实，这专业课确实傻逼，但是就算不喜欢这门课想及格还是挺容易的</p><p>反正失去的时间已经挽回不了，所以我要做的就是怎么把未来的时间去规划好，嗯从放假开始也浪了五天了，是时候该收心来开始计划下这个暑假的学习了</p><p>这个暑假我打算主要的目标还是把数据结构学好，下周开始为期一个星期的集训就是很好的机会了，早晨讲课下午训练，感觉这是自己的一个很好的机会去见识下真正竞赛的水平是什么样的。<br>训练结束完之后，还有半个月的时间<br>1.重新复习高数，每天坚持刷五道题，重新开始学习概率论相关内容<br>2.数据结构继续学习，每天坚持完成一道算法题(最好是洛谷上照着训练来一步一步刷题)<br>3.开始学习计算机组成原理的相关知识(到时候买课本回来进行系统的学习和整理笔记)<br>4.C++继续学习面向对象的部分，从八月份开始给自己找一个小项目去写<br>5.观看相关网课，找到合适的网课进行学习(mooc Coursera上找到相关资料)<br>6.每天的学习时间：<br>  早晨：8:00 – 11:30</p><p>  下午：14:15 – 17:15</p><p>  晚上：18：00 – 20:00(做每日一题)<br>  20:30之后为娱乐时间，坚持劳逸结合的方法，在学习的时候提升自己的学习效率，不分心多思考，多动手打代码，多和朋友交流，争取自己过一个充实的暑假！嗯，毕竟之前也浪费了那么多的时间了。</p><p>  最后就是时间的安排了，计划大概八月初去旅游然后回家待一个星期左右的时间然后再回到学校进行半个月的学习，除去集训的时间外，大概有一个月的时间来给自己提升，这次切不可再浪费来之不易的暑假了，我也不给自己安排过多的任务，这个暑假如果能按照这个计划切实落实好的话我觉得我下个学期会很有底气地去做事情了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190616</title>
      <link href="/2019/06/16/20190616/"/>
      <url>/2019/06/16/20190616/</url>
      
        <content type="html"><![CDATA[<h1 id="迟到好久来的日记"><a href="#迟到好久来的日记" class="headerlink" title="迟到好久来的日记"></a><center>迟到好久来的日记</center></h1><p>摸了好久啊，可能有半个月了？从放松的时光一跃进入考试周，简直就像是在做梦一样，因为根本就没反应过来<br>因为在我的印象里面这学期实在是过的太快了，从2月份开学一直到现在6月份三个多月的时间就这么被我过去了，感觉毫无意义，因为我发现我自己学习缺乏一个系统的过程，每天去leetcode或者洛谷刷题反而让自己没有多大的提高<br>其实仔细想想也不会很奇怪，缺乏系统有效的体系单纯去刷题的提高是很有限的，所以我觉得暑假应该调整好自己的方向<br>刚才又在看陈平教授的眉山论剑，觉得说的真的是太对了<br>第一就是要关心天下大事，关心社会问题在这个时代要有自己的思考<br>第二就是对于未来自己的专业，不是赶着时髦去选专业，而是选适合自己或者自己喜欢做的事情才是最正确的<br>第三就是个人的进步，说来惭愧，我不止一两次在我日记里面写到了，本来大学刚开始就准备要好好学计算机，结果到现在两年了实在是说不上有多少进步，虽然说确实有很多客观的原因影响自己的学习但是人总不能给自己找借口吧，人就是这样子，不喜欢努力，想着天天躺在床上去就能够进步就能够成为大佬，怎么可能呢哈哈哈哈，看着知乎上那些初高中的小弟弟小妹妹们都比自己实力强，不禁心里想问自己心里难道就不会有压迫感吗，我仔细想了想可能也是因为自己周围的环境所造成的，宿舍的人确实过的太舒服了我感觉自己被他们所同化了，其次就是我自己所说的那句话，自己没有经历过的事情，是不会体会到那种感觉的，就是虽然看到知乎上面有那么多的天坑专业的硕士，博士有那么惨痛的经历，可是自己没有亲身体验过，所以没有那种危机感，但是确实，好的话就要听进去，方向比努力更重要，所以我在这里决定，暑假不能够再浪费了，正好在学校也认识了一个志同道合的朋友，虽然之前学校也认识一个沙雕网友还是我把它劝退了，但是在我看来他并没有那么坚定的决心去劝退去脱坑，对于天坑专业还有种幻想，还觉得自己有很多条后路，所以我不太想跟他一起，所以暑假和新朋友去一起参加培训，一起讨论题目甚至还可以一起去考pat，一起明年去考蓝桥杯，我觉得这是很好的事情，自己也确实需要去主动认识一些人了，毕竟你不主动谁来认识你，谁来和你交朋友呢，因为专业的缘故也没参加大学的社团感觉挺遗憾的，所以自己要亲手去弥补这个遗憾才行呢，在网上认识更多的大佬，同时自己也需要更加努力去提升自己的实力才能够配的上跟别人交朋友的资格呢</p><p>其次就是这次618自己也买了几本书，我发现自己对经济，近代史方面确实还挺感兴趣的，所以之后为了提升自己的人文素养也要去看这方面相关的知识，到知乎上面多浏览，和知乎上的大佬们多讨论，要形成自己的看法，形成自己的观点，到b站上面多看看陈平教授这样的视频去提升自己的素养，而不是整天去打游戏，最后一学期下来甚至整个大学下来都没有什么收获，嗯但也不是说不去打游戏，偶尔打打游戏还是可以的，但是要掌握一个度才行，每天要完成任务比如完成一道算法题，刷了leetcode或者学了一个算法才能够自己打游戏，否则就不行，所以在7月2号考完之后所以应该进入考研的模式了，同时每天也要坚持对英语和数学的学习才行，嗯虽然自己的技能栏还是空空如也，但是我相信只要有信念什么时候都不算晚。</p><p>说到底道理谁不知道呢，关键就是大学里面实在是没有自己喜欢做的事情，只有赶着这个时代的潮流了，想起看过吴军博士写过的《浪潮之巅》，确实心潮澎湃，生活在这个变革的时代，不去顺应潮流去做点什么事情，难道不会感到遗憾么，所以坚定自己的决心去当一名geek不也是挺酷的事吗，但其实对自己来说，可能不逼一逼自己就根本就没有危机感和压力感，所以暑假和朋友要好好讨论讨论自己未来的道路了。</p><p>嗯，下个星期就是复习周了所以当前的主要目标就是要应付完这个学期才行，起码及格才行吧，但是能考高一点就高一点，就算自己以后不从事化学这方面的事情，绩点高一点对自己也是无害的。所以加油吧，最后的半个月的时间，需要自己去好好的专注到专业课的方面了，在最后这几天好好努力一把吧，在自习室要提升自己学习的效率了，等考完了再来写日记好好规划下自己吧！</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-033</title>
      <link href="/2019/06/09/Leetcode-033/"/>
      <url>/2019/06/09/Leetcode-033/</url>
      
        <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">传送门</a><br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line"></span><br><span class="line">( 例如，数组 <span class="string">[0,1,2,4,5,6,7]</span> 可能变为 <span class="string">[4,5,6,7,0,1,2]</span> )。</span><br><span class="line"></span><br><span class="line">搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -<span class="number">1</span> 。</span><br><span class="line"></span><br><span class="line">你可以假设数组中不存在重复的元素。</span><br><span class="line"></span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/09/Leetcode-033/73723541_p0_master1200.jpg" alt="不开心"></p><hr><a id="more"></a><p>思路:<br>数组在某个点进行了旋转，那么原来的数组就不是有序的了，所以我们需要遍历数组来找到那个分界点<br>那么问题来了，怎么才能找到那个分界点呢？</p><p>因为题目要求算法的时间复杂度为 O(log n) 级别,所以我们就不能遍历数组来找到那个分界点</p><p>而是应该用二分查找的方式来找到那个分界点才能满足时间复杂度的要求</p><p>那么怎么用二分查找来获取那个分界点呢？</p><p>答案就是比较low,mid,high三个点的值的大小比较,如果mid &gt; low,说明low到mid之间是有序的<br>所以令low = mid + 1,否则low到mid之间是无序的，令high = mid</p><p>最终知道low == high的时候就找到了分界点，然后再比较分界点之间与target的大小<br>然后再分别到两个区间进行二分查找，可以满足要求</p><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(left);</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">split_t</span> = left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="keyword">split_t</span>] &lt;= target &amp;&amp; target &lt;= nums[right]) left = <span class="keyword">split_t</span>;</span><br><span class="line">        <span class="keyword">else</span> right = <span class="keyword">split_t</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190528</title>
      <link href="/2019/05/28/20190528/"/>
      <url>/2019/05/28/20190528/</url>
      
        <content type="html"><![CDATA[<h1 id="两周年回顾"><a href="#两周年回顾" class="headerlink" title="两周年回顾"></a><center>两周年回顾</center></h1><p>嗯这个打算这个星期写完吧，好好总结和反思一下自己，希望未来能够以此引以为戒。</p><p>今天还是开了两周年的班会，不知不觉已经两年了，我也从一个新生成为了一个老<del>学长</del>油条了呢<br>青春，就是在不知不觉中慢慢流逝的呢<br>今天的班会上说了些莫名其妙的话，其实根本都不是我内心里面的真实想法，嘛，毕竟这种东西只能对亲密的人说呢</p><p>好吧，那现在我好好总结下我这两年的生活吧<br><img src="/2019/05/28/20190528/74842026_p0_master1200.jpg" alt><br><a id="more"></a><br>17年高考完毕之后，填志愿，那时自己也是真的挺傻的，填志愿都不知道去找几个对应专业的学长学姐问问具体的情况，自己在知乎上就随便搜了几个热门的专业<br>确实是想去学计算机和电气相关的专业，可以填六个志愿，最后一个不知道填什么就随便填了化学，于是乎，命运就这样跟我开了个巨大的玩笑，让我的生活发生了巨大的转折</p><p>没错呢，分数不够计算机和电气的专业，于是进了化学系，当时的我确实已经产生了后悔的感觉了，但是这种感觉并不强烈，嗯因为自己没有那种强烈的危机感，自己根本就不知道未来的人生计划到底怎么样，于是像个傻子一样没有目的一样的生活，但是自己给自己定的目标就是要远离化学的坑，说来惭愧，过了两年了自己的编程水平并没有什么明显的提升，但是我并不后悔<del>因为后悔也没用了</del></p><p>大一两个学期都是满满的课，每天上课指纹签到，每天晚上都有晚自习，怎么说呢那段时间还是挺让人怀念的吧，如果对于一个好好学习的学生的话确实挺充实的，有我喜欢的微积分的课和vb的课可以上，别的科目虽然不怎么喜欢但是当时自己没有什么别的想法，还是挺充实的吧，说实话那段时间确实还在经常抱怨什么的，因为确实很累，但是回过头来现在这样懒散的生活反而导致自己没有了原来的动力了。<br>仔细回想了下大一真的没有做什么事情，最大的遗憾可能就是错过了计算机协会吧，其实我内心是想进入一个社团去体验一下大学生活的，但是很可惜，当时自己没什么技能也没什么实力所以也没有进入。(其实内心是炒鸡后悔的，错过了认识一大群可爱的人的机会)<br>第二个遗憾的事情可能就是没有好好努力学习知识了吧，把自己的绩点搞上去达到专业的前15%就可以申请转专业了，因为当时自己也不知道转专业的条件和限制，等到了大二去问导员才知道只能大一上学期才能转专业，然而到了大二下学期才知道学校又稍微放宽了大一的转专业的限制，不需要成绩达到前15%就可以申请(所以又错过了一次又一次的机会)</p><p>不知道为什么呢，人生就是这样的戏剧性，一次又一次的错过，一直有一件事想搞明白，造成这样的原因到底是因为运气呢还是命中注定呢，不管是大学，高中，甚至是初中，可以改变我命运或者说是人生道路的明明有好几个，但是都被我完美的错过或者说没抓住机会，我真应该好好反思下自己为什么会一而再再而三的犯同样的错误了。</p><p>第三个可能做得唯一一件有意义的事情就是去考了计算机二级的证书吧，说来也搞笑，当初自己大一上就报了计算机二级考试，还报了两门，一门C语言和一门office，结果自己复习了好多天，考office还遇到的是原题，结果最后考出来两门都没有过，当时真的是，自己去查成绩真的是想死的心都有了，因为还是自己叫另外一个同学去报考的，他也报了两门，结果别人两门都过了，自己两门都没有过，这种巨大的落差真的是让自己感觉好难受，是的，人生本来就是一直在和别人进行比较的时光，我本来心态也一直不好，当时真的是想去跳楼之类的，但是现在想起来这算什么呢，人生的挫折多了去了，可能就是因为要经历过很多很多事情才能锻炼出自己强大的内心吧。<br>嗯，然后下半年又去报了一门C语言，还是自己一个人去的，万幸，这次终于过了，虽然没能拿到优秀，但是良好也挺不错了，总之这次过了之后自己的内心才能有所释怀，毕竟是大学的第一个证书啊，然后我自己下定决心，趁着大学剩下的时间要把能考的证书全部考了(flag无疑)</p><p>第四个不好的事情可能就是大一下的无机化学了吧，这个给我的印象挺深的，无机的一次期中考试，考完之后我在全班是倒数第二，这个成绩真的是震惊到我了，可以说是第一次不完全意义上的挂科了吧，然而让我想到我室友的挂科的惨状，下个学期莫名其妙多了一门课要去学，还有补考，那真的是炒鸡痛苦啊，然后我下定决定好好学，万幸最后居然过了，这次给我的警告让我知道了大学决不能挂科啊，不然带来的后果简直就是太痛苦了。</p><p>emmmmm好像没了呢，大一好像就这些给自己深刻印象的事情了。</p><p>大一的暑假，可真的是太混了，在暑假打了两个月的游戏，说好要学习也没怎么学(间接导致了我现在的现状)想出去旅游也找不到人可以一起出去玩，那时候真的是孤独和寂寞啊，现实中也找不到人可以一起玩，网上也没多少人可以说话，我也不知道当时我是怎么过来的。</p><p>然后就进入了大二吧，大二刚进来的时候就进行了所谓的实训，快乐了半个月吧，去博物馆参观和去化工厂参观，说实话其实就是一个走流程的东西，根本就学不到什么东西，去参观化工厂给自己的感受就是又苦又累的生活，我自己下定决心以后要远离这种生活呢。<br>然后大二的课也是好多好多除了好多实验就是好多无意义的课了，当然还有我最讨厌的大物了<br>说起来我也不知道为什么按理来说数学好的人物理不会差到哪里去，但是我偏偏是相反的那一个了，数学还行吧，但是物理真的是巨差无比，哈哈哈我好像不喜欢那种抽象出数学模型的东西。<br>可能我做的最明智的一个决定就是去参加数学竞赛了吧，说巧不巧，其实我之前也不知道这个消息的，还是我一个朋友告诉了我想跟我一起参加比赛之后才有这个想法要去参加一下比赛，嗯买了一本那个黄书去学，每天晚上去学那个知识，真的是炒鸡痛苦，因为我真的是很不喜欢证明题，然后就准备了几个星期去参加初赛，说实话我到现在都不知道是怎么跟我算的成绩，我明明感觉我初赛考的稀烂。。。。然后就告诉我过了，然后要我去参加复赛<br>不过那次经历真的让我超喜欢啊，出去代表打比赛什么的，真的是好有成就感，什么东西都能找学校去报销，和一个同学在酒店住了一晚上hhh那天晚上真的是好美妙啊，好像晚上八点就复习不下去了，从第一天晚上的八点睡到第二天的七点，足足睡了十二个小时，这可能是我这辈子睡的最久的一次了，然而第二天复赛的题目真的好难啊，我好多题都看不懂，最后还是草草的虽然写了然后就交卷了，然后再和别人一起回学校。<br>嗯最后出结果我居然还是考了个省一，真的是在我的意料之外啊，虽然不那么完美，但是对于误打误撞就获奖的我还算挺幸福的了，从此我也知道要好好学习只有自己的实力不断的提升才能自信的去面对任何困难(还有一个惊喜就是前几天突然告诉我省一原来还有奖金hhhh，意外之中的收获吧，但是不知道多久才能打到我的卡上qaq)</p><p>之后印象深刻的事情可能就是元旦晚会了吧，不知道为什么呢我就是想参加表演呢，因为感觉自己大学确实没参加过什么精彩的事情呢，于是就和几个室友和同学一起去表演了一个话剧，啊，每天晚上上完晚自习都去练习，动作什么的都要练好练到位，现在想想真的是挺辛苦呢，其实是挺浪费时间的。<br>到了上台的那一天真的是，说实话因为其他人的节目都挺精彩反而我们的节目不那么精彩了，所以没能在同学的记忆里面留下深刻的印象，说实话我挺灰心的，因为付出小于回报，自己辛辛苦苦练了几个星期的节目还不如别人一个女装的印象深刻xd，但是总之还算是很美好的一个回忆了。</p><p>然后就是这个学期，大二下学期，可能是最舒服的一个学期了，课也没多少，我也经常逃课去自习，自己可以利用的时间真的是多多了，但是很可惜啊，从三月份到五月份，整整三个月的时间我的水平还是没什么长进，还是停留在数据结构这上面很久了(说到这个真的是对自己好气好气，有的时候不逼一逼自己根本就不行)<br>但是这个学期说实话我并不觉得轻松，因为有三门跟物理相关的专业课要去考试，今天已经2号了，24号就要考第一门了，留给我的时间已经不多了，我决定就算要复习每天也要坚持学习算法，这个绝对不能断，自己给自己买的专栏要看，要实现的算法要坚持自己去实现一遍才行，再加上昨天到的xm3耳机，不能再找借口去放松什么的了，争取重新到达高三那时候的水平，不能再安逸下去了。<br>对了还有15号的6级考试，这个也要认真的去准备，争取一次过，不能让明年考研的时候还被这个困扰。</p><hr><p>好了，星期二就开始想写的这个东西我今天终于摸完了，说实话这两年其实不那么精彩，我在大学认识的人也太少了，可以获得的信息也太少了，以后要主动去认识更多更有趣的人才行呢，改变别人不如改变自己，主动去认识别人主动和别人交朋友才能充实自己嘛，虽然有时候会遇到尴尬，但是自己不主动就不会有故事呢！<br>在网上也是这样，争取到知乎上认识更多的小可爱(划掉)qaq哼唧<br>嗯，总结篇就写这么多吧，过几天再写关于未来具体的计划和要达成的目标吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1141</title>
      <link href="/2019/05/24/luoguOJ-P1141/"/>
      <url>/2019/05/24/luoguOJ-P1141/</url>
      
        <content type="html"><![CDATA[<h1 id="P1141-01迷宫"><a href="#P1141-01迷宫" class="headerlink" title="P1141 01迷宫"></a><center>P1141 01迷宫</center></h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/P1141" target="_blank" rel="noopener">传送门</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。</p><p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>第1行为两个正整数n,m。</p><p>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。</p><p>接下来mm行，每行22个用空格分隔的正整数i,j对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>m行，对于每个询问输出相应答案。</p><h1 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">01</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line">输入样例#<span class="number">2</span>： </span><br><span class="line"><span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">10010011</span></span><br><span class="line"><span class="number">01100100</span></span><br><span class="line"><span class="number">10010011</span></span><br><span class="line"><span class="number">01011011</span></span><br><span class="line"><span class="number">10001000</span></span><br><span class="line"><span class="number">00011011</span></span><br><span class="line"><span class="number">00101000</span></span><br><span class="line"><span class="number">00000010</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出样例#<span class="number">2</span>： </span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>定义一个数组val来存放迷宫，定义一个数组cmp来判断是否走过<br>1.这道题一眼看上去就是一个深搜，把01用二维数组存下下来，搜索每一个格子然后判断合理情况，如果遇到不相同的格子就记录<br>然后每遇到一个点就重新memset一下cmp重新开始<br>噼里啪啦一顿dfs交上去，TLE了三个点只有70分</p><p>2.这样做问题出在哪里呢？我把测试数据看了一下，发现很恶心，n和m分别取到了1000和100000，那显然，memset是很耗时间的<br>于是我想到把cmp数组的标记改为layer，代表所搜索的格子所在的不同联通块。<br>这样，每一次去数新一个格子所能联通的块数就只要更新layer，节省了很大一块时间(这样就不用每次memset一次cmp数组我觉得这样的做法很巧妙)<br>成功过掉了第二个点也就是n=1000, m=10000的点</p><p>3.但是还有两个点TLE，说明还要需要改进的地方需要我去思考<br>苦苦思索，是与否有其他优化方法，果然，有一条很明显的但是一早就被我忽略了：</p><h2 id="同一个联通块所在的格子，能到达的格子数都是相同的。"><a href="#同一个联通块所在的格子，能到达的格子数都是相同的。" class="headerlink" title="同一个联通块所在的格子，能到达的格子数都是相同的。"></a>同一个联通块所在的格子，能到达的格子数都是相同的。</h2><p>这样一看，怎么记忆化就已经很明显了，我们已经用cmp数组标记过了当前搜索的格子所在的联通块，用layer表示，那么我们只要再开一个record数组，将已经遍历过的联通块对应的格子数记录下来，那么搜索到相应联通块里的其它格子时，就不用再搜索了，这是一步很大的优化，最终我提交了修改过的代码，100分ac</p><p>自己遇到的坑：<br>第一个坑: OJ上要求的是直接输入一串数而不是一个数字一个数字输入的我觉得这个挺坑的，我就懒得换了，直接char一个数组去接受，然后再int一个全局数组去修改对应的值，这样做其实挺傻的，还有可以改进的地方~(但是我懒啊)~<br>第二个坑: OJ要求的输出是输入数据之后全部输出，所以就还要再定义一个sum数组去存放数据，最后再全部输出。</p><hr><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> record[maxm];</span><br><span class="line"><span class="keyword">char</span> sum[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> val[maxn][maxn];<span class="comment">//定义一个二维数组才存放n*n的迷宫</span></span><br><span class="line"><span class="keyword">int</span> cmp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示n*n迷宫,m表示询问的点的个数</span></span><br><span class="line"><span class="comment">//方向数组</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cmp[x][y] = layer;</span><br><span class="line">    record[layer] = ++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i],b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(val[a][b]==val[x][y])</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cmp[a][b] == layer)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span>&amp;&amp;a &lt;= n&amp;&amp;b &gt;<span class="number">0</span>&amp;&amp;b &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            cmp[a][b] = layer;</span><br><span class="line">            dfs(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;sum[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           (sum[i][j] == <span class="string">'1'</span>)&amp;&amp;(val[i][j] = <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum[maxm];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp1,temp2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;temp1,&amp;temp2);</span><br><span class="line">        <span class="keyword">if</span>(record[cmp[temp1][temp2]] == <span class="number">0</span>)&#123;<span class="comment">//如果record里面temp1和temp2对应的cmp的值为0的话就进行dfs，并记录到record中        </span></span><br><span class="line">            dfs(temp1,temp2);</span><br><span class="line">            sum[i] = record[cmp[temp1][temp2]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//遇到相同的联通块直接输出对应的record</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] = record[cmp[temp1][temp2]];</span><br><span class="line">        &#125;</span><br><span class="line">        layer++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-022</title>
      <link href="/2019/05/24/Leetcode-022/"/>
      <url>/2019/05/24/Leetcode-022/</url>
      
        <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a><center>22.括号生成</center></h1><h2 id="难度-medium"><a href="#难度-medium" class="headerlink" title="难度:medium"></a>难度:medium</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给出 <span class="built_in">n</span> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</span><br><span class="line"></span><br><span class="line">例如，给出 <span class="built_in">n</span> = <span class="number">3</span>，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><p>思路：应用递归的思路来解决这道题<br>只有当左括号大于右括号的时候才进行递归<br>但其实递归的实质就是栈的实现</p><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">val_generateParenthesis</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">string</span> str,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; n || right &gt; n)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(left == n &amp;&amp; right == n)</span><br><span class="line">    val.push_back(str);</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)<span class="comment">//只有左括号的数目大于右括号再进行递归</span></span><br><span class="line">    &#123;</span><br><span class="line">       val_generateParenthesis(left+<span class="number">1</span>,right,str+<span class="string">'('</span>,n,val);</span><br><span class="line">       val_generateParenthesis(left,right+<span class="number">1</span>,str+<span class="string">')'</span>,n,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; val;</span><br><span class="line">       val_generateParenthesis(<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,n,val);</span><br><span class="line">       <span class="keyword">return</span> val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190523</title>
      <link href="/2019/05/23/20190523/"/>
      <url>/2019/05/23/20190523/</url>
      
        <content type="html"><![CDATA[<h1 id="半个月来摸出来一点东西吧"><a href="#半个月来摸出来一点东西吧" class="headerlink" title="半个月来摸出来一点东西吧"></a>半个月来摸出来一点东西吧</h1><p>上回写日记还是5月12号，一晃眼就已经23号了啊<br>这个五月我过得还是比较充实的，基本上实现了基本预定的目标<br>不管是学习上还是其他方面，但是现在面临的问题也更多了<br>诶多，6月15号的六级考试过了之后，23号就要开始期末考试了<br>今天正好整整一个月的时间吧，不说之前重复的话了，没意思，好好努力吧，争取让充实的五月不忘初心吧</p><p>今天晚上又发生了不好的事情呢，我和好朋友又吵架了呢，像个hape一样那么大声在街上吵架。。。简直就像是失了智一样，我发现我有的时候就喜欢这样。。。喜欢跟别人较真，喜欢跟别人死磕，每次都是因为一些小事吵起来真的挺无语的，吵架的时候非要分个对错才行吗？有的时候想想就能明白的道理，自己却不去想不去思考，那再有用的大道理又有什么用呢？</p><p>所以啊抛弃这种幼稚的思想吧，努力去成长为一个大人吧！</p><p>这其中也发生了好多好多事情，我也想借这个机会聊聊我自己的看法，比如中美贸易战以及Trump制裁华为这几件事，让我觉得世界并不太平，Trump的目的可能是和以前的日本一样逼迫中国签订类似广场协议的条约<br>所以去年中兴被制裁，领导人直接就去谈判了，今年华为更加严重反倒没去，说明我们是准备和美国打而不是准备去谈判妥协问题。<br>但是我觉得这个时代自己不能太缺乏知识了，还是要去多了解历史经济相关的知识才行。<br>最近看b站上陈平教授的&lt;&lt;眉山论剑&gt;&gt;，我觉得陈平老师的知识很精辟也很到位，对当前一些热点问题的分析我觉得有自己独特的看法，而且也敢说话，没有架子<br>我决定去买本陈平教授的&lt;&lt;代谢增长论&gt;&gt;，多看一点历史案例和西方的一些兴衰史真的是很有意思啊，丰富自己的知识和阅历，我还从来没有主动迫切的想买一本书的时候啊。。。。<br>其实增加自己的知识水平比打游戏更有意思，我决定大学还有两年要利用好时间去学习更多相关的知识，争取能够早日达到能够在知乎上分析问题得出自己观点的水平吧！</p><p>可能是一个最好的五月，也可能是一个最坏的五月x，具体怎么样全看你自己了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1443</title>
      <link href="/2019/05/23/luoguOJ-P1443/"/>
      <url>/2019/05/23/luoguOJ-P1443/</url>
      
        <content type="html"><![CDATA[<h1 id="P1443-马的遍历"><a href="#P1443-马的遍历" class="headerlink" title="P1443 马的遍历"></a><center>P1443 马的遍历</center></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个n*m的棋盘(1&lt; n,m &lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>一行四个数据，棋盘的大小和马的坐标</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#输入输出样例</span><br><span class="line"></span><br><span class="line">输入样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">0</span>    <span class="number">3</span>    <span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    <span class="number">-1</span>   <span class="number">1</span>    </span><br><span class="line"><span class="number">2</span>    <span class="number">1</span>    <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输入样例#<span class="number">2</span>：</span><br><span class="line"><span class="number">6</span> <span class="number">9</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出样例#<span class="number">2</span>：</span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>思考:<br>这题就是一道很典型的bfs的题目<br>根据题目给的首节点，来存入队列里面<br>定义方向数组来模拟马走的八个方向<br>然后把首节点存入队列，然后取出首节点，依次遍历八个方向，然后如果可以就Map2 = Map1 +1<br>这样的话根据这个递推公式可以推出所有可以走的点<br>最后还记得定义一个path数组来判断是否走过就行了</p><p>这道题目里面的坑:<br>题目要左对齐宽五格所以要printf(“%-5d”,Map[i][j])</p><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1443 马的遍历</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="comment">//定义方向数组来定义马走的八个方向</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Map[maxn][maxn];<span class="comment">//定义一个数组记录棋盘上的</span></span><br><span class="line"><span class="keyword">int</span> path[maxn][maxn];<span class="comment">//定义一个路径来判断是否走过当前路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">//定义一个结构体才存放棋盘坐标的值</span></span><br><span class="line">     <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; val;<span class="comment">//定义一个来存放结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node s)</span><span class="comment">//传入结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val.push(s);</span><br><span class="line">    Map[s.x][s.y] = <span class="number">0</span>;<span class="comment">//定义开始为0，其余的结点都是依照这个点而来的</span></span><br><span class="line">    path[s.x][s.y] = <span class="number">1</span>;<span class="comment">//记录路径为走过</span></span><br><span class="line">    <span class="keyword">while</span>(!val.empty())<span class="comment">//如果队列里面不为空则继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node temp = val.front();</span><br><span class="line">        val.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)<span class="comment">//八个方向来进行探测</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node cmp;<span class="comment">//定义一个中间变量来存放数据</span></span><br><span class="line">            cmp.x = temp.x + dx[i];</span><br><span class="line">            cmp.y = temp.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(path[cmp.x][cmp.y] != <span class="number">0</span>||cmp.x&lt;<span class="number">1</span>||cmp.x&gt;n||cmp.y&lt;<span class="number">1</span>||cmp.y&gt;m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path[cmp.x][cmp.y] = <span class="number">1</span>;<span class="comment">//记录为走过</span></span><br><span class="line">            Map[cmp.x][cmp.y] = Map[temp.x][temp.y] + <span class="number">1</span>;</span><br><span class="line">            val.push(cmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Map));<span class="comment">//定义Map上所有结点为-1，如果这个值不会改变则说明这个点根本走不到</span></span><br><span class="line">    Node s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s.x&gt;&gt;s.y;</span><br><span class="line">    bfs(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%-5d"</span>,Map[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguOJ-P1162</title>
      <link href="/2019/05/20/luoguOJ-P1162/"/>
      <url>/2019/05/20/luoguOJ-P1162/</url>
      
        <content type="html"><![CDATA[<h1 id="P1162-填涂颜色"><a href="#P1162-填涂颜色" class="headerlink" title="P1162 填涂颜色"></a><center>P1162 填涂颜色</center></h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">由数字<span class="number">0</span>组成的方阵中，有一任意形状闭合圈，闭合圈由数字<span class="number">11</span>构成，围圈时只走上下左右<span class="number">44</span>个方向。现要求把闭合圈内的所有空间都填写成<span class="number">22.</span>例如：<span class="number">6</span>×<span class="number">6</span>的方阵（n=<span class="number">6</span>），涂色前和涂色后的方阵如下：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每组测试数据第一行一个整数n(1&lt;=n&lt;=30)<br>接下来n行，由0和1组成的n×n的方阵。</p><p>方阵内只有一个闭合圈，圈内至少有一个0。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>已经填好数字2的完整方阵。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出样例#<span class="number">1</span>： </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>说明: 1&lt;=n&lt;=30</p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>定义一个a数组来接受方阵，然后定义一个b数组，在a数组的外围套一层边界，也就是套一层0，这样做的目的是为了让dfs边界的时候能够把闭合圈以外的部分都能够标记(也就是染色)</p><p>然后定义方向数组，从(0,0)开始往四个方向依次寻找两个边界中间的部分然后标记，然后b数组对应没染色的地方就是a数组方阵闭合圈里面要找的</p><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40</span>;<span class="comment">//定义最大的边界</span></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//用来接收方阵的数组</span></span><br><span class="line"><span class="keyword">int</span> b[maxn][maxn];<span class="comment">//把方阵外面套一层边界,便于dfs寻找边界</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//N表示N * N的方阵</span></span><br><span class="line"><span class="comment">//方向数组,依次为右下左上</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当dfs寻找值碰到外边界和内边界时返回上一层</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>|| x &gt; N+<span class="number">1</span>||y &lt; <span class="number">0</span>||y &gt; N+<span class="number">1</span>||b[x][y] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没碰到边界,继续搜索,令两个边界中间的值为2,并沿着四个方向继续搜索</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs((x + dx[i]),(y + dy[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="comment">//输入方阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">1</span>)</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//对加过边界的b数组进行搜索</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-019</title>
      <link href="/2019/05/15/Leetcode-019/"/>
      <url>/2019/05/15/Leetcode-019/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><center>19. 删除链表的倒数第N个节点</center></h1><h2 id="难度：medium"><a href="#难度：medium" class="headerlink" title="难度：medium"></a>难度：medium</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">给定的 n 保证是有效的。</span><br></pre></td></tr></table></figure><hr><p>我自己的思路:<br>(两次遍历链表的想法)<br>先定义一个num遍历链表记录结点的总数，然后定义一个cmp = 0，当再次遍历到num - n -1时就表明这个时候的结点是在要删除结点的前一个结点，然后再进行删除操作</p><p>这题遇到的坑：不知道leetcode到底有没有头结点，结果最后发现没有头结点，head对应的就是第一个结点，最后定义了一个newhead做头结点来进行操作，如果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    newhead-&gt;next = head;       </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>,cmp = <span class="number">0</span>;</span><br><span class="line">    ListNode *temp1,*temp2;    </span><br><span class="line">    temp1 = newhead;</span><br><span class="line">    temp2 = newhead;</span><br><span class="line">    <span class="keyword">while</span>(temp1 != <span class="literal">NULL</span>)<span class="comment">//统计链表的结点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp1 = temp1-&gt;next;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;    </span><br><span class="line">     <span class="keyword">while</span>(cmp != num - n <span class="number">-1</span> )<span class="comment">//定位到要删除结点的前一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = temp2-&gt;next;</span><br><span class="line">        cmp++;</span><br><span class="line">    &#125;   </span><br><span class="line">    ListNode * flag = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    flag = temp2-&gt;next;</span><br><span class="line">    temp2-&gt;next = flag-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead-&gt;next; </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>官方的题解思路：</p><p>###方法一：两次遍历算法</p><p>###思路</p><p>我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。</p><p>###算法</p><p>首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。</p><p><img src="/2019/05/15/Leetcode-019/a476f4e932fa4499e22902dcb18edba41feaf9cfe4f17869a90874fbb1fd17f5-file_1555694537876.png" alt="删除列表中的第 L - n + 1 个元素"></p><p>Java代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">int</span> length  = <span class="number">0</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    <span class="keyword">while</span> (first != null) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    length -= n;</span><br><span class="line">    first = dummy;</span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        length--;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first.next = first.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##复杂度分析</p><p>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。</p><p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p><hr><p>###方法二：一次遍历算法</p><p>###算法</p><p>上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p><p><img src="/2019/05/15/Leetcode-019/4e134986ba59f69042b2769b84e3f2682f6745033af7bcabcab42922a58091ba-file_1555694482088.png" alt="删除链表的倒数第 N 个元素"></p><p>Java代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">    <span class="keyword">while</span> (first != null) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###复杂度分析</p><p>时间复杂度：O(L)，该算法对含有 L个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。</p><p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-018</title>
      <link href="/2019/05/14/Leetcode-018/"/>
      <url>/2019/05/14/Leetcode-018/</url>
      
        <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a><center>18.四数之和</center></h1><h2 id="难度-medium"><a href="#难度-medium" class="headerlink" title="难度: medium"></a>难度: medium</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目描述:</span><br><span class="line">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">答案中不可以包含重复的四元组。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = <span class="comment">[1, 0, -1, 0, -2, 2]</span>，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[-1,  0, 0, 1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[-2, -1, 1, 2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[-2,  0, 0, 2]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><hr><p>思路:<br>回顾一下三数之和的思路:<br>三数之和的主要思路在于双指针的遍历<br>先把数组从小到大排序，然后再从nums[k]开始从左往右进行遍历<br>因为a + b + c = target<br>此时只要 b + c = target - a相等的话就算找到了<br>然后就是相当于定义两个双指针分别对应 b 和 c<br>int i = k+1<br>int j = nums.length() - 1<br>然后 i , j从k的右边到数组的边界，从两头分别开始进行遍历<br>如果nums[i] + nums[j] &lt; (target -nums[k]) 那么就说明i还需要更大一点才能相等,i++<br>如果nums[i] + nums[j] &gt; (target -nums[k]) 那么就说明j还需要更小一点才能相等,j–<br>最后nums[i] + nums[j] == (target -nums[k]) 的时候记录数据<br>这个时候进行去重的操作，因为第一次相等之后，如果i,j,k后面还有重复的数字的话那么就会有重复的结果<br>那么如果遇到符合条件的重复数组就i++,j–,k++去重</p><hr><p>四数之和==&gt;三数之和==&gt;两数之和<br>跟三数之和类似，多了层循环遍历数组，同时也需要注意数组的去重操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.size();k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> value = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span>(value &gt; (<span class="number">0</span>-nums[k]))&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; <span class="number">0</span>-nums[k])&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">                    <span class="built_in">list</span>.push_back(nums[k]);</span><br><span class="line">                    <span class="built_in">list</span>.push_back(nums[i]);</span><br><span class="line">                    <span class="built_in">list</span>.push_back(nums[j]);</span><br><span class="line">                    res.push_back(<span class="built_in">list</span>);</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i] == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(k&lt;nums.size()<span class="number">-1</span> &amp;&amp; nums[k] == nums[k+<span class="number">1</span>])&#123;</span><br><span class="line">                    k++;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190512</title>
      <link href="/2019/05/12/20190512/"/>
      <url>/2019/05/12/20190512/</url>
      
        <content type="html"><![CDATA[<h1 id="一点点小总结吧"><a href="#一点点小总结吧" class="headerlink" title="一点点小总结吧"></a><center>一点点小总结吧</center></h1><p>迟到了两天才有时间写个总结，我也真是懒啊hhh<br>忙碌复习一周的感觉简直就是要了我的命，从零开始学习令我厌恶的化学真的是让我作呕<br>可是我又能有什么办法呢(笑)，为了不挂科，也只能用心的去学了呢，每天一有空就去自习室简直就是让人窒息啊，就感觉提前进入了复习周一样难受啊，不过以后每个周末都要好好努力复习了呢</p><p>总之总之，期中考试终于over了，接下来是新の五月的生活啊<br>虽然已经过了一半了，但是也要好好的充实才行呢</p><p>这几天又发生了几件让我不开心的事情呢，果然不是每个人都是善意的呢，有的人不喜欢被主动勾搭，有的人不喜欢和我说话，真的是好遗憾呢</p><p>诶多诶多，这每天记流水账一样的日记简直就是让我想吐啊233333，果然每天还是应该乱写点想写的东西才好吗</p><p>啰里啰嗦了半天还是决定以后如果有意义的事情再来写日记吧233333<br>那么就这样吧今天，希望以后能继续写更多有意义的东西呢</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190509</title>
      <link href="/2019/05/09/20190509/"/>
      <url>/2019/05/09/20190509/</url>
      
        <content type="html"><![CDATA[<h1 id="令人绝望的星期四"><a href="#令人绝望的星期四" class="headerlink" title="令人绝望的星期四"></a><center>令人绝望的星期四</center></h1><p>嗯，一个星期唯一没课的一天，硬是自己把自己搞自闭了，早晨7点本来只想趴着休息会，结果睡着睡着就睡到九点半了，唔，然后一个上午相当于啥都没干，中午又睡了个觉磨磨蹭蹭到三点钟才起床去自习室，然后到自习室混了7个多小时到十点左右再回来</p><p>结构真的是好难啊，好多东西我都搞不懂，还有一天多的时间去学，还有物化这块硬骨头要啃，呜，这个星期过了我就好好做人，游戏都删掉的我要过一个不一样的五月！</p><pre><code>by Azure</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190508</title>
      <link href="/2019/05/08/20190508/"/>
      <url>/2019/05/08/20190508/</url>
      
        <content type="html"><![CDATA[<h1 id="星期三的烦恼嗷"><a href="#星期三的烦恼嗷" class="headerlink" title="星期三的烦恼嗷"></a><center>星期三的烦恼嗷</center></h1><p>今天真的是忙碌的一天嗷，从早到晚满课嗷，今天凌晨四点钟突然惊醒然后睡不着，到床上折腾了半天估计有半个小时吧才睡着，诶诶多结果一醒来结果利物浦居然把巴萨逆转了！！！哇塞，创造历史的一场比赛啊，还没有球队能够在客场0比3的情况下，主场逆转翻盘！真的是荡气回肠的一场比赛，说实话我其实挺喜欢利物浦的，尤其是渣叔克洛普，我超喜欢的！真心希望利物浦能赢得欧冠啊，去年的遗憾今年不能再重蹈覆辙了。</p><p>早晨日常逃课，但是早晨学习的效率是真的低啊，又困又要学习，真的是好难熬啊嗷嗷，期中考试的一周真的是难受难受难受难受的要死了，一个星期要学完前面几个月的知识我真是个天才哈哈哈哈哈哈嗝才怪，希望这星期能应付完期中考试吧，再准备其他比赛。</p><p>晚上真的是没心思学习了，晚上看汉堡王做活动没忍住买了四五十的外卖呜呜呜，我真的是败家玩意嗷，还口口声声说减肥呜，估计又要胖回去了，嗯嗯这一定是最后一次，嗯最后一次啦，以后为了减肥可不能再这样了5555555</p><p>最后就是不能理解为什么要晚上停电维修，唔，明明早晨宿舍都没人它不去检修，非要晚上还没睡觉的时候就停电检修，搞不懂电力部门在想什么</p><p>那么今天就这样吧，晚安啦，希望明天没课的一天我能复习完物化和结构的大部分。<br>                           by Azure</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190507</title>
      <link href="/2019/05/07/20190507/"/>
      <url>/2019/05/07/20190507/</url>
      
        <content type="html"><![CDATA[<h1 id="今日份的记事"><a href="#今日份的记事" class="headerlink" title="今日份的记事"></a><center>今日份的记事</center></h1><p>今天真的是不一样的一天呢</p><p>早晨日常去上体育课，本来以为要体测做引体向上，结果那个老师是个明白人233333，我本来一个也做不了的qaq结果挂上面抖了抖就给我算满分了hhhhh，然后测完中途就溜回去洗了个澡就休息了，嗯挺不错的。</p><p>中午倒是发生了一些事情让我有点害怕，中午日常吃饱饭，但是一站起来就感觉胃特别不舒服，还好我室友给了我胃药缓解多了，但是以后必须得格外注意了，不能吃的太饱233333</p><p>下午好不容易起来去自习室，但是感觉还是效率不是太高，好在今天把物化第二章复习完了，接下来就是明天继续复习第三章和去写期中考试卷子了，嗯感觉这个星期如果熬过去感觉这次的考试是可以挺过去的。</p><p>晚上倒是发生了很多愉快的事情，和同一类人聊天是真的愉快，说什么话都能很快就明白根本不用多费口舌，别人说什么东西也能很快就能懂意思，不仅仅是一起讨论问题还是去探讨一些别的话题，我们在一起聊天是真的很开心很开心！希望以后多和这样的好朋友在一起为未来的前途努力吧！说实话真的是很烦为什么没分配到一个宿舍里面啊真的是，我现在越来越讨厌我的室友了，真的不是一类人，只会天天打游戏，应付考试应付别人，关键是还喜欢影响别人，等着瞧吧，再过两年我们走着瞧咯。</p><p>这个星期复习完专业课后要重新开始学习算法，英语和数学，嗯一个也不能拉下，尤其是已经把游戏全部都卸载掉了，嗯五月初自己说过的话千万不能再忘了，已经失去太多的东西了好像已经没有再可以失去的了，一起学习的朋友晚上熬夜到三点中还在做leetcode，感觉自己跟别人比起来真的是太舒服了，要找回原来的那种状态，要去让每一天都充实起来才行！加油吧，每天都不忘初心方得始终。<br>                                       by Azure</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190506</title>
      <link href="/2019/05/06/20190506/"/>
      <url>/2019/05/06/20190506/</url>
      
        <content type="html"><![CDATA[<h1 id="预习第一天的感受"><a href="#预习第一天的感受" class="headerlink" title="预习第一天的感受"></a><center>预习第一天的感受</center></h1><p>不开心的第一天嗷，不过早晨做实验是真的混啊2333333，本来以为今天要做很久的实验，看了那么一大堆步骤，结果老师都不让我们去做，给了个粗品要我们直接去提纯，简直太快乐了啊哈哈。</p><p>昨天Trump的一条推特导致今天A股暴跌真的是闻所未闻，都快跌6%了，简直就是股灾啊，看别人评论说的，别人美国总统一句话就能让你一无所有，很真实，股市的风险确实是太大了，我觉得我在大学这个阶段一定要慎之又慎才行，我搞这个心态又不好23333，所以要锻炼自己在金融方面的知识才行呢，做一个知识全面的人才行呢。</p><p>下午就不怎么快乐了，今天开始复习物化了，但是真的是好烦啊，本来就不喜欢物理相关的知识，但是这学期两门专业课都涉及物理，简直让我绝望5555555，还以为就算不怎么好好学考试考好点能拿奖学金呢，可惜这学期估计科科及格都难咯</p><p>下午在自习室从4点一直搞到9点半，除去要去上课签到花了点时间，差不多有将近五个小时的时间都可以学习，但是效率是真的低，在自习室整个人都快自闭了，太安静的环境也不适合去学习，脑阔里面非要听点电音或者轻音乐才能去集中自己的注意力，但是有的时候听多了反而又容易走神23333，真的是很难抉择呢，但是好在是已经开头了，我有信心去准备这次的期中考试，这个星期好好努力吧，争取达到能应付考试的水平就行了，然后下个星期再开始准备学习算法，天天运动，嗯，这学期不能再像之前那样了</p><p>这可是你自己说要过一个不一样的五月啊，成年人就应该信守自己所作出的承诺。</p><p>嘛，今天就写这么多吧，每天写日记写博客真的是让自己很喜欢这种生活，为什么不早点开始坚持记录自己每天的生活呢？嘻嘻</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190505</title>
      <link href="/2019/05/05/20190505/"/>
      <url>/2019/05/05/20190505/</url>
      
        <content type="html"><![CDATA[<h1 id="今日份的不知所云"><a href="#今日份的不知所云" class="headerlink" title="今日份的不知所云"></a><center>今日份的不知所云</center></h1><p>嗯，五一假期后的第一天上学，感觉还行吧，感觉自己的状态有所回升呢，但是感觉还是要加把劲呢，还有一个星期从零开始准备期中考试啊，真的是最不舒服的一个星期要来了呢</p><p>今天真的是莫名其妙的惊喜呢，空间里面突然有个大佬加我，真的是猜不透呢，不是一个世界的人原来想接触我这样的普通人吗？感觉别人的思想真的是不一样呢，想去顶级名校，想去拯救整个社会，想去改造别人的思想，想去像儒家一样去兼济天下，唉，可惜呢，只有生存无忧才会去想这些事呢，继承家产，到大城市的地方有几套房，我如果有这么好的家室就好了啊，有钱可以买自己想买的东西，也没有学业，事业上面的压力就好了，可是啊，这只能存在于幻想之中呢，现实就是我出身一个十八线小城市，没车没房，家里也没钱，唯一值得庆幸的就是父母都挺开明的，知道自己没什么知识，敢于让我自己去做决定，自己去做决定自己未来的人生道路，我觉得这也是不幸中的万幸了吧！</p><p>还有一件事就是我今天才知道我的一个室友前几天刚脱单，这几天又找到了新的女友，怎么说呢，别人大学都谈了三次了我还一次都没有，怎么说呢，从小到大我可能对感情都没有概念吧，被老师把恋爱这个选项在脑海中删除了(其实也有小学到高中越来越丑越来越胖的原因)，但是谁不渴望爱情呢，不说那么奢侈的东西吧，我其实渴望被关心，渴望和别人每天聊天，渴望和别人分享自己的快乐和烦恼，谁喜欢孤独呢，孤独都不是被逼的吗？如果遇到合适的人和志同道合的人，谁又想一个人呢。</p><p>诶多，不知不觉又写了这么多，我也不知道自己天天在说什么，但是感觉日常写日记真的让自己感觉很棒，我会继续坚持下去的，记录自己生活的点点滴滴，这样的感觉真的很棒，等我觉得哪天我的东西可以分享给别人的话就会给你们看的，毕竟日记也不是不可以分享给别人的东西，我也希望有人来看我每天生活的点点滴滴，希望以后能遇到更多更棒的朋友！<br>                                         by Azure</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-002</title>
      <link href="/2019/05/04/Leetcode-002/"/>
      <url>/2019/05/04/Leetcode-002/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><h3 id="难度-medium"><a href="#难度-medium" class="headerlink" title="难度 : medium"></a>难度 : medium</h3><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h5><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure></p><hr><p>分析：两个非空的链表表示两个非负的整数，既然是按照逆序的方式来储存，那么就应该对两个链表分别从头开始遍历进行加和操作</p><p>用x,y来分别取出两个数对应的数位,用carry来记录是否需要进位<br>先令carry = 0,再计算sum = x + y + carry;<br>如果 sum &gt;= 10,则令carry = 1<br>再让 sum % 10来组成新的数的每一位<br>如果其中一个链表有数可以取出,而另一个链表的下一位为NULL<br>则令为NULL的那一条链表对应的x或者y为0即可</p><p>然后最后结束的时候如果carry还为 1,说明最后还多出来一位,则应该再额外多进1。</p><hr><p>自己在这题中遇到的问题:<br>Leetcode给的构造函数(struct跟class一样啊，我真的是有点傻了)<br>既然它给的有构造函数<br><code>ListNode(int x) : val(x), next(NULL) {}</code><br>则初始化对象的时候一定要调用,那么定义新的结点的时候就一定需要一个初始值(比如0),否则会报错。</p><hr><p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">  ListNode *p1,*p2,*p3;</span><br><span class="line">  ListNode *l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);      </span><br><span class="line">  p1 = l1;</span><br><span class="line">  p2 = l2;</span><br><span class="line">  p3 = l3;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p1 != <span class="literal">NULL</span> || p2 != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//如果对应的数位为NULL,则直接令其为0</span></span><br><span class="line">      <span class="keyword">int</span> x = (p1 != <span class="literal">NULL</span>) ? p1-&gt;val : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> y = (p2 != <span class="literal">NULL</span>) ? p2-&gt;val : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">      (sum / <span class="number">10</span>)? (carry = <span class="number">1</span>): (carry = <span class="number">0</span>);</span><br><span class="line">      ListNode *s = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//定义一个新的结点来存放结果,一定要初始化才行</span></span><br><span class="line">      s-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">      p3-&gt;next = s;</span><br><span class="line">      p3 = s;</span><br><span class="line">      (p1 != <span class="literal">NULL</span>) &amp;&amp; (p1 = p1-&gt;next);<span class="comment">//代替if的语句</span></span><br><span class="line">      (p2 != <span class="literal">NULL</span>) &amp;&amp; (p2 = p2-&gt;next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry)<span class="comment">//如果最后carry还为1,则说明还需进一位</span></span><br><span class="line">  &#123;</span><br><span class="line">      ListNode *s = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      s-&gt;val = <span class="number">1</span>;</span><br><span class="line">      p3-&gt;next = s;</span><br><span class="line">      p3 = s;</span><br><span class="line">      p3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  l3 = l3-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> l3;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新の开始？</title>
      <link href="/2019/05/04/20190504/"/>
      <url>/2019/05/04/20190504/</url>
      
        <content type="html"><![CDATA[<h1 id="新の开始"><a href="#新の开始" class="headerlink" title="新の开始"></a>新の开始</h1><h2 id="胡乱写一些自己都看不懂的话"><a href="#胡乱写一些自己都看不懂的话" class="headerlink" title="胡乱写一些自己都看不懂的话"></a>胡乱写一些自己都看不懂的话</h2><h3 id="重新再来，从头开始"><a href="#重新再来，从头开始" class="headerlink" title="重新再来，从头开始"></a>重新再来，从头开始</h3><p>真的是令人怀念的话语啊,上一次说这个话是高考前一百多天的时候,结果说完也没有多么努力去改变自己的命运,结果自己到了今天这个地步,如今,实在是没有什么可以再失去的东西了</p><p>青春？梦想？努力？奋斗？再为自己的年轻付出巨大的代价之后才会后悔,可是又能有什么用呢？一次又一次的悔恨,一次又一次的失败，我实在是厌倦这样的生活了,不知道两年前的自己怎么也想不到今天会到这种地步吧，不仅什么也不会，而且也缺少朋友，缺少能天天和我一起说话的人</p><p>孤独？谁又喜欢孤独呢，谁希望自己被逼成这样呢，孤独的人也渴望和朋友一起聊天，一起分享每天的欢乐，一起诉说每天的烦恼，这是我梦想中的生活啊。</p><p>然而，每天简直就是有无穷无尽的烦恼，不仅是学业上还是生活中。<br>经过了两年的时间，自己还是啥都不会，虽然早就下定了转行的决心，但是相比跟我年龄一样的科班的人，差距还是巨大，只有每天付出比他们更多的努力才能让自己变得更强<br>生活上，每天被室友吵得心烦，天天只会打游戏，混日子，每个星期还要去实验室跟老师搬砖还浑然不知未来的处境如何，真的是感觉可悲，真不知道再过两年他们会有什么感受。</p><p>想起了高中班主任跟我说的话，眼界决定境界，态度决定高度，这句话我现在细想起来还真的是太对了，但可惜我两样都没有<br>论眼界，从小城市出身的我真的是眼界太低，见识也太低了，居然稀里糊涂的报了化学这个天坑专业，高中还以为化学挺有意思的，谁知道大学完全是两个完全相反的学科，跳进了坑真的是感觉自己蠢到极点。<br>论态度，我明知道每天自己该干嘛，却还是天天摸鱼，喜欢看b站，喜欢逛知乎，喜欢玩游戏，反正每天除了学习真的是一堆事都能做，但是只要学习就容易犯困，提不起劲，这个学期把没用的课都翘了好好学算法，学相关一堆知识可以学，但是我还是喜欢浪费时间，整天摸鱼，然后从2月份一直到现在，我真的忍受不了了，必须做出一点改变来才行了，不然就算再给两年的时间给自己也是白费。</p><p>已经20岁了，不再是一个小孩子了，是时候该为自己的未来，为自己的前途好好考虑一下了，人不是为自己而活，你还要付出很多很多东西才行，不说那么远，就说为了将来自己幸福的生活现在也应该要好好行动了。<br>嗯，今天把游戏全都卸载了，时间是宝贵的，再也经不起我这样浪费了，两个月的时间，我想重新调整自己的状态，该去自习室去自习室，该休息休息，以后每天十一点上床睡觉，决不熬夜，只有晚上睡好了早晨才有精神去学习，去做其他事情。<br>这个月，再也不能跟自己开玩笑了。<br>总结下最近应该准备的东西吧<br>1.英语六级，每天背10-15个单词<br>2.物理化学，结构化学复习，先把期中考试撑过了再说吧。<br>3.每天一篇算法题目(期中考试前可酌情减少)<br>4.订阅的专栏每天阅读两到三篇文章，有问题多跟小伙伴去讨论<br>5.知乎上多跟别人互动交流，诶多自己不主动怎么会有更多的朋友呢emmmm，如果可以每个星期摸出一篇高质量的回答吧！争取把点赞数和关注数都上去吧，多跟别人到想法下面去互动吧！<br>6.Linux入门吧，再不入门说不过去了。<br>7.继续算法的学习，这个每天不能丢。<br>8.运动也不能停，但是可视情况减少相应的跑步次数来去学习。</p><p>嗯，就写这么多吧，现在好像也总算养成了写博客写日记的习惯了，希望再过一年两年的自己再回过头来看不会后悔吧！加油啊</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不知道自己在说些什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五一假期的一点感想</title>
      <link href="/2019/05/02/20190502/"/>
      <url>/2019/05/02/20190502/</url>
      
        <content type="html"><![CDATA[<h1 id="五一假期的一点感想"><a href="#五一假期的一点感想" class="headerlink" title="五一假期的一点感想"></a><center>五一假期的一点感想</center></h1><p>阿拉阿拉，这个学期最舒服的一个月快要走到尽头了呢，从四月份的清明假一直到现在的劳动节假期，整整一个月的时间，每天逃课每天玩手机，每天想干嘛就干嘛，现在再让我回想起去年天天满课的时光，我都不知道我是怎么度过来的emmmmm</p><p>这个月主要有两个烦人的事情，第一个就是期中考试吧，虽说已经知道结构期中考试可能不算成绩吧，但是这也不是我逃避它的借口，嗯要花时间去重新学起来，还有一个就是物化了，物化期中考试老师都很认真，所以我也要去认真的去准备它，起码不能挂科吧，额，所以最近要开始找回上学期的那种状态咯<br>诶多我想想啊，从5号到10号这六天时间要<del>复习</del>预习准备考试，怎么想都够呛，额，为了准备它我还额外到网上买了学习指导和习题解答，这尼玛还不及格那就真的是自己的问题了，好好加油吧。</p><p>还有一个烦的就是体测了，虽说上个星期刚测完一千米，但是下个星期还要去测引体向上，我我我没臂力真的一个也做不来啊qaq，诶多，期末还要考颠球什么的，要是体育也挂科了那多丢人qaq</p><p>嗯，嗯因为长假的缘故我又到学校外面订了两个晚上的酒店准备放松下自我，准备去试试新买的小裙子什么的，诶多说实话我还从来都没试过呢xd，嗯我喜欢安静的环境，想和别人打游戏语音也不会吵到别人，也不会有傻逼室友来吵我烦我，所以说对于我来说，我适合独居生活而不是群居！</p><p>哼唧，如果以后能跟喜欢的人一起合居就好了qaq，嘛，既然已经知道自己放假不可能好好学习了，那还不如玩的爽一点呢，诶多，就写这么多吧，以后估计要经常写日记了hhh</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-206</title>
      <link href="/2019/04/29/Leetcode-206/"/>
      <url>/2019/04/29/Leetcode-206/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><h3 id="难度-easy"><a href="#难度-easy" class="headerlink" title="难度:easy"></a>难度:easy</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><hr><p>自己的解法：<br>思路:至少需要三个结点p1,p2,p3来完成链表的逆序<br>首先从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点、第三个节点。<br>实现链表逆序的完整步骤如下：<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429174100.png" alt><br>1.以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173342.jpg" alt><br>2.三个临时节点引用p1，p2，p3分别向后移动一格位置。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173345.jpg" alt><br>3.重复第1步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173348.jpg" alt><br>4.重复第2步的工作，三个临时节点引用p1，p2，p3分别向后移动一格位置。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173351.jpg" alt><br>5.继续像这样子迭代下去，一直到p2是空为止。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173354.jpg" alt><br>6.最后，把head节点的next指向空，成为逆序链表的尾节点。并且把p1赋值给head，让p1所在的节点成为逆序链表的头节点。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173356.jpg" alt></p><p>实现代码如下:<br>方法1：迭代<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//当头结点为空，或者它的下一个结点为空的话，返回head</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *p1,*p2,*p3;<span class="comment">//声明三个中间变量来交换</span></span><br><span class="line">    p1 = head;</span><br><span class="line">    p2 = head-&gt;next;</span><br><span class="line">    p3 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head = p1;</span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><p>方法2: 递归<br>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø</p><p>若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。</p><p>n1 → … → nk-1 → nk → nk+1 ← … ← nm</p><p>我们希望 nk+1 的下一个节点指向 nk。</p><p>所以，nk.next.next = nk;</p><p>要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><p>实现代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><p>时间复杂度：O(n)。假设n是列表的长度，那么时间复杂度为O(n)。</p><p>空间复杂度：O(n)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到n层。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九周小结</title>
      <link href="/2019/04/28/%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/04/28/%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="第九周小结"><a href="#第九周小结" class="headerlink" title="第九周小结"></a>第九周小结</h1><p>不知不觉，一个星期又过去了，好像还是老样子，还是那么喜欢摸鱼，还是那么喜欢混，可能是上几个学期的努力过头了吧，这个学期实在是太轻松了，人就是这样，有的时候没有外部的压力可能就不逼自己，道理谁都懂，可谁都喜欢去犯懒，谁都喜欢去打游戏，看剧之类的，学习的过程是枯燥的，在这个漫长的过程中学习所能得到的正反馈太少了，所以本来从17年高考结束开始就决定学编程，到现在19年快两年了感觉根本没什么长进，我自己都觉得自己是个傻逼。</p><p>方向不对，再多努力也是白费，前几天看扬叔写的小说真的是触目惊心，王奋斗不努力吗？并不是他不努力，只是他一步又一步的犯错，本来人试错的成本就已经很高了，更何况还一而再再而三的试错？</p><p>没错，王奋斗的经历确实有点夸张，但正是因为这种夸张作者才想要深切的告诉我们，天坑专业不是一般人能读的啊，不管是学术界还是工业界，不管是去当导师廉价的劳动力还是去化工厂做危险的工作，我觉得都是不可接受的，所以更加坚定了我脱坑搞CS的决心</p><p>可怜我那几个室友，现在天天去实验室搬砖像个傻子一样，一点觉悟都没有，等过几年再看看他们是什么处境吧</p><hr><p>顺手记录下这个星期所发生的大事吧<br>星期一没上物化课，在宿舍摸了一整天，勉强完成了当天的任务</p><p>星期二上了体育课，把假条也给了老师看了，重新去踢了足球比赛<br>但是是真的累啊，不知道为什么每天晚上运动了那么久，结果去比赛还是累的要死。<br>但是下个星期二要测一千米啊啊啊啊，说实话挺烦的。</p><p>星期三上午去自习的效率还行，可能这是唯一让我感到满意的一天了吧，晚上去公园茂玩了一晚上，也挺开心的吧，虽然公园茂那里的小吃并不让我特别感兴趣</p><p>星期四一天没课，下午我又没去自习，本来是早就要跟基友一起去自习的，但是却都不互相监督，真的是无语呢，所以啊挺想找个跟我一样的人一起去考研一起去学习，甚至能一起恋爱呢(~大雾~)</p><p>星期五这一天可真的太无语了，早晨睡了一早晨不说，下午第一次准备去逃马原课，第一次去逃老师就点名，还是基友和我室友一起帮忙说我请假了才搞定的这事，现在想想就心有余悸，如果当时我一开始就冲过去就好了，真的是不幸中的万幸了<br>晚上去找到了我五一订的酒店的位置，看起来还不错吧，物超所值，差不多是花了上回出去住一晚上的价钱住了两个晚上，期待出去住呢<br>还去丹尼斯购物了一波，说实话有点小失望吧，其实大超市也没什么东西好买的，就买了两盒饼干和一点小零食，唯一让我开心的就是里面有卖仲景香菇酱的吧，以后可以不用到网上买了嘻嘻，然后又去公园茂转了一圈，转了半天都不知道吃什么，最后结果去吃了渔粉，说实话不是很好吃，而且也不值这个价55555555，最后是出去花了一百多真的是败家啊，以后要开始省钱了呢<br>星期六一天啥也没做，又浪了一整天，晚上还花了40点了汉堡王的外卖，而且因为天气的原因这一个星期都没跑步，我真的是太草了<br>今天星期天，上午摸过去，下去去自习室吧，晚上签个到去跑步然后就结束这一个星期吧</p><p>诶多这个星期买了小裙子订了酒店还有各种乱七八糟的居然花了1k了，这么抠门的我居然能花这么多，其实是心痛死了啊啊啊啊啊啊啊啊，如果不是上个月发现了闲鱼上可以赚点小钱现在我岂不是更穷5555555555555，而且最近闲鱼上买东西的越来越少了，我应该要想点办法去卖更多的东西了，诶多争取以后一个月起码有2K才行？</p><p>所以继续明确一下下个星期的目标和每天的任务吧，不多也不少，但是每天要坚持完成，没完成就给自己惩罚！<br>每天的任务:<br>1.开始准备6级考试，每天十五个英语单词，期中考试过后每天还要两篇阅读理解<br>2.张宇1000题每天五题<br>3.洛谷OJ or Leetcode 每天一题<br>4.程序员小灰 or 极客时间 每天一章<br>5.微信小程序(这个比赛我将信将疑了，因为感觉学JavaScript和那个好费劲，但毕竟是我提出的计划，嘛有时间就去看看吧)<br>6.王道数据结构开始看，题目也开始做吧<br>7.准备期中考试，物化重点复习，结构次重点复习。(五一看看能不能复习一哈子，然后5.11之前复习完)</p><hr><p>好了，总结和感悟就这么多吧，以后争取至少每个星期写篇日记吧，还要把刷过的每一道题都放到博客上来，嗯，过几天再把评论区和其他东西完善一下，如果可以的话再搞个域名就更好了，那么Azure加油吧！你现在不是一个人在战斗呢。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷Oj-P1101</title>
      <link href="/2019/04/24/luoguOj-P1101/"/>
      <url>/2019/04/24/luoguOj-P1101/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷OJ-P1101"><a href="#洛谷OJ-P1101" class="headerlink" title="洛谷OJ-P1101"></a>洛谷OJ-P1101</h1><h2 id="P1101-单词方阵"><a href="#P1101-单词方阵" class="headerlink" title="P1101 单词方阵"></a>P1101 单词方阵</h2><p>题目描述<br>给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">    <span class="number">8</span>                     输出：</span><br><span class="line">    qyizhong              *yizhong</span><br><span class="line">    gydthkjy              gy******</span><br><span class="line">    nwidghji              <span class="built_in">n</span>*i*****</span><br><span class="line">    orbzsfgz              o**z****</span><br><span class="line">    hhgrhwth              h***h***</span><br><span class="line">    zzzzzozo              z****o**</span><br><span class="line">    iwdfrgng              i*****<span class="built_in">n</span>*</span><br><span class="line">    yyyygggg              y******g</span><br></pre></td></tr></table></figure></p><p>输入输出格式<br>输入格式：<br>第一行输入一个数n。(7≤n≤100)。</p><p>第二行开始输入n×n的字母矩阵。</p><p>输出格式：</p><h2 id="突出显示单词的n×n矩阵。"><a href="#突出显示单词的n×n矩阵。" class="headerlink" title="突出显示单词的n×n矩阵。"></a>突出显示单词的n×n矩阵。</h2><p>思路：<br>1.用两个数组来表示八个方向<br>const int dx_shift[10] = {1,1,0,-1,-1,-1,0,1};<br>const int dy_shift[10] = {0,-1,-1,-1,0,1,1,1};<br>2.在搜索到y之后沿着一个方向搜索izhong，直至不跳出边界为止，搜索完毕如果符合条件记录到另外一个数组中<br>3.j是步长，这里的j正好对应了yizhong 的第j位 所以正好可以对应起来<br>dx = x + j <em> dx_shift[i];<br>dy = y + j </em> dy_shift[i];</p><hr><h3 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1101 单词方阵</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n * n的矩阵</span></span><br><span class="line"><span class="comment">//方向数组表示八个方向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx_shift[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy_shift[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dx,dy;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> cmp = <span class="string">"yizhong"</span>;</span><br><span class="line"><span class="keyword">char</span> Map[maxn][maxn],result[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//x,y表示当前点的坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)<span class="comment">//枚举八个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">6</span>;j++)<span class="comment">//对同一方向连续探索6次,直至全部符合izhong为止</span></span><br><span class="line">       &#123;</span><br><span class="line">           dx = x + j * dx_shift[i];</span><br><span class="line">           dy = y + j * dy_shift[i];</span><br><span class="line">           <span class="keyword">if</span>(dx &lt; <span class="number">1</span> || dx &gt; n || dy &lt; <span class="number">1</span> || dy &gt; n)<span class="comment">//若越界直接跳出循环,换一种方向继续尝试</span></span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(Map[dx][dy] != cmp[j])<span class="comment">//如果探索的第j位不符合也跳出循环进行下一次搜索</span></span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span><span class="comment">//符合条件记录到数组中</span></span><br><span class="line">       &#123;</span><br><span class="line">           result[x][y] = <span class="string">'y'</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">6</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">           dx = x + j * dx_shift[i];</span><br><span class="line">           dy = y + j * dy_shift[i];</span><br><span class="line">           result[dx][dy] = Map[dx][dy];</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[i][j] == <span class="string">'y'</span>)<span class="comment">//如果搜索到y就进行搜索</span></span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;result[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八周小结</title>
      <link href="/2019/04/20/%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/04/20/%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一下这个星期发生的事情和心得吧"><a href="#记录一下这个星期发生的事情和心得吧" class="headerlink" title="记录一下这个星期发生的事情和心得吧"></a>记录一下这个星期发生的事情和心得吧</h1><p>星期二上午的体育课运气也太差了，从来都不点名的老师居然这次点名了555555555，害得我要去p一张请假条才行，星期三的早晨的效率挺高的，虽然逃了课。。。可是导员去查了前几个班的签到情况==，这尼玛谁顶得住啊，以后逃课要小心了、、、、今天看扬叔发的想法感觉好有道理</p><blockquote><blockquote><p>“学生上课的时候不听讲会被认为是违反课堂纪律，我如果觉得上课说话，那属于影响别人上课，但是我上课睡觉，看手机，只要我不发出声，那就不算违反课堂纪律”<br>“你可以说是对老师的不尊重，但是学生是没得选的，如果双方都有平等的选择地位，我不喜欢我可以走，可以不来上课，但是我现在必须要来上课，你就不能以不尊重为理由批评我上课不听讲”<br>“事实上，许多学生开始自己看公开课，看优质教材，用脚投票”<br>是啊，因为劝退的原因我上课不能听讲，老师还经常要点我发言来误会我，有的时候想想也真的很气，不过他说的话真的深感认同</p></blockquote></blockquote><h2 id="我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？"><a href="#我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？" class="headerlink" title="我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？"></a>我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？</h2><p>这个星期又很好的摸了一个星期呢，反正每个星期天的豪言壮志，最后都会被自己的懒惰所无情的击败呢</p><p>可能是这学期的课过得实在是太轻松了吧，导致自己好像找不会上学期的那种状态了，甚至可以说在学编程方面连寒假的状态都不如了。</p><p>可是呢，人可能就是这样的一种动物啊，总喜欢为自己找借口，遇到什么事情都喜欢自我安慰，真的是太脆弱了呢，既然选择了这条艰苦的道路，那么就应该不后悔不放弃嘛，再苦再累又能如何呢？那些厉害的大佬可能这一辈子都追不上了，但是这就是自己可以不继续每天学习的理由吗？</p><p>所以啊，已经过去了8个星期了，差不多两个月了，还有三个月，诶多，中间还要准备期中期末考试，啊真的是烦人，这学期的课我一点底都没有，跟物理相关的课程我就是白痴一个啊啊啊啊啊，反正再怎么样混了两年了，再混可能都毕不了业考不上研了，真是羡慕那些好好学习上课努力认真听讲，晚上回去天天打游戏，考试好好考就能搞个好绩点，然后保研爽一年什么的</p><p>哈哈哈哈哈，既然没有了这个选项那就不要天天幻想这啊那了，每天做好自己才是最重要的，所以啊，一定要坚持下去啊Azure，你不是为了你自己而活啊</p><p>下个星期的任务吧：<br>1.每天一道算法题(leetcode / 洛谷OJ)<br>2.这个星期一定要学会dfs和bfs算法！！！！！再拖我是狗<br>3.继续学习JavaScript，完成微信小程序的比赛<br>4.每天看一章程序员小灰关于算法的文章，不懂的一定要自己打出来才行！！！<br>5.自己手打代码！自己手打代码！自己手打代码！重要的事情说三遍！<br>6.王道数据结构继续阅读<br>7.张宇数学1000题每天写至少5题！！！<br>8.不要再说什么时间多了，要做的事情一堆呢！<br>9.预习物理化学的内容，把期中考试先过了再说</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录自己的心得体会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫评《ようこそ実力至上主義の教室へ》</title>
      <link href="/2019/04/14/20190414/"/>
      <url>/2019/04/14/20190414/</url>
      
        <content type="html"><![CDATA[<p>很遗憾前年7月的番昨天才被我偶然所发现，然后花了一天不到的时间就补完了，动画里面看到堀北就想起了雪乃，看到路哥就想起了大老师，然而看下来才知道这部番跟春物完全不同，春物是以校园恋爱为主题描述一群正常高中生的生活，而实教是以校园为背景展开一场斗智斗勇的作品，前者偏重于青春的描写，后者偏重于对人性的刻画</p><p>大老师和路哥(二老师)也是表面看上去差不多但其实完全不同的两个人，路哥心黑大老师心白。</p><p>路哥：我不是，我没有<br>大老师：我也不是谦虚，这锅我背了。</p><p>大老师花式自爆收获后宫，而路哥则是个性冷淡，这也不难理解，动画最后一集本以为路哥会在铃音最虚弱的时候闪亮登场，击败坏人，获得美人芳心，迎娶白富美自此走上人生巅峰。然而路哥却开启王之蔑视，他把除了他之外所有人都当成了他赢得胜利的棋子，他根本不相信任何人，动画也随之戛然而止，还有很多东西都没讲清楚，过了两年也没出第二季也让人感觉深感遗憾。<br>这也不难理解，因为从小说喵了个咪只有男主没有女主，动画还是强行魔改小说把铃音当做女主来写，之后几卷就没有铃音的戏份了，所以第二季很难做出来<br>(脑瘫作者就不能跟这个作品好好写个女主吗)</p><p>之所以很喜欢这部番，感觉它把学校同学关系的那种真实感描写了出来，你所能看到的只是一个人的表面，很多人其实都是表里不一的，更不用说那些伪善的人了，每个人都喜欢隐藏自己的真实的一面，表里如一的堀北和人格分裂的桔梗就形成了鲜明的对比，路哥也是，表面上一副面瘫脸人畜无害的模样，实际上他把每个人都当做棋子，只要最终赢得胜利的人是他就行了。</p><p>引用逼乎上的评价，“有实力者不滥用实力，无实力者也能生存的反实力至上主义教室”嗯我觉得也是对这番最贴切的描述了</p><p>同时顺便期待下今年春物的第三季吧，嗯，希望能遇到更多这样有意思的动画。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4月份不再摸鱼</title>
      <link href="/2019/04/07/dailylife/"/>
      <url>/2019/04/07/dailylife/</url>
      
        <content type="html"><![CDATA[<h1 id="4月份再摸鱼我是狗"><a href="#4月份再摸鱼我是狗" class="headerlink" title="4月份再摸鱼我是狗"></a><center>4月份再摸鱼我是狗</center></h1><p>懒真的是一种病，更可况还是懒癌晚期的我(<del>划掉</del>)，我的博客好像一个月前就弄好了吧，结果现在才想起来要写第一篇日志hhh无药可救了喵。</p><p>哼唧，重新看了看自己上个月立下的一个个flag，再摸鱼可能都毕不了业了呢，所以啊，azure从下个星期开始就要好好努力咯，虽然在学校没什么可以一起交流的人，室友也只会天天打游戏，像个傻子一样学化学，放假了还要跟导师免费搬砖，沦为廉价的劳动力还一副理所当然的样子，哼唧，我可不能变成这样呢，答应过别人不做一个普通人(<del>真的是很奇怪的要求呢</del>)</p><p>所以我再这么摸鱼下去就是混吃等死了，认识很多大佬每天都那么努力，再看看自己真的是，无话可说，有的时候不逼到最后一刻自己就不会醒悟的</p><p>既然选择了劝退这一道路就应该每天都一直努力嘛，其实可以做的事情真的是挺多的，但有的时候要学的东西太多了自己反而麻木了，诚然，在学习的道路上给自己的正反馈的确不多，但是这也不是自己能够为了逃避而找到了合理的借口x，所以我跟我基友一起商量不能再这么下去了，以后要计划好每天，每周以及每个月应该做到的计划，做到与没做到都要有奖励和惩罚才行。</p><p>每次自己做完的题解会发布到自己博客上，不管怎么样自己打出来的东西有一个记录也是极好的</p><p>下一周的计划:<br>1.每天一道leetcode或者洛谷的题目(周三除外)(不能丢掉算法这方面的内容啊)<br>2.这个星期学会dp算法和dfs&amp;bfs算法(dp摸了这么久了结果还没弄完我也是醉了)<br>3.学习JavaScript相关知识，为微信小程序比赛做准备！</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
