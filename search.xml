<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode-206</title>
      <link href="/2019/04/29/Leetcode-206/"/>
      <url>/2019/04/29/Leetcode-206/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><h3 id="难度-简单"><a href="#难度-简单" class="headerlink" title="难度:简单"></a>难度:简单</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><hr><p>自己的解法：<br>思路:至少需要三个结点p1,p2,p3来完成链表的逆序<br>首先从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点、第三个节点。<br>实现链表逆序的完整步骤如下：<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429174100.png" alt><br>1.以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173342.jpg" alt><br>2.三个临时节点引用p1，p2，p3分别向后移动一格位置。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173345.jpg" alt><br>3.重复第1步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173348.jpg" alt><br>4.重复第2步的工作，三个临时节点引用p1，p2，p3分别向后移动一格位置。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173351.jpg" alt><br>5.继续像这样子迭代下去，一直到p2是空为止。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173354.jpg" alt><br>6.最后，把head节点的next指向空，成为逆序链表的尾节点。并且把p1赋值给head，让p1所在的节点成为逆序链表的头节点。<br><img src="/2019/04/29/Leetcode-206/微信图片_20190429173356.jpg" alt></p><p>实现代码如下:<br>方法1：迭代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(head == NULL || head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;//当头结点为空，或者它的下一个结点为空的话，返回head</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *p1,*p2,*p3;//声明三个中间变量来交换</span><br><span class="line">    p1 = head;</span><br><span class="line">    p2 = head-&gt;next;</span><br><span class="line">    p3 = NULL;</span><br><span class="line"></span><br><span class="line">    while(p2 != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    head = p1;</span><br><span class="line">    return head;  </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><p>方法2: 递归<br>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø</p><p>若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。</p><p>n1 → … → nk-1 → nk → nk+1 ← … ← nm</p><p>我们希望 nk+1 的下一个节点指向 nk。</p><p>所以，nk.next.next = nk;</p><p>要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><p>实现代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) return head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><p>时间复杂度：O(n)。假设n是列表的长度，那么时间复杂度为O(n)。</p><p>空间复杂度：O(n)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到n层。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自己记录每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九周小结</title>
      <link href="/2019/04/28/%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/04/28/%E7%AC%AC%E4%B9%9D%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="第九周小结"><a href="#第九周小结" class="headerlink" title="第九周小结"></a>第九周小结</h1><p>不知不觉，一个星期又过去了，好像还是老样子，还是那么喜欢摸鱼，还是那么喜欢混，可能是上几个学期的努力过头了吧，这个学期实在是太轻松了，人就是这样，有的时候没有外部的压力可能就不逼自己，道理谁都懂，可谁都喜欢去犯懒，谁都喜欢去打游戏，看剧之类的，学习的过程是枯燥的，在这个漫长的过程中学习所能得到的正反馈太少了，所以本来从17年高考结束开始就决定学编程，到现在19年快两年了感觉根本没什么长进，我自己都觉得自己是个傻逼。</p><p>方向不对，再多努力也是白费，前几天看扬叔写的小说真的是触目惊心，王奋斗不努力吗？并不是他不努力，只是他一步又一步的犯错，本来人试错的成本就已经很高了，更何况还一而再再而三的试错？</p><p>没错，王奋斗的经历确实有点夸张，但正是因为这种夸张作者才想要深切的告诉我们，天坑专业不是一般人能读的啊，不管是学术界还是工业界，不管是去当导师廉价的劳动力还是去化工厂做危险的工作，我觉得都是不可接受的，所以更加坚定了我脱坑搞CS的决心</p><p>可怜我那几个室友，现在天天去实验室搬砖像个傻子一样，一点觉悟都没有，等过几年再看看他们是什么处境吧</p><hr><p>顺手记录下这个星期所发生的大事吧<br>星期一没上物化课，在宿舍摸了一整天，勉强完成了当天的任务</p><p>星期二上了体育课，把假条也给了老师看了，重新去踢了足球比赛<br>但是是真的累啊，不知道为什么每天晚上运动了那么久，结果去比赛还是累的要死。<br>但是下个星期二要测一千米啊啊啊啊，说实话挺烦的。</p><p>星期三上午去自习的效率还行，可能这是唯一让我感到满意的一天了吧，晚上去公园茂玩了一晚上，也挺开心的吧，虽然公园茂那里的小吃并不让我特别感兴趣</p><p>星期四一天没课，下午我又没去自习，本来是早就要跟基友一起去自习的，但是却都不互相监督，真的是无语呢，所以啊挺想找个跟我一样的人一起去考研一起去学习，甚至能一起恋爱呢(~大雾~)</p><p>星期五这一天可真的太无语了，早晨睡了一早晨不说，下午第一次准备去逃马原课，第一次去逃老师就点名，还是基友和我室友一起帮忙说我请假了才搞定的这事，现在想想就心有余悸，如果当时我一开始就冲过去就好了，真的是不幸中的万幸了<br>晚上去找到了我五一订的酒店的位置，看起来还不错吧，物超所值，差不多是花了上回出去住一晚上的价钱住了两个晚上，期待出去住呢<br>还去丹尼斯购物了一波，说实话有点小失望吧，其实大超市也没什么东西好买的，就买了两盒饼干和一点小零食，唯一让我开心的就是里面有卖仲景香菇酱的吧，以后可以不用到网上买了嘻嘻，然后又去公园茂转了一圈，转了半天都不知道吃什么，最后结果去吃了渔粉，说实话不是很好吃，而且也不值这个价55555555，最后是出去花了一百多真的是败家啊，以后要开始省钱了呢<br>星期六一天啥也没做，又浪了一整天，晚上还花了40点了汉堡王的外卖，而且因为天气的原因这一个星期都没跑步，我真的是太草了<br>今天星期天，上午摸过去，下去去自习室吧，晚上签个到去跑步然后就结束这一个星期吧</p><p>诶多这个星期买了小裙子订了酒店还有各种乱七八糟的居然花了1k了，这么抠门的我居然能花这么多，其实是心痛死了啊啊啊啊啊啊啊啊，如果不是上个月发现了闲鱼上可以赚点小钱现在我岂不是更穷5555555555555，而且最近闲鱼上买东西的越来越少了，我应该要想点办法去卖更多的东西了，诶多争取以后一个月起码有2K才行？</p><p>所以继续明确一下下个星期的目标和每天的任务吧，不多也不少，但是每天要坚持完成，没完成就给自己惩罚！<br>每天的任务:<br>1.开始准备6级考试，每天十五个英语单词，期中考试过后每天还要两篇阅读理解<br>2.张宇1000题每天五题<br>3.洛谷OJ or Leetcode 每天一题<br>4.程序员小灰 or 极客时间 每天一章<br>5.微信小程序(这个比赛我将信将疑了，因为感觉学JavaScript和那个好费劲，但毕竟是我提出的计划，嘛有时间就去看看吧)<br>6.王道数据结构开始看，题目也开始做吧<br>7.准备期中考试，物化重点复习，结构次重点复习。(五一看看能不能复习一哈子，然后5.11之前复习完)</p><hr><p>好了，总结和感悟就这么多吧，以后争取至少每个星期写篇日记吧，还要把刷过的每一道题都放到博客上来，嗯，过几天再把评论区和其他东西完善一下，如果可以的话再搞个域名就更好了，那么Azure加油吧！你现在不是一个人在战斗呢。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷Oj-P1101</title>
      <link href="/2019/04/24/luoguOj-P1101/"/>
      <url>/2019/04/24/luoguOj-P1101/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷OJ-P1101"><a href="#洛谷OJ-P1101" class="headerlink" title="洛谷OJ-P1101"></a>洛谷OJ-P1101</h1><h2 id="P1101-单词方阵"><a href="#P1101-单词方阵" class="headerlink" title="P1101 单词方阵"></a>P1101 单词方阵</h2><p>题目描述<br>给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">    8                     输出：</span><br><span class="line">    qyizhong              *yizhong</span><br><span class="line">    gydthkjy              gy******</span><br><span class="line">    nwidghji              n*i*****</span><br><span class="line">    orbzsfgz              o**z****</span><br><span class="line">    hhgrhwth              h***h***</span><br><span class="line">    zzzzzozo              z****o**</span><br><span class="line">    iwdfrgng              i*****n*</span><br><span class="line">    yyyygggg              y******g</span><br></pre></td></tr></table></figure></p><p>输入输出格式<br>输入格式：<br>第一行输入一个数n。(7≤n≤100)。</p><p>第二行开始输入n×n的字母矩阵。</p><p>输出格式：</p><h2 id="突出显示单词的n×n矩阵。"><a href="#突出显示单词的n×n矩阵。" class="headerlink" title="突出显示单词的n×n矩阵。"></a>突出显示单词的n×n矩阵。</h2><p>思路：<br>1.用两个数组来表示八个方向<br>const int dx_shift[10] = {1,1,0,-1,-1,-1,0,1};<br>const int dy_shift[10] = {0,-1,-1,-1,0,1,1,1};<br>2.在搜索到y之后沿着一个方向搜索izhong，直至不跳出边界为止，搜索完毕如果符合条件记录到另外一个数组中<br>3.j是步长，这里的j正好对应了yizhong 的第j位 所以正好可以对应起来<br>dx = x + j <em> dx_shift[i];<br>dy = y + j </em> dy_shift[i];</p><hr><h3 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//P1101 单词方阵</span><br><span class="line">int n;//n * n的矩阵</span><br><span class="line">//方向数组表示八个方向</span><br><span class="line">const int dx_shift[10] = &#123;1,1,0,-1,-1,-1,0,1&#125;;</span><br><span class="line">const int dy_shift[10] = &#123;0,-1,-1,-1,0,1,1,1&#125;;</span><br><span class="line">int dx,dy;</span><br><span class="line">const int maxn = 110;</span><br><span class="line">const string cmp = &quot;yizhong&quot;;</span><br><span class="line">char Map[maxn][maxn],result[maxn][maxn];</span><br><span class="line">void dfs(int x,int y)//x,y表示当前点的坐标</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0;i &lt; 8;i++)//枚举八个方向</span><br><span class="line">    &#123;</span><br><span class="line">       int flag = 1;</span><br><span class="line">       for(int j = 1;j &lt;= 6;j++)//对同一方向连续探索6次,直至全部符合izhong为止</span><br><span class="line">       &#123;</span><br><span class="line">           dx = x + j * dx_shift[i];</span><br><span class="line">           dy = y + j * dy_shift[i];</span><br><span class="line">           if(dx &lt; 1 || dx &gt; n || dy &lt; 1 || dy &gt; n)//若越界直接跳出循环,换一种方向继续尝试</span><br><span class="line">           &#123;</span><br><span class="line">               flag = 0;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           if(Map[dx][dy] != cmp[j])//如果探索的第j位不符合也跳出循环进行下一次搜索</span><br><span class="line">           &#123;</span><br><span class="line">               flag = 0;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(flag == 0)</span><br><span class="line">       &#123;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       else//符合条件记录到数组中</span><br><span class="line">       &#123;</span><br><span class="line">           result[x][y] = &apos;y&apos;;</span><br><span class="line">         for(int j = 1;j &lt;= 6;j++)</span><br><span class="line">         &#123;</span><br><span class="line">           dx = x + j * dx_shift[i];</span><br><span class="line">           dy = y + j * dy_shift[i];</span><br><span class="line">           result[dx][dy] = Map[dx][dy];</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;Map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i][j] = &apos;*&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(Map[i][j] == &apos;y&apos;)//如果搜索到y就进行搜索</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;result[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 洛谷OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自己记录每天ac的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八周小结</title>
      <link href="/2019/04/20/%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/04/20/%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一下这个星期发生的事情和心得吧"><a href="#记录一下这个星期发生的事情和心得吧" class="headerlink" title="记录一下这个星期发生的事情和心得吧"></a>记录一下这个星期发生的事情和心得吧</h1><p>星期二上午的体育课运气也太差了，从来都不点名的老师居然这次点名了555555555，害得我要去p一张请假条才行，星期三的早晨的效率挺高的，虽然逃了课。。。可是导员去查了前几个班的签到情况==，这尼玛谁顶得住啊，以后逃课要小心了、、、、今天看扬叔发的想法感觉好有道理</p><blockquote><blockquote><p>“学生上课的时候不听讲会被认为是违反课堂纪律，我如果觉得上课说话，那属于影响别人上课，但是我上课睡觉，看手机，只要我不发出声，那就不算违反课堂纪律”<br>“你可以说是对老师的不尊重，但是学生是没得选的，如果双方都有平等的选择地位，我不喜欢我可以走，可以不来上课，但是我现在必须要来上课，你就不能以不尊重为理由批评我上课不听讲”<br>“事实上，许多学生开始自己看公开课，看优质教材，用脚投票”<br>是啊，因为劝退的原因我上课不能听讲，老师还经常要点我发言来误会我，有的时候想想也真的很气，不过他说的话真的深感认同</p></blockquote></blockquote><h2 id="我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？"><a href="#我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？" class="headerlink" title="我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？"></a>我可以去看那些更好的公开课，何必要把时间浪费在你身上呢？</h2><p>这个星期又很好的摸了一个星期呢，反正每个星期天的豪言壮志，最后都会被自己的懒惰所无情的击败呢</p><p>可能是这学期的课过得实在是太轻松了吧，导致自己好像找不会上学期的那种状态了，甚至可以说在学编程方面连寒假的状态都不如了。</p><p>可是呢，人可能就是这样的一种动物啊，总喜欢为自己找借口，遇到什么事情都喜欢自我安慰，真的是太脆弱了呢，既然选择了这条艰苦的道路，那么就应该不后悔不放弃嘛，再苦再累又能如何呢？那些厉害的大佬可能这一辈子都追不上了，但是这就是自己可以不继续每天学习的理由吗？</p><p>所以啊，已经过去了8个星期了，差不多两个月了，还有三个月，诶多，中间还要准备期中期末考试，啊真的是烦人，这学期的课我一点底都没有，跟物理相关的课程我就是白痴一个啊啊啊啊啊，反正再怎么样混了两年了，再混可能都毕不了业考不上研了，真是羡慕那些好好学习上课努力认真听讲，晚上回去天天打游戏，考试好好考就能搞个好绩点，然后保研爽一年什么的</p><p>哈哈哈哈哈，既然没有了这个选项那就不要天天幻想这啊那了，每天做好自己才是最重要的，所以啊，一定要坚持下去啊Azure，你不是为了你自己而活啊</p><p>下个星期的任务吧：<br>1.每天一道算法题(leetcode / 洛谷OJ)<br>2.这个星期一定要学会dfs和bfs算法！！！！！再拖我是狗<br>3.继续学习JavaScript，完成微信小程序的比赛<br>4.每天看一章程序员小灰关于算法的文章，不懂的一定要自己打出来才行！！！<br>5.自己手打代码！自己手打代码！自己手打代码！重要的事情说三遍！<br>6.王道数据结构继续阅读<br>7.张宇数学1000题每天写至少5题！！！<br>8.不要再说什么时间多了，要做的事情一堆呢！<br>9.预习物理化学的内容，把期中考试先过了再说</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录自己的心得体会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫评《ようこそ実力至上主義の教室へ》</title>
      <link href="/2019/04/14/20190414/"/>
      <url>/2019/04/14/20190414/</url>
      
        <content type="html"><![CDATA[<p>很遗憾前年7月的番昨天才被我偶然所发现，然后花了一天不到的时间就补完了，动画里面看到堀北就想起了雪乃，看到路哥就想起了大老师，然而看下来才知道这部番跟春物完全不同，春物是以校园恋爱为主题描述一群正常高中生的生活，而实教是以校园为背景展开一场斗智斗勇的作品，前者偏重于青春的描写，后者偏重于对人性的刻画</p><p>大老师和路哥(二老师)也是表面看上去差不多但其实完全不同的两个人，路哥心黑大老师心白。</p><p>路哥：我不是，我没有<br>大老师：我也不是谦虚，这锅我背了。</p><p>大老师花式自爆收获后宫，而路哥则是个性冷淡，这也不难理解，动画最后一集本以为路哥会在铃音最虚弱的时候闪亮登场，击败坏人，获得美人芳心，迎娶白富美自此走上人生巅峰。然而路哥却开启王之蔑视，他把除了他之外所有人都当成了他赢得胜利的棋子，他根本不相信任何人，动画也随之戛然而止，还有很多东西都没讲清楚，过了两年也没出第二季也让人感觉深感遗憾。<br>这也不难理解，因为从小说喵了个咪只有男主没有女主，动画还是强行魔改小说把铃音当做女主来写，之后几卷就没有铃音的戏份了，所以第二季很难做出来<br>(脑瘫作者就不能跟这个作品好好写个女主吗)</p><p>之所以很喜欢这部番，感觉它把学校同学关系的那种真实感描写了出来，你所能看到的只是一个人的表面，很多人其实都是表里不一的，更不用说那些伪善的人了，每个人都喜欢隐藏自己的真实的一面，表里如一的堀北和人格分裂的桔梗就形成了鲜明的对比，路哥也是，表面上一副面瘫脸人畜无害的模样，实际上他把每个人都当做棋子，只要最终赢得胜利的人是他就行了。</p><p>引用逼乎上的评价，“有实力者不滥用实力，无实力者也能生存的反实力至上主义教室”嗯我觉得也是对这番最贴切的描述了</p><p>同时顺便期待下今年春物的第三季吧，嗯，希望能遇到更多这样有意思的动画。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4月份不再摸鱼</title>
      <link href="/2019/04/07/dailylife/"/>
      <url>/2019/04/07/dailylife/</url>
      
        <content type="html"><![CDATA[<p>#<center>4月份再摸鱼我是狗</center>&gt;#<br>懒真的是一种病，更可况还是懒癌晚期的我(<del>划掉</del>)，我的博客好像一个月前就弄好了吧，结果现在才想起来要写第一篇日志hhh无药可救了喵。</p><p>哼唧，重新看了看自己上个月立下的一个个flag，再摸鱼可能都毕不了业了呢，所以啊，azure从下个星期开始就要好好努力咯，虽然在学校没什么可以一起交流的人，室友也只会天天打游戏，像个傻子一样学化学，放假了还要跟导师免费搬砖，沦为廉价的劳动力还一副理所当然的样子，哼唧，我可不能变成这样呢，答应过别人不做一个普通人(<del>真的是很奇怪的要求呢</del>)</p><p>所以我再这么摸鱼下去就是混吃等死了，认识很多大佬每天都那么努力，再看看自己真的是，无话可说，有的时候不逼到最后一刻自己就不会醒悟的</p><p>既然选择了劝退这一道路就应该每天都一直努力嘛，其实可以做的事情真的是挺多的，但有的时候要学的东西太多了自己反而麻木了，诚然，在学习的道路上给自己的正反馈的确不多，但是这也不是自己能够为了逃避而找到了合理的借口x，所以我跟我基友一起商量不能再这么下去了，以后要计划好每天，每周以及每个月应该做到的计划，做到与没做到都要有奖励和惩罚才行。</p><p>每次自己做完的题解会发布到自己博客上，不管怎么样自己打出来的东西有一个记录也是极好的</p><p>下一周的计划:<br>1.每天一道leetcode或者洛谷的题目(周三除外)(不能丢掉算法这方面的内容啊)<br>2.这个星期学会dp算法和dfs&amp;bfs算法(dp摸了这么久了结果还没弄完我也是醉了)<br>3.学习JavaScript相关知识，为微信小程序比赛做准备！</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手写的一点东西 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
